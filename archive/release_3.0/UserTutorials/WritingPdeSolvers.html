<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>UserTutorials/WritingPdeSolvers - Chaste</title>
    <link rel="stylesheet" href="https://chaste.github.io/old_releases/trac.css" type="text/css" />
    <link rel="stylesheet" href="https://chaste.github.io/old_releases/wiki.css" type="text/css" />
    <link rel="stylesheet" href="/trac/css/site.css" type="text/css" />
    <style type="text/css">
/* Link styles */
:link, :visited, a em {
 text-decoration: none;
 color: #283f6b;
 border-bottom: 1px dotted #bbb;
}
/*
:link:hover, :visited:hover {
 background-color: #eee;
 color: #555;
}
*/
    </style>

  </head>
  <body>
    <div id="banner">
      <div id="header">
        <p>
          <a id="logo" href="https://chaste.github.io/"><img src="https://chaste.github.io/chaste_0256.png" alt="Chaste logo" height="60" /></a>
          <em>Documentation for <a href="https://chaste.github.io/old_releases/release_3.0/">Release 3.0</a>.</em>
        </p>
      </div>
    </div>
    <p>&nbsp;</p>
    <div id="content" class="wiki">
      <p class="path noprint">
        <a class="pathentry" title="View UserTutorials" href="https://chaste.github.io/old_releases/release_3.0/UserTutorials.html">UserTutorials</a><span class="pathentry sep">/</span><a class="pathentry" title="View UserTutorials/WritingPdeSolvers" href="https://chaste.github.io/old_releases/release_3.0/UserTutorials/WritingPdeSolvers.html">WritingPdeSolvers</a>
        <br style="clear: both" />
      </p>
      <div class="wikipage searchable">
        
          <p>
This tutorial is automatically generated from the file trunk/pde/test/tutorials/TestWritingPdeSolversTutorial.hpp at revision <a class="changeset" href="/cgi-bin/trac.cgi/changeset/14534" title="tutorial comments">r14534</a>.
Note that the code is given in full at the bottom of the page.
</p>
<h2 id="Introduction">Introduction</h2>
<p>
Chaste can be used to set up solvers for more general (coupled) PDEs. To do this the
user just needs to code up the integrands of any finite element (FE) matrices or vectors,
without having to deal with set-up, looping over elements, numerical quadrature, assembly
or solving the linear system. If you have a set of coupled linear PDEs for which it is
appropriate to use linear basis functions for each unknown (for example, a reaction-diffusion
system), then it is relatively straightforward to set up a solver that will be parallel and
reliable, since all the base components are heavily tested.
</p>
<p>
Some solvers for general simple (uncoupled) linear PDEs are already provided in Chaste, such
as the <tt>SimpleLinearEllipticSolver</tt>. These are for PDEs that can be written in a generic
form (<tt>SimpleLinearEllipticPde</tt>, for example). However <i>coupled</i> PDEs can't
be easily written in generic form, so the user has to write their own solver. In this tutorial
we explain how to do this.
</p>
<p>
For this tutorial the user needs to have read the solving-PDEs tutorials. It may also be
helpful to read the associated <a class="wiki" href="https://chaste.github.io/old_releases/release_3.0/ChasteGuides/NmoodLectureNotes.html">lectures notes</a>, in
particular the slides on solving equations using finite elements if you are not familiar
with this (lecture 2), the slides on the general design of the Chaste finite element solvers
(lecture 3), and the first part of lecture 4.
</p>
<p>
Let us use the terminology "assembled in an FE manner" for any matrix or vector that is
defined via a volume/surface/line integral, and which is constructed by: looping over
elements (or surface elements, etc); computing the elemental contribution (i.e. a small
matrix/vector) using numerical quadrature; and adding to the full matrix/vector.
</p>
<p>
We only consider linear problems here. In these problems the discretised FE problem leads
to a linear system, Ax=b, to be solved once in static problems and at each time step in
time-dependent problems. There are two cases to be distinguished. The first case is where
BOTH A and b are assembled in an FE manner, b possibly being composed of a volume integral
plus a surface integral. The other case is where this is not true, for example where b = Mc+d,
where the vector d and matrix M are assembled in an FE manner, but not the vector c.
</p>
<p>
The Chaste PDE classes include ASSEMBLER classes, for setting up anything assembled in an
FE manner, and SOLVER classes, for setting up linear systems. In the general case, solvers
need to own assemblers for setting up each part of the linear system. However for the first
case described above (in which both A and b in Ax=b are assembled), we can use the design
where the solver IS AN assembler. We illustrate how to do this in the first tutorial.
</p>
<h2 id="Writingsolvers">Writing solvers</h2>
<p>
Let us write a solver for the coupled 2-unknown problem
</p>
<pre class="wiki">Laplacian(u) + v = f(x,y)
Laplacian(v) + u = g(x,y)
</pre><p>
where <tt>Laplacian(u)</tt> of course represents u<sub>xx</sub>+u<sub>yy</sub> and where f and g are chosen so that,
with zero-dirichlet boundary conditions, the solution is given by u = sin(pi*x)sin(pi*x),
v = sin(2*pi*x)sin(2*pi*x).
</p>
<p>
( As a brief aside, note that the solver we write will in fact work with general Dirichlet-Neumann
boundary conditions, though the test will only provide all-Dirichlet boundary conditions. We
save a discussion on general Dirichlet-Neumann boundary conditions for the second example.)
</p>
<p>
Using linear basis functions, and a mesh with N nodes, the linear system that needs to be set up is
of size 2N by 2N, and in block form is:
</p>
<pre class="wiki">[ K   -M  ] [U]  =  [b1]
[ -M   K  ] [V]     [b2]
</pre><p>
where <tt>K</tt> is the stiffness matrix, <tt>M</tt> the mass matrix, <tt>U</tt> the vector of nodal values
of u, <tt>V</tt> the vector of nodal values of v, <tt>b1</tt> the vector with entries <tt>integral(f\phi_i dV)</tt> (i=1,..,N)
and <tt>b2</tt> has entries <tt>integral(g\phi_i dV)</tt> (here <tt>phi_i</tt> are the linear basis functions).
</p>
<p>
This is the linear system which we now write a solver to set up. <strong>Note</strong>, however, that
the main Chaste solvers assume a STRIPED data format, ie that the unknown vector
is <tt>[U_1 V_1 U_2 V_2 .. U_n V_n]</tt>, not <tt>[ U_1 U_2 .. U_n V_1 V_2 .. V_n]</tt>. <i>We write down
equations in block form as it makes things clearer, but have to remember that the code
deals with STRIPED data structures.</i> Striping is used in the code for parallelisation reasons.
</p>
<p>
These are some basic includes as in the solving-PDEs tutorials
</p>
<div class="code"><pre><span class="cp">#include &lt;cxxtest/TestSuite.h&gt;
#include "TetrahedralMesh.hpp"
#include "TrianglesMeshReader.hpp"
#include "BoundaryConditionsContainer.hpp"
#include "ConstBoundaryCondition.hpp"
#include "PetscSetupAndFinalize.hpp"
#include "TrianglesMeshWriter.hpp"
</span></pre></div><p>
We need to include the following two classes if we are going to use a combination of
(element_dim, space_dim, problem_dim) that isn't explicitly instantiated in
<tt>BoundaryConditionsContainer.cpp</tt> (see the bottom of that file) (without these includes this test will
fail to link).
</p>
<div class="code"><pre><span class="cp">#include "BoundaryConditionsContainerImplementation.hpp"
#include "AbstractBoundaryConditionsContainerImplementation.hpp"
</span></pre></div><p>
These two classes will be used in writing the solver
</p>
<div class="code"><pre><span class="cp">#include "AbstractAssemblerSolverHybrid.hpp"
#include "AbstractStaticLinearPdeSolver.hpp"
</span></pre></div><p>
We will solve a second problem, below, which will be time-dependent and will
require the following class
</p>
<div class="code"><pre><span class="cp">#include "AbstractDynamicLinearPdeSolver.hpp"
</span></pre></div><p>
The linear system is Ax=b where A and b are FE assembled, so we can use the solver-is-an-assembler
design. To construct our solver, we inherit from <tt>AbstractAssemblerSolverHybrid</tt> which links
the solver clases to the assembler classes, and <tt>AbstractStaticLinearPdeSolver</tt>. (For time-dependent
problems, the second parent would be <tt>AbstractDynamicLinearPdeSolver</tt>). Note the template
parameter <tt>PROBLEM_DIM</tt> below, in this case it is 2 as there are two unknowns.
</p>
<div class="code"><pre><span class="k">class</span> <span class="nc">MyTwoVariablePdeSolver</span>
    <span class="o">:</span> <span class="k">public</span> AbstractAssemblerSolverHybrid<span class="o">&lt;</span><span class="mi">2</span><span class="c">/*elem_dim*/</span><span class="p">,</span><span class="mi">2</span><span class="c">/*space_dim*/</span><span class="p">,</span><span class="mi">2</span><span class="c">/*problem_dim*/</span><span class="p">,</span>NORMAL<span class="c">/*amount of interpolation*/</span><span class="o">&gt;</span><span class="p">,</span>
      <span class="k">public</span> AbstractStaticLinearPdeSolver<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
</pre></div><p>
The function f
</p>
<div class="code"><pre>    <span class="kt">double</span> f<span class="p">(</span><span class="kt">double</span> x<span class="p">,</span><span class="kt">double</span> y<span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span>M_PI<span class="o">*</span>M_PI<span class="o">*</span>sin<span class="p">(</span>M_PI<span class="o">*</span>x<span class="p">)</span><span class="o">*</span>sin<span class="p">(</span>M_PI<span class="o">*</span>y<span class="p">)</span> <span class="o">+</span> sin<span class="p">(</span><span class="mi">2</span><span class="o">*</span>M_PI<span class="o">*</span>x<span class="p">)</span><span class="o">*</span>sin<span class="p">(</span><span class="mi">2</span><span class="o">*</span>M_PI<span class="o">*</span>y<span class="p">);</span>
    <span class="p">}</span>
</pre></div><p>
The function g
</p>
<div class="code"><pre>    <span class="kt">double</span> g<span class="p">(</span><span class="kt">double</span> x<span class="p">,</span><span class="kt">double</span> y<span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">8</span><span class="o">*</span>M_PI<span class="o">*</span>M_PI<span class="o">*</span>sin<span class="p">(</span><span class="mi">2</span><span class="o">*</span>M_PI<span class="o">*</span>x<span class="p">)</span><span class="o">*</span>sin<span class="p">(</span><span class="mi">2</span><span class="o">*</span>M_PI<span class="o">*</span>y<span class="p">)</span> <span class="o">+</span> sin<span class="p">(</span>M_PI<span class="o">*</span>x<span class="p">)</span><span class="o">*</span>sin<span class="p">(</span>M_PI<span class="o">*</span>y<span class="p">);</span>
    <span class="p">}</span>
</pre></div><p>
The abstract assembler parent classes know how to assemble matrices and vectors, but the concrete
class needs to provide the integrand of the elemental contribution to A and b. This first
method returns the elemental contribution of the matrix A, given the provided bases
(<tt>rPhi</tt>, <tt>rGradPhi</tt>). The '3's here represent the number of bases per element (ie the number
of nodes as linear bases are being used). The returned matrix is 6 by 6 (problem_dim *
num_bases_per_element = 2*3 = 6).
</p>
<div class="code"><pre>    c_matrix<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="mi">3</span><span class="o">&gt;</span> ComputeMatrixTerm<span class="p">(</span>c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;&amp;</span> rPhi <span class="c">/* the three bases for the current element, evaluated at the current quad pt*/</span><span class="p">,</span>
                                               c_matrix<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;&amp;</span> rGradPhi <span class="c">/* gradients of the three bases */</span><span class="p">,</span>
                                               ChastePoint<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;&amp;</span> rX           <span class="c">/* physical coordinate of quad point */</span><span class="p">,</span>
                                               c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;&amp;</span> rU       <span class="c">/* current solution (unused here as a linear static problem */</span><span class="p">,</span>
                                               c_matrix<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;&amp;</span> rGradU <span class="c">/* current solution gradient (unused here as a linear static problem */</span><span class="p">,</span>
                                               Element<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> pElement<span class="p">)</span>
    <span class="p">{</span>
</pre></div><p>
Set up the matrix, which corresponds to the elemental contribution for the matrix
written above, taking into account the striped nature of the matrices and vectors.
(Note: the following can be done more efficiently using matrix slices and products,
see <tt>BidomainAssembler</tt> for example).
</p>
<div class="code"><pre>        c_matrix<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="mi">3</span><span class="o">&gt;</span> ret <span class="o">=</span> zero_matrix<span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="mi">3</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> i<span class="o">=</span><span class="mi">0</span><span class="p">;</span> i<span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> i<span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> j<span class="o">=</span><span class="mi">0</span><span class="p">;</span> j<span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> j<span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> k<span class="o">=</span><span class="mi">0</span><span class="p">;</span> k<span class="o">&lt;</span><span class="mi">2</span><span class="p">;</span> k<span class="o">++</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="c">// stiffness matrix on diagonal 'blocks'
</span>                    ret<span class="p">(</span><span class="mi">2</span><span class="o">*</span>i<span class="p">,</span>  <span class="mi">2</span><span class="o">*</span>j<span class="p">)</span>   <span class="o">+=</span> rGradPhi<span class="p">(</span>k<span class="p">,</span>i<span class="p">)</span><span class="o">*</span>rGradPhi<span class="p">(</span>k<span class="p">,</span>j<span class="p">);</span>
                    ret<span class="p">(</span><span class="mi">2</span><span class="o">*</span>i<span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span>j<span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+=</span> rGradPhi<span class="p">(</span>k<span class="p">,</span>i<span class="p">)</span><span class="o">*</span>rGradPhi<span class="p">(</span>k<span class="p">,</span>j<span class="p">);</span>
                <span class="p">}</span>

                <span class="c">// (negative) mass matrix on off-diagonal 'blocks'
</span>                ret<span class="p">(</span><span class="mi">2</span><span class="o">*</span>i<span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span>j<span class="p">)</span>   <span class="o">=</span> <span class="o">-</span>rPhi<span class="p">(</span>i<span class="p">)</span><span class="o">*</span>rPhi<span class="p">(</span>j<span class="p">);</span>
                ret<span class="p">(</span><span class="mi">2</span><span class="o">*</span>i<span class="p">,</span>   <span class="mi">2</span><span class="o">*</span>j<span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span>rPhi<span class="p">(</span>i<span class="p">)</span><span class="o">*</span>rPhi<span class="p">(</span>j<span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> ret<span class="p">;</span>
    <span class="p">}</span>
</pre></div><p>
Similarly compute the elemental contribution to the RHS vector
</p>
<div class="code"><pre>    c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="mi">3</span><span class="o">&gt;</span> ComputeVectorTerm<span class="p">(</span>c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> rPhi<span class="p">,</span>
                                           c_matrix<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="o">&gt;&amp;</span> rGradPhi<span class="p">,</span>
                                           ChastePoint<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;&amp;</span> rX<span class="p">,</span>
                                           c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;&amp;</span> rU<span class="p">,</span>
                                           c_matrix<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;&amp;</span> rGradU<span class="p">,</span>
                                           Element<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> pElement<span class="p">)</span>
    <span class="p">{</span>
        c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="mi">3</span><span class="o">&gt;</span> ret<span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> i<span class="o">=</span><span class="mi">0</span><span class="p">;</span> i<span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> i<span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            ret<span class="p">(</span><span class="mi">2</span><span class="o">*</span>i<span class="p">)</span>   <span class="o">=</span> <span class="o">-</span>f<span class="p">(</span>rX<span class="p">[</span><span class="mi">0</span><span class="p">],</span>rX<span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> rPhi<span class="p">(</span>i<span class="p">);</span>
            ret<span class="p">(</span><span class="mi">2</span><span class="o">*</span>i<span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span>g<span class="p">(</span>rX<span class="p">[</span><span class="mi">0</span><span class="p">],</span>rX<span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> rPhi<span class="p">(</span>i<span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> ret<span class="p">;</span>
    <span class="p">}</span>
</pre></div><p>
These classes which inherit from both assemblers and solvers must
provide the following method, which links the two. Just copy and paste
the following.
</p>
<div class="code"><pre>    <span class="kt">void</span> SetupLinearSystem<span class="p">(</span>Vec currentSolution<span class="p">,</span> <span class="kt">bool</span> computeMatrix<span class="p">)</span>
    <span class="p">{</span>
        SetupGivenLinearSystem<span class="p">(</span>currentSolution<span class="p">,</span> computeMatrix<span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span>mpLinearSystem<span class="p">);</span>
    <span class="p">}</span>

<span class="k">public</span><span class="o">:</span>
</pre></div><p>
The constructor takes in a mesh and boundary conditions container, and passes
them to the parent classes.
</p>
<div class="code"><pre>    MyTwoVariablePdeSolver<span class="p">(</span>TetrahedralMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> pMesh<span class="p">,</span>
                           BoundaryConditionsContainer<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> pBoundaryConditions<span class="p">)</span>
        <span class="o">:</span> AbstractAssemblerSolverHybrid<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span>NORMAL<span class="o">&gt;</span><span class="p">(</span>pMesh<span class="p">,</span>pBoundaryConditions<span class="p">),</span>
          AbstractStaticLinearPdeSolver<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span>pMesh<span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div><p>
That is the solver written. The usage is the same as see the PDE solvers described in the
previous tutorials - have a look at the first test below.
</p>
<h2 id="Asolverof3parabolicequations">A solver of 3 parabolic equations</h2>
<p>
Let us also write a solver for the following problem, which is composed of 3 parabolic PDEs
</p>
<pre class="wiki">u_t = Laplacian(u) + v
v_t = Laplacian(v) + u + 2w
w_t = Laplacian(w) + g(t,x,y)
</pre><p>
where g(t,x,y) = t if x&gt;0.5 and 0 otherwise. This time we assume general
Dirichlet-Neumann boundary conditions will be specified.
</p>
<p>
The <tt>AbstractAssemblerSolverHybrid</tt> deals with the Dirichlet and Neumann boundary parts of the implementation,
so, we, the writer of the solver, don't have to worry about this. The user has to realise though that they are
specifying NATURAL Neumann BCs, which are whatever appears naturally in the weak form of the problem. In this case, natural
Neumann BCs are specification of: <tt>du/dn = s1, dv/dn = s2, dw/dn = s3</tt>, which coincide with usual Neumann BCs. However,
suppose the last equation was <tt>w_t = Laplacian(w) + Div(D grad(u))</tt>, then the natural BCs would be:
<tt>du/dn = s1, dv/dn = s2, dw/dn + (Dgradu).n = s3</tt>.
</p>
<p>
We need to choose a time-discretisation. Let us choose an implicit discretisation, ie
</p>
<pre class="wiki">(u^{n+1} - u^{n})/dt = Laplacian(u^{n+1}) + v^{n+1}
(v^{n+1} - v^{n})/dt = Laplacian(v^{n+1}) + u^{n+1} + 2w^{n+1}
(w^{n+1} - w^{n})/dt = Laplacian(w^{n+1}) + g(t^{n+1},x)
</pre><p>
Using linear basis functions, and a mesh with N nodes, the linear system that needs to be set up is
of size 3N by 3N, and in block form is:
</p>
<pre class="wiki">[ M/dt+K     -M       0    ] [U^{n+1}]  =  [b1]  +  [c1]
[   -M     M/dt+K    -2M   ] [V^{n+1}]     [b2]  +  [c2]
[    0        0     M/dt+K ] [W^{n+1}]     [b3]  +  [c3]
</pre><p>
where <tt>K</tt> is the stiffness matrix, <tt>M</tt> the mass matrix, <tt>U^n</tt> the vector of nodal values
of u at time t_n, etc, <tt>b1</tt> has entries <tt>integral( (u^n/dt)phi_i dV )</tt>, and similarly for
<tt>b2</tt> and <tt>b3</tt>. Writing the Neumann boundary conditions for
u as <tt>du/dn = s1(x,y)</tt> on Gamma, a subset of the boundary, then <tt>c1</tt> has entries
<tt>integral_over_Gamma (s1*phi_i dS)</tt>, and similarly for <tt>c2</tt> and <tt>c3</tt>.
</p>
<p>
Let us create a solver for this linear system, which will be written in a way in which the RHS
vector is assembled in an FE manner, so that the solver-is-an-assembler design can be used.
Note that this solver inherits from <tt>AbstractDynamicLinearPdeSolver</tt> and PROBLEM_DIM is now equal
to 3. We don't have to worry about setting up [c1 c2 c3] (we just need to take in a <tt>BoundaryConditionsContainer</tt>
and the parent will use it in assembling this vector). We do however have to tell it
how to assemble the volume integral part of the RHS vector, and the LHS matrix.
</p>
<div class="code"><pre><span class="k">class</span> <span class="nc">ThreeParabolicPdesSolver</span>
    <span class="o">:</span> <span class="k">public</span> AbstractAssemblerSolverHybrid<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span>NORMAL<span class="o">&gt;</span><span class="p">,</span>
      <span class="k">public</span> AbstractDynamicLinearPdeSolver<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
</pre></div><p>
Define the function g(t,x,y)
</p>
<div class="code"><pre>    <span class="kt">double</span> g<span class="p">(</span><span class="kt">double</span> t<span class="p">,</span> ChastePoint<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;&amp;</span> rX<span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> t<span class="o">*</span><span class="p">(</span>rX<span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mf">0.5</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div><p>
Provide the (elemental contribution to the) LHS matrix. The matrix is 9 by 9, where
9 = 3*3 = PROBLEM_DIM * NUM_NODES_PER_ELEMENT
</p>
<div class="code"><pre>    c_matrix<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span><span class="mi">3</span><span class="o">&gt;</span> ComputeMatrixTerm<span class="p">(</span>c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;&amp;</span> rPhi<span class="p">,</span>
                                               c_matrix<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;&amp;</span> rGradPhi<span class="p">,</span>
                                               ChastePoint<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;&amp;</span> rX<span class="p">,</span>
                                               c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;&amp;</span> rU<span class="p">,</span>
                                               c_matrix<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;&amp;</span> rGradU<span class="p">,</span>
                                               Element<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> pElement<span class="p">)</span>
    <span class="p">{</span>
        c_matrix<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">9</span><span class="o">&gt;</span> ret <span class="o">=</span> zero_matrix<span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="mi">9</span><span class="p">);</span>

        <span class="c">// this is how to get the current timestep
</span>        <span class="kt">double</span> dt <span class="o">=</span> PdeSimulationTime<span class="o">::</span>GetPdeTimeStep<span class="p">();</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> i<span class="o">=</span><span class="mi">0</span><span class="p">;</span> i<span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> i<span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> j<span class="o">=</span><span class="mi">0</span><span class="p">;</span> j<span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> j<span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="c">// mass matrix on the diagonal blocks
</span>                ret<span class="p">(</span><span class="mi">3</span><span class="o">*</span>i<span class="p">,</span>  <span class="mi">3</span><span class="o">*</span>j<span class="p">)</span>   <span class="o">=</span>  rPhi<span class="p">(</span>i<span class="p">)</span><span class="o">*</span>rPhi<span class="p">(</span>j<span class="p">)</span><span class="o">/</span>dt<span class="p">;</span>
                ret<span class="p">(</span><span class="mi">3</span><span class="o">*</span>i<span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span>j<span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span>  rPhi<span class="p">(</span>i<span class="p">)</span><span class="o">*</span>rPhi<span class="p">(</span>j<span class="p">)</span><span class="o">/</span>dt<span class="p">;</span>
                ret<span class="p">(</span><span class="mi">3</span><span class="o">*</span>i<span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span>j<span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span>  rPhi<span class="p">(</span>i<span class="p">)</span><span class="o">*</span>rPhi<span class="p">(</span>j<span class="p">)</span><span class="o">/</span>dt<span class="p">;</span>

                <span class="c">// mass matrix on some off-diagonal blocks
</span>                ret<span class="p">(</span><span class="mi">3</span><span class="o">*</span>i<span class="p">,</span>  <span class="mi">3</span><span class="o">*</span>j<span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span>  <span class="o">-</span>rPhi<span class="p">(</span>i<span class="p">)</span><span class="o">*</span>rPhi<span class="p">(</span>j<span class="p">);</span>
                ret<span class="p">(</span><span class="mi">3</span><span class="o">*</span>i<span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span>j<span class="p">)</span> <span class="o">=</span>  <span class="o">-</span>rPhi<span class="p">(</span>i<span class="p">)</span><span class="o">*</span>rPhi<span class="p">(</span>j<span class="p">);</span>
                ret<span class="p">(</span><span class="mi">3</span><span class="o">*</span>i<span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span>j<span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span>  <span class="o">-</span><span class="mi">2</span><span class="o">*</span>rPhi<span class="p">(</span>i<span class="p">)</span><span class="o">*</span>rPhi<span class="p">(</span>j<span class="p">);</span>

                <span class="c">// stiffness matrix on the diagonal blocks
</span>                <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> dim<span class="o">=</span><span class="mi">0</span><span class="p">;</span> dim<span class="o">&lt;</span><span class="mi">2</span><span class="p">;</span> dim<span class="o">++</span><span class="p">)</span>
                <span class="p">{</span>
                    ret<span class="p">(</span><span class="mi">3</span><span class="o">*</span>i<span class="p">,</span>  <span class="mi">3</span><span class="o">*</span>j<span class="p">)</span>   <span class="o">+=</span> rGradPhi<span class="p">(</span>dim<span class="p">,</span>i<span class="p">)</span><span class="o">*</span>rGradPhi<span class="p">(</span>dim<span class="p">,</span>j<span class="p">);</span>
                    ret<span class="p">(</span><span class="mi">3</span><span class="o">*</span>i<span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span>j<span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+=</span> rGradPhi<span class="p">(</span>dim<span class="p">,</span>i<span class="p">)</span><span class="o">*</span>rGradPhi<span class="p">(</span>dim<span class="p">,</span>j<span class="p">);</span>
                    ret<span class="p">(</span><span class="mi">3</span><span class="o">*</span>i<span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span>j<span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">+=</span> rGradPhi<span class="p">(</span>dim<span class="p">,</span>i<span class="p">)</span><span class="o">*</span>rGradPhi<span class="p">(</span>dim<span class="p">,</span>j<span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> ret<span class="p">;</span>
    <span class="p">}</span>
</pre></div><p>
Provide the volume elemental contribution to the RHS vector, ie the vector <tt>[b1 b2 b3]</tt> above
</p>
<div class="code"><pre>    c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span><span class="mi">3</span><span class="o">&gt;</span> ComputeVectorTerm<span class="p">(</span>c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> rPhi<span class="p">,</span>
                                           c_matrix<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> rGradPhi<span class="p">,</span>
                                           ChastePoint<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;&amp;</span> rX<span class="p">,</span>
                                           c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;&amp;</span> rU<span class="p">,</span>
                                           c_matrix<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;&amp;</span> rGradU<span class="p">,</span>
                                           Element<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> pElement<span class="p">)</span>
    <span class="p">{</span>
        c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span><span class="mi">3</span><span class="o">&gt;</span> ret<span class="p">;</span>

        <span class="c">// get u,v,w out of the provided parameters
</span>        <span class="kt">double</span> u <span class="o">=</span> rU<span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="kt">double</span> v <span class="o">=</span> rU<span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="kt">double</span> w <span class="o">=</span> rU<span class="p">(</span><span class="mi">2</span><span class="p">);</span>

        <span class="c">// this is how to get the current time and timestep
</span>        <span class="kt">double</span> t <span class="o">=</span> PdeSimulationTime<span class="o">::</span>GetTime<span class="p">();</span>
        <span class="kt">double</span> dt <span class="o">=</span> PdeSimulationTime<span class="o">::</span>GetPdeTimeStep<span class="p">();</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> i<span class="o">=</span><span class="mi">0</span><span class="p">;</span> i<span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> i<span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            ret<span class="p">(</span><span class="mi">3</span><span class="o">*</span>i<span class="p">)</span>   <span class="o">=</span>  <span class="p">(</span>u<span class="o">/</span>dt<span class="p">)</span> <span class="o">*</span> rPhi<span class="p">(</span>i<span class="p">);</span>
            ret<span class="p">(</span><span class="mi">3</span><span class="o">*</span>i<span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span>  <span class="p">(</span>v<span class="o">/</span>dt<span class="p">)</span> <span class="o">*</span> rPhi<span class="p">(</span>i<span class="p">);</span>
            ret<span class="p">(</span><span class="mi">3</span><span class="o">*</span>i<span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span>  <span class="p">(</span>w<span class="o">/</span>dt <span class="o">+</span> g<span class="p">(</span>t<span class="o">+</span>dt<span class="p">,</span>rX<span class="p">))</span> <span class="o">*</span> rPhi<span class="p">(</span>i<span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> ret<span class="p">;</span>
    <span class="p">}</span>
</pre></div><p>
Define this method as before
</p>
<div class="code"><pre>    <span class="kt">void</span> SetupLinearSystem<span class="p">(</span>Vec currentSolution<span class="p">,</span> <span class="kt">bool</span> computeMatrix<span class="p">)</span>
    <span class="p">{</span>
        SetupGivenLinearSystem<span class="p">(</span>currentSolution<span class="p">,</span> computeMatrix<span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span>mpLinearSystem<span class="p">);</span>
    <span class="p">}</span>

<span class="k">public</span><span class="o">:</span>
</pre></div><p>
The constructor is similar to before. However: <strong>important</strong> - by default the dynamic solvers
will reassemble the matrix each timestep. In this (and most other) problems the matrix is constant
and only needs to be assembled once. Make sure we tell the solver this, otherwise performance
will be destroyed.
</p>
<div class="code"><pre>    ThreeParabolicPdesSolver<span class="p">(</span>TetrahedralMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> pMesh<span class="p">,</span>
                             BoundaryConditionsContainer<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;*</span> pBoundaryConditions<span class="p">)</span>
        <span class="o">:</span> AbstractAssemblerSolverHybrid<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span>NORMAL<span class="o">&gt;</span><span class="p">(</span>pMesh<span class="p">,</span>pBoundaryConditions<span class="p">),</span>
          AbstractDynamicLinearPdeSolver<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span>pMesh<span class="p">)</span>
    <span class="p">{</span>
        <span class="k">this</span><span class="o">-&gt;</span>mMatrixIsConstant <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div><p>
Now the tests using the two solvers
</p>
<div class="code"><pre><span class="k">class</span> <span class="nc">TestWritingPdeSolversTutorial</span> <span class="o">:</span> <span class="k">public</span> CxxTest<span class="o">::</span>TestSuite
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
</pre></div><p>
Use the first solver to solve the static PDE. We apply zero Dirichlet boundary conditions
on the whole of the boundary for both variables.
</p>
<div class="code"><pre>    <span class="kt">void</span> TestMyTwoVariablePdeSolver<span class="p">()</span> <span class="k">throw</span> <span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
        TetrahedralMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> mesh<span class="p">;</span>
        mesh<span class="p">.</span>ConstructRegularSlabMesh<span class="p">(</span><span class="mf">0.01</span> <span class="c">/*h*/</span><span class="p">,</span> <span class="mf">1.0</span> <span class="c">/*width*/</span><span class="p">,</span> <span class="mf">1.0</span> <span class="c">/*height*/</span><span class="p">);</span>

        <span class="c">// Boundary conditions for 2-unknown problem
</span>        BoundaryConditionsContainer<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> bcc<span class="p">;</span>
        bcc<span class="p">.</span>DefineZeroDirichletOnMeshBoundary<span class="p">(</span><span class="o">&amp;</span>mesh<span class="p">,</span><span class="mi">0</span><span class="p">);</span> <span class="c">// zero dirichlet for u
</span>        bcc<span class="p">.</span>DefineZeroDirichletOnMeshBoundary<span class="p">(</span><span class="o">&amp;</span>mesh<span class="p">,</span><span class="mi">1</span><span class="p">);</span> <span class="c">// zero dirichlet for v
</span>
        <span class="c">// Use our purpose-made solver for this problem:
</span>        MyTwoVariablePdeSolver solver<span class="p">(</span><span class="o">&amp;</span>mesh<span class="p">,</span><span class="o">&amp;</span>bcc<span class="p">);</span>
</pre></div><p>
The <tt>AbstractStaticLinearPdeSolver</tt> class from which our solver
inherits, provides a <tt>Solve</tt> method.
</p>
<div class="code"><pre>        Vec result <span class="o">=</span> solver<span class="p">.</span>Solve<span class="p">();</span>
        ReplicatableVector result_repl<span class="p">(</span>result<span class="p">);</span>
</pre></div><p>
Compare against the exact solution.
</p>
<div class="code"><pre>        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> i<span class="o">=</span><span class="mi">0</span><span class="p">;</span> i<span class="o">&lt;</span>mesh<span class="p">.</span>GetNumNodes<span class="p">();</span> i<span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">double</span> x <span class="o">=</span> mesh<span class="p">.</span>GetNode<span class="p">(</span>i<span class="p">)</span><span class="o">-&gt;</span>GetPoint<span class="p">()[</span><span class="mi">0</span><span class="p">];</span>
            <span class="kt">double</span> y <span class="o">=</span> mesh<span class="p">.</span>GetNode<span class="p">(</span>i<span class="p">)</span><span class="o">-&gt;</span>GetPoint<span class="p">()[</span><span class="mi">1</span><span class="p">];</span>

            <span class="kt">double</span> u <span class="o">=</span> result_repl<span class="p">[</span><span class="mi">2</span><span class="o">*</span>i<span class="p">];</span>
            <span class="kt">double</span> v <span class="o">=</span> result_repl<span class="p">[</span><span class="mi">2</span><span class="o">*</span>i<span class="o">+</span><span class="mi">1</span><span class="p">];</span>

            <span class="kt">double</span> u_exact <span class="o">=</span> sin<span class="p">(</span>M_PI<span class="o">*</span>x<span class="p">)</span><span class="o">*</span>sin<span class="p">(</span>M_PI<span class="o">*</span>y<span class="p">);</span>
            <span class="kt">double</span> v_exact <span class="o">=</span> sin<span class="p">(</span><span class="mi">2</span><span class="o">*</span>M_PI<span class="o">*</span>x<span class="p">)</span><span class="o">*</span>sin<span class="p">(</span><span class="mi">2</span><span class="o">*</span>M_PI<span class="o">*</span>y<span class="p">);</span>

            TS_ASSERT_DELTA<span class="p">(</span>u<span class="p">,</span> u_exact<span class="p">,</span> <span class="mf">0.002</span><span class="p">);</span>
            TS_ASSERT_DELTA<span class="p">(</span>v<span class="p">,</span> v_exact<span class="p">,</span> <span class="mf">0.007</span><span class="p">);</span>
        <span class="p">}</span>
        VecDestroy<span class="p">(</span>result<span class="p">);</span>
    <span class="p">}</span>
</pre></div><p>
Now run a test solving the parabolic-parabolic-parabolic PDE system.
</p>
<div class="code"><pre>    <span class="kt">void</span> TestMyParaEllipticSetOfPdesSolver<span class="p">()</span> <span class="k">throw</span> <span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
        TetrahedralMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> mesh<span class="p">;</span>
        mesh<span class="p">.</span>ConstructRegularSlabMesh<span class="p">(</span><span class="mf">0.05</span> <span class="c">/*h*/</span><span class="p">,</span> <span class="mf">1.0</span> <span class="c">/*width*/</span><span class="p">,</span> <span class="mf">1.0</span> <span class="c">/*height*/</span><span class="p">);</span>
</pre></div><p>
Set up the boundary conditions. v and w are zero on the entire boundary,
and du/dn=1 on the LHS and 0 otherwise.
</p>
<div class="code"><pre>        BoundaryConditionsContainer<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> bcc<span class="p">;</span>

        bcc<span class="p">.</span>DefineZeroDirichletOnMeshBoundary<span class="p">(</span><span class="o">&amp;</span>mesh<span class="p">,</span><span class="mi">1</span> <span class="c">/*index of unknown, ie v*/</span><span class="p">);</span>
        bcc<span class="p">.</span>DefineZeroDirichletOnMeshBoundary<span class="p">(</span><span class="o">&amp;</span>mesh<span class="p">,</span><span class="mi">2</span> <span class="c">/*index of unknown, ie w*/</span><span class="p">);</span>

        ConstBoundaryCondition<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;*</span> p_neumann_bc <span class="o">=</span> <span class="k">new</span> ConstBoundaryCondition<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
        TetrahedralMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;::</span>BoundaryElementIterator iter <span class="o">=</span> mesh<span class="p">.</span>GetBoundaryElementIteratorBegin<span class="p">();</span>
        <span class="k">while</span> <span class="p">(</span>iter <span class="o">&lt;</span> mesh<span class="p">.</span>GetBoundaryElementIteratorEnd<span class="p">())</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span>fabs<span class="p">((</span><span class="o">*</span>iter<span class="p">)</span><span class="o">-&gt;</span>CalculateCentroid<span class="p">()[</span><span class="mi">0</span><span class="p">])</span><span class="o">&lt;</span><span class="mf">1e-6</span><span class="p">)</span>
            <span class="p">{</span>
                bcc<span class="p">.</span>AddNeumannBoundaryCondition<span class="p">(</span><span class="o">*</span>iter<span class="p">,</span> p_neumann_bc<span class="p">,</span> <span class="mi">0</span> <span class="c">/*index of unknown, ie u*/</span><span class="p">);</span>
            <span class="p">}</span>
            iter<span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
</pre></div><p>
Use our solver
</p>
<div class="code"><pre>        ThreeParabolicPdesSolver solver<span class="p">(</span><span class="o">&amp;</span>mesh<span class="p">,</span><span class="o">&amp;</span>bcc<span class="p">);</span>
</pre></div><p>
The interface is exactly the same as the <tt>SimpleLinearParabolicSolver</tt>.
</p>
<div class="code"><pre>        solver<span class="p">.</span>SetTimeStep<span class="p">(</span><span class="mf">0.01</span><span class="p">);</span>
        solver<span class="p">.</span>SetTimes<span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>

        Vec initial_condition <span class="o">=</span> PetscTools<span class="o">::</span>CreateAndSetVec<span class="p">(</span><span class="mi">3</span><span class="o">*</span>mesh<span class="p">.</span>GetNumNodes<span class="p">(),</span> <span class="mf">0.0</span><span class="p">);</span>
        solver<span class="p">.</span>SetInitialCondition<span class="p">(</span>initial_condition<span class="p">);</span>
</pre></div><p>
For this test we show how to output results to file for multiple sampling times. We start by
specifying an output directory and filename prefix for our results file:
</p>
<div class="code"><pre>        solver<span class="p">.</span>SetOutputDirectoryAndPrefix<span class="p">(</span><span class="s">"ThreeVarCoupledProblem"</span><span class="p">,</span><span class="s">"results"</span><span class="p">);</span>
</pre></div><p>
When an output directory has been specified, the solver writes output in HDF5 format. To
convert this to another output format, we call the relevant method. Here, we convert
the output to plain txt files. We also say how often to write the data, telling the
solver to output results to file every tenth timestep. The solver will create
one file for each variable and for each time, so for example, the file
results_Variable_0_10 is the results for u, over all nodes, at the 11th printed time.
Have a look in the output directory after running the test. (Note: the HDF5 data can also be
converted to VTK or cmgui formats).
</p>
<div class="code"><pre>        solver<span class="p">.</span>SetOutputToTxt<span class="p">(</span><span class="kc">true</span><span class="p">);</span>
        solver<span class="p">.</span>SetPrintingTimestepMultiple<span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</pre></div><p>
We are now ready to solve the system.
</p>
<div class="code"><pre>        Vec result <span class="o">=</span> solver<span class="p">.</span>Solve<span class="p">();</span>
        ReplicatableVector result_repl<span class="p">(</span>result<span class="p">);</span>
</pre></div><p>
The plain txt output can be loaded into matlab for easy visualisation. For this we
also need the mesh data - at the very least the nodal locations - so we also write out
the mesh
</p>
<div class="code"><pre>        TrianglesMeshWriter<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> mesh_writer<span class="p">(</span><span class="s">"ThreeVarCoupledProblem"</span><span class="p">,</span> <span class="s">"mesh"</span><span class="p">,</span> <span class="kc">false</span> <span class="c">/*don't clean (ie delete everything in) directory!*/</span><span class="p">);</span>
        mesh_writer<span class="p">.</span>WriteFilesUsingMesh<span class="p">(</span>mesh<span class="p">);</span>
</pre></div><p>
Note that we need to destroy the initial condition vector as well as the solution.
</p>
<div class="code"><pre>        VecDestroy<span class="p">(</span>initial_condition<span class="p">);</span>
        VecDestroy<span class="p">(</span>result<span class="p">);</span>
</pre></div><p>
<strong>Visualisation:</strong> To visualise in matlab/octave, you can load the node file,
and then the data files. However, the node file needs to be edited to remove any
comment lines (lines starting with '#') and the header line (which says how
many nodes there are). (The little matlab script 'anim/matlab/read_chaste_node_file.m'
can be used to do this, though it is not claimed to be very robust). As an
example matlab visualisation script, the following, if run from the output
directory, plots w:
</p>
<pre class="wiki">pos = read_chaste_node_file('mesh.node');
for i=0:200
file = ['txt_output/results_Variable_2_',num2str(i),'.txt'];
w = load(file);
plot3(pos(:,1),pos(:,2),w,'*');
pause;
end;
</pre><div class="code"><pre>    <span class="p">}</span>
<span class="p">};</span>
</pre></div><h1 id="Code">Code</h1>
<p>
The full code is given below
</p>
<h2 id="FilenameTestWritingPdeSolversTutorial.hpp">File name <tt>TestWritingPdeSolversTutorial.hpp</tt></h2>
<div class="code"><pre><span class="cp">#include &lt;cxxtest/TestSuite.h&gt;
#include "TetrahedralMesh.hpp"
#include "TrianglesMeshReader.hpp"
#include "BoundaryConditionsContainer.hpp"
#include "ConstBoundaryCondition.hpp"
#include "PetscSetupAndFinalize.hpp"
#include "TrianglesMeshWriter.hpp"
#include "BoundaryConditionsContainerImplementation.hpp"
#include "AbstractBoundaryConditionsContainerImplementation.hpp"
#include "AbstractAssemblerSolverHybrid.hpp"
#include "AbstractStaticLinearPdeSolver.hpp"
#include "AbstractDynamicLinearPdeSolver.hpp"
</span>
<span class="k">class</span> <span class="nc">MyTwoVariablePdeSolver</span>
    <span class="o">:</span> <span class="k">public</span> AbstractAssemblerSolverHybrid<span class="o">&lt;</span><span class="mi">2</span><span class="c">/*elem_dim*/</span><span class="p">,</span><span class="mi">2</span><span class="c">/*space_dim*/</span><span class="p">,</span><span class="mi">2</span><span class="c">/*problem_dim*/</span><span class="p">,</span>NORMAL<span class="c">/*amount of interpolation*/</span><span class="o">&gt;</span><span class="p">,</span>
      <span class="k">public</span> AbstractStaticLinearPdeSolver<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">double</span> f<span class="p">(</span><span class="kt">double</span> x<span class="p">,</span><span class="kt">double</span> y<span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span>M_PI<span class="o">*</span>M_PI<span class="o">*</span>sin<span class="p">(</span>M_PI<span class="o">*</span>x<span class="p">)</span><span class="o">*</span>sin<span class="p">(</span>M_PI<span class="o">*</span>y<span class="p">)</span> <span class="o">+</span> sin<span class="p">(</span><span class="mi">2</span><span class="o">*</span>M_PI<span class="o">*</span>x<span class="p">)</span><span class="o">*</span>sin<span class="p">(</span><span class="mi">2</span><span class="o">*</span>M_PI<span class="o">*</span>y<span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">double</span> g<span class="p">(</span><span class="kt">double</span> x<span class="p">,</span><span class="kt">double</span> y<span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">8</span><span class="o">*</span>M_PI<span class="o">*</span>M_PI<span class="o">*</span>sin<span class="p">(</span><span class="mi">2</span><span class="o">*</span>M_PI<span class="o">*</span>x<span class="p">)</span><span class="o">*</span>sin<span class="p">(</span><span class="mi">2</span><span class="o">*</span>M_PI<span class="o">*</span>y<span class="p">)</span> <span class="o">+</span> sin<span class="p">(</span>M_PI<span class="o">*</span>x<span class="p">)</span><span class="o">*</span>sin<span class="p">(</span>M_PI<span class="o">*</span>y<span class="p">);</span>
    <span class="p">}</span>

    c_matrix<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="mi">3</span><span class="o">&gt;</span> ComputeMatrixTerm<span class="p">(</span>c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;&amp;</span> rPhi <span class="c">/* the three bases for the current element, evaluated at the current quad pt*/</span><span class="p">,</span>
                                               c_matrix<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;&amp;</span> rGradPhi <span class="c">/* gradients of the three bases */</span><span class="p">,</span>
                                               ChastePoint<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;&amp;</span> rX           <span class="c">/* physical coordinate of quad point */</span><span class="p">,</span>
                                               c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;&amp;</span> rU       <span class="c">/* current solution (unused here as a linear static problem */</span><span class="p">,</span>
                                               c_matrix<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;&amp;</span> rGradU <span class="c">/* current solution gradient (unused here as a linear static problem */</span><span class="p">,</span>
                                               Element<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> pElement<span class="p">)</span>
    <span class="p">{</span>
        c_matrix<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="mi">3</span><span class="o">&gt;</span> ret <span class="o">=</span> zero_matrix<span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="mi">3</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> i<span class="o">=</span><span class="mi">0</span><span class="p">;</span> i<span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> i<span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> j<span class="o">=</span><span class="mi">0</span><span class="p">;</span> j<span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> j<span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> k<span class="o">=</span><span class="mi">0</span><span class="p">;</span> k<span class="o">&lt;</span><span class="mi">2</span><span class="p">;</span> k<span class="o">++</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="c">// stiffness matrix on diagonal 'blocks'
</span>                    ret<span class="p">(</span><span class="mi">2</span><span class="o">*</span>i<span class="p">,</span>  <span class="mi">2</span><span class="o">*</span>j<span class="p">)</span>   <span class="o">+=</span> rGradPhi<span class="p">(</span>k<span class="p">,</span>i<span class="p">)</span><span class="o">*</span>rGradPhi<span class="p">(</span>k<span class="p">,</span>j<span class="p">);</span>
                    ret<span class="p">(</span><span class="mi">2</span><span class="o">*</span>i<span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span>j<span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+=</span> rGradPhi<span class="p">(</span>k<span class="p">,</span>i<span class="p">)</span><span class="o">*</span>rGradPhi<span class="p">(</span>k<span class="p">,</span>j<span class="p">);</span>
                <span class="p">}</span>

                <span class="c">// (negative) mass matrix on off-diagonal 'blocks'
</span>                ret<span class="p">(</span><span class="mi">2</span><span class="o">*</span>i<span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span>j<span class="p">)</span>   <span class="o">=</span> <span class="o">-</span>rPhi<span class="p">(</span>i<span class="p">)</span><span class="o">*</span>rPhi<span class="p">(</span>j<span class="p">);</span>
                ret<span class="p">(</span><span class="mi">2</span><span class="o">*</span>i<span class="p">,</span>   <span class="mi">2</span><span class="o">*</span>j<span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span>rPhi<span class="p">(</span>i<span class="p">)</span><span class="o">*</span>rPhi<span class="p">(</span>j<span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> ret<span class="p">;</span>
    <span class="p">}</span>

    c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="mi">3</span><span class="o">&gt;</span> ComputeVectorTerm<span class="p">(</span>c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> rPhi<span class="p">,</span>
                                           c_matrix<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="o">&gt;&amp;</span> rGradPhi<span class="p">,</span>
                                           ChastePoint<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;&amp;</span> rX<span class="p">,</span>
                                           c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;&amp;</span> rU<span class="p">,</span>
                                           c_matrix<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;&amp;</span> rGradU<span class="p">,</span>
                                           Element<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> pElement<span class="p">)</span>
    <span class="p">{</span>
        c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="mi">3</span><span class="o">&gt;</span> ret<span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> i<span class="o">=</span><span class="mi">0</span><span class="p">;</span> i<span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> i<span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            ret<span class="p">(</span><span class="mi">2</span><span class="o">*</span>i<span class="p">)</span>   <span class="o">=</span> <span class="o">-</span>f<span class="p">(</span>rX<span class="p">[</span><span class="mi">0</span><span class="p">],</span>rX<span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> rPhi<span class="p">(</span>i<span class="p">);</span>
            ret<span class="p">(</span><span class="mi">2</span><span class="o">*</span>i<span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span>g<span class="p">(</span>rX<span class="p">[</span><span class="mi">0</span><span class="p">],</span>rX<span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> rPhi<span class="p">(</span>i<span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> ret<span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> SetupLinearSystem<span class="p">(</span>Vec currentSolution<span class="p">,</span> <span class="kt">bool</span> computeMatrix<span class="p">)</span>
    <span class="p">{</span>
        SetupGivenLinearSystem<span class="p">(</span>currentSolution<span class="p">,</span> computeMatrix<span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span>mpLinearSystem<span class="p">);</span>
    <span class="p">}</span>

<span class="k">public</span><span class="o">:</span>
    MyTwoVariablePdeSolver<span class="p">(</span>TetrahedralMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> pMesh<span class="p">,</span>
                           BoundaryConditionsContainer<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> pBoundaryConditions<span class="p">)</span>
        <span class="o">:</span> AbstractAssemblerSolverHybrid<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span>NORMAL<span class="o">&gt;</span><span class="p">(</span>pMesh<span class="p">,</span>pBoundaryConditions<span class="p">),</span>
          AbstractStaticLinearPdeSolver<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span>pMesh<span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">ThreeParabolicPdesSolver</span>
    <span class="o">:</span> <span class="k">public</span> AbstractAssemblerSolverHybrid<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span>NORMAL<span class="o">&gt;</span><span class="p">,</span>
      <span class="k">public</span> AbstractDynamicLinearPdeSolver<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">double</span> g<span class="p">(</span><span class="kt">double</span> t<span class="p">,</span> ChastePoint<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;&amp;</span> rX<span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> t<span class="o">*</span><span class="p">(</span>rX<span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mf">0.5</span><span class="p">);</span>
    <span class="p">}</span>

    c_matrix<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span><span class="mi">3</span><span class="o">&gt;</span> ComputeMatrixTerm<span class="p">(</span>c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;&amp;</span> rPhi<span class="p">,</span>
                                               c_matrix<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;&amp;</span> rGradPhi<span class="p">,</span>
                                               ChastePoint<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;&amp;</span> rX<span class="p">,</span>
                                               c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;&amp;</span> rU<span class="p">,</span>
                                               c_matrix<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;&amp;</span> rGradU<span class="p">,</span>
                                               Element<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> pElement<span class="p">)</span>
    <span class="p">{</span>
        c_matrix<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">9</span><span class="o">&gt;</span> ret <span class="o">=</span> zero_matrix<span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="mi">9</span><span class="p">);</span>

        <span class="c">// this is how to get the current timestep
</span>        <span class="kt">double</span> dt <span class="o">=</span> PdeSimulationTime<span class="o">::</span>GetPdeTimeStep<span class="p">();</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> i<span class="o">=</span><span class="mi">0</span><span class="p">;</span> i<span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> i<span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> j<span class="o">=</span><span class="mi">0</span><span class="p">;</span> j<span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> j<span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="c">// mass matrix on the diagonal blocks
</span>                ret<span class="p">(</span><span class="mi">3</span><span class="o">*</span>i<span class="p">,</span>  <span class="mi">3</span><span class="o">*</span>j<span class="p">)</span>   <span class="o">=</span>  rPhi<span class="p">(</span>i<span class="p">)</span><span class="o">*</span>rPhi<span class="p">(</span>j<span class="p">)</span><span class="o">/</span>dt<span class="p">;</span>
                ret<span class="p">(</span><span class="mi">3</span><span class="o">*</span>i<span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span>j<span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span>  rPhi<span class="p">(</span>i<span class="p">)</span><span class="o">*</span>rPhi<span class="p">(</span>j<span class="p">)</span><span class="o">/</span>dt<span class="p">;</span>
                ret<span class="p">(</span><span class="mi">3</span><span class="o">*</span>i<span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span>j<span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span>  rPhi<span class="p">(</span>i<span class="p">)</span><span class="o">*</span>rPhi<span class="p">(</span>j<span class="p">)</span><span class="o">/</span>dt<span class="p">;</span>

                <span class="c">// mass matrix on some off-diagonal blocks
</span>                ret<span class="p">(</span><span class="mi">3</span><span class="o">*</span>i<span class="p">,</span>  <span class="mi">3</span><span class="o">*</span>j<span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span>  <span class="o">-</span>rPhi<span class="p">(</span>i<span class="p">)</span><span class="o">*</span>rPhi<span class="p">(</span>j<span class="p">);</span>
                ret<span class="p">(</span><span class="mi">3</span><span class="o">*</span>i<span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span>j<span class="p">)</span> <span class="o">=</span>  <span class="o">-</span>rPhi<span class="p">(</span>i<span class="p">)</span><span class="o">*</span>rPhi<span class="p">(</span>j<span class="p">);</span>
                ret<span class="p">(</span><span class="mi">3</span><span class="o">*</span>i<span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span>j<span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span>  <span class="o">-</span><span class="mi">2</span><span class="o">*</span>rPhi<span class="p">(</span>i<span class="p">)</span><span class="o">*</span>rPhi<span class="p">(</span>j<span class="p">);</span>

                <span class="c">// stiffness matrix on the diagonal blocks
</span>                <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> dim<span class="o">=</span><span class="mi">0</span><span class="p">;</span> dim<span class="o">&lt;</span><span class="mi">2</span><span class="p">;</span> dim<span class="o">++</span><span class="p">)</span>
                <span class="p">{</span>
                    ret<span class="p">(</span><span class="mi">3</span><span class="o">*</span>i<span class="p">,</span>  <span class="mi">3</span><span class="o">*</span>j<span class="p">)</span>   <span class="o">+=</span> rGradPhi<span class="p">(</span>dim<span class="p">,</span>i<span class="p">)</span><span class="o">*</span>rGradPhi<span class="p">(</span>dim<span class="p">,</span>j<span class="p">);</span>
                    ret<span class="p">(</span><span class="mi">3</span><span class="o">*</span>i<span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span>j<span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+=</span> rGradPhi<span class="p">(</span>dim<span class="p">,</span>i<span class="p">)</span><span class="o">*</span>rGradPhi<span class="p">(</span>dim<span class="p">,</span>j<span class="p">);</span>
                    ret<span class="p">(</span><span class="mi">3</span><span class="o">*</span>i<span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span>j<span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">+=</span> rGradPhi<span class="p">(</span>dim<span class="p">,</span>i<span class="p">)</span><span class="o">*</span>rGradPhi<span class="p">(</span>dim<span class="p">,</span>j<span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> ret<span class="p">;</span>
    <span class="p">}</span>

    c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span><span class="mi">3</span><span class="o">&gt;</span> ComputeVectorTerm<span class="p">(</span>c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> rPhi<span class="p">,</span>
                                           c_matrix<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> rGradPhi<span class="p">,</span>
                                           ChastePoint<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;&amp;</span> rX<span class="p">,</span>
                                           c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;&amp;</span> rU<span class="p">,</span>
                                           c_matrix<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;&amp;</span> rGradU<span class="p">,</span>
                                           Element<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> pElement<span class="p">)</span>
    <span class="p">{</span>
        c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span><span class="mi">3</span><span class="o">&gt;</span> ret<span class="p">;</span>

        <span class="c">// get u,v,w out of the provided parameters
</span>        <span class="kt">double</span> u <span class="o">=</span> rU<span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="kt">double</span> v <span class="o">=</span> rU<span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="kt">double</span> w <span class="o">=</span> rU<span class="p">(</span><span class="mi">2</span><span class="p">);</span>

        <span class="c">// this is how to get the current time and timestep
</span>        <span class="kt">double</span> t <span class="o">=</span> PdeSimulationTime<span class="o">::</span>GetTime<span class="p">();</span>
        <span class="kt">double</span> dt <span class="o">=</span> PdeSimulationTime<span class="o">::</span>GetPdeTimeStep<span class="p">();</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> i<span class="o">=</span><span class="mi">0</span><span class="p">;</span> i<span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> i<span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            ret<span class="p">(</span><span class="mi">3</span><span class="o">*</span>i<span class="p">)</span>   <span class="o">=</span>  <span class="p">(</span>u<span class="o">/</span>dt<span class="p">)</span> <span class="o">*</span> rPhi<span class="p">(</span>i<span class="p">);</span>
            ret<span class="p">(</span><span class="mi">3</span><span class="o">*</span>i<span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span>  <span class="p">(</span>v<span class="o">/</span>dt<span class="p">)</span> <span class="o">*</span> rPhi<span class="p">(</span>i<span class="p">);</span>
            ret<span class="p">(</span><span class="mi">3</span><span class="o">*</span>i<span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span>  <span class="p">(</span>w<span class="o">/</span>dt <span class="o">+</span> g<span class="p">(</span>t<span class="o">+</span>dt<span class="p">,</span>rX<span class="p">))</span> <span class="o">*</span> rPhi<span class="p">(</span>i<span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> ret<span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> SetupLinearSystem<span class="p">(</span>Vec currentSolution<span class="p">,</span> <span class="kt">bool</span> computeMatrix<span class="p">)</span>
    <span class="p">{</span>
        SetupGivenLinearSystem<span class="p">(</span>currentSolution<span class="p">,</span> computeMatrix<span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span>mpLinearSystem<span class="p">);</span>
    <span class="p">}</span>

<span class="k">public</span><span class="o">:</span>
    ThreeParabolicPdesSolver<span class="p">(</span>TetrahedralMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> pMesh<span class="p">,</span>
                             BoundaryConditionsContainer<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;*</span> pBoundaryConditions<span class="p">)</span>
        <span class="o">:</span> AbstractAssemblerSolverHybrid<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span>NORMAL<span class="o">&gt;</span><span class="p">(</span>pMesh<span class="p">,</span>pBoundaryConditions<span class="p">),</span>
          AbstractDynamicLinearPdeSolver<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span>pMesh<span class="p">)</span>
    <span class="p">{</span>
        <span class="k">this</span><span class="o">-&gt;</span>mMatrixIsConstant <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">TestWritingPdeSolversTutorial</span> <span class="o">:</span> <span class="k">public</span> CxxTest<span class="o">::</span>TestSuite
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> TestMyTwoVariablePdeSolver<span class="p">()</span> <span class="k">throw</span> <span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
        TetrahedralMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> mesh<span class="p">;</span>
        mesh<span class="p">.</span>ConstructRegularSlabMesh<span class="p">(</span><span class="mf">0.01</span> <span class="c">/*h*/</span><span class="p">,</span> <span class="mf">1.0</span> <span class="c">/*width*/</span><span class="p">,</span> <span class="mf">1.0</span> <span class="c">/*height*/</span><span class="p">);</span>

        <span class="c">// Boundary conditions for 2-unknown problem
</span>        BoundaryConditionsContainer<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> bcc<span class="p">;</span>
        bcc<span class="p">.</span>DefineZeroDirichletOnMeshBoundary<span class="p">(</span><span class="o">&amp;</span>mesh<span class="p">,</span><span class="mi">0</span><span class="p">);</span> <span class="c">// zero dirichlet for u
</span>        bcc<span class="p">.</span>DefineZeroDirichletOnMeshBoundary<span class="p">(</span><span class="o">&amp;</span>mesh<span class="p">,</span><span class="mi">1</span><span class="p">);</span> <span class="c">// zero dirichlet for v
</span>
        <span class="c">// Use our purpose-made solver for this problem:
</span>        MyTwoVariablePdeSolver solver<span class="p">(</span><span class="o">&amp;</span>mesh<span class="p">,</span><span class="o">&amp;</span>bcc<span class="p">);</span>

        Vec result <span class="o">=</span> solver<span class="p">.</span>Solve<span class="p">();</span>
        ReplicatableVector result_repl<span class="p">(</span>result<span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> i<span class="o">=</span><span class="mi">0</span><span class="p">;</span> i<span class="o">&lt;</span>mesh<span class="p">.</span>GetNumNodes<span class="p">();</span> i<span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">double</span> x <span class="o">=</span> mesh<span class="p">.</span>GetNode<span class="p">(</span>i<span class="p">)</span><span class="o">-&gt;</span>GetPoint<span class="p">()[</span><span class="mi">0</span><span class="p">];</span>
            <span class="kt">double</span> y <span class="o">=</span> mesh<span class="p">.</span>GetNode<span class="p">(</span>i<span class="p">)</span><span class="o">-&gt;</span>GetPoint<span class="p">()[</span><span class="mi">1</span><span class="p">];</span>

            <span class="kt">double</span> u <span class="o">=</span> result_repl<span class="p">[</span><span class="mi">2</span><span class="o">*</span>i<span class="p">];</span>
            <span class="kt">double</span> v <span class="o">=</span> result_repl<span class="p">[</span><span class="mi">2</span><span class="o">*</span>i<span class="o">+</span><span class="mi">1</span><span class="p">];</span>

            <span class="kt">double</span> u_exact <span class="o">=</span> sin<span class="p">(</span>M_PI<span class="o">*</span>x<span class="p">)</span><span class="o">*</span>sin<span class="p">(</span>M_PI<span class="o">*</span>y<span class="p">);</span>
            <span class="kt">double</span> v_exact <span class="o">=</span> sin<span class="p">(</span><span class="mi">2</span><span class="o">*</span>M_PI<span class="o">*</span>x<span class="p">)</span><span class="o">*</span>sin<span class="p">(</span><span class="mi">2</span><span class="o">*</span>M_PI<span class="o">*</span>y<span class="p">);</span>

            TS_ASSERT_DELTA<span class="p">(</span>u<span class="p">,</span> u_exact<span class="p">,</span> <span class="mf">0.002</span><span class="p">);</span>
            TS_ASSERT_DELTA<span class="p">(</span>v<span class="p">,</span> v_exact<span class="p">,</span> <span class="mf">0.007</span><span class="p">);</span>
        <span class="p">}</span>
        VecDestroy<span class="p">(</span>result<span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> TestMyParaEllipticSetOfPdesSolver<span class="p">()</span> <span class="k">throw</span> <span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
        TetrahedralMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> mesh<span class="p">;</span>
        mesh<span class="p">.</span>ConstructRegularSlabMesh<span class="p">(</span><span class="mf">0.05</span> <span class="c">/*h*/</span><span class="p">,</span> <span class="mf">1.0</span> <span class="c">/*width*/</span><span class="p">,</span> <span class="mf">1.0</span> <span class="c">/*height*/</span><span class="p">);</span>

        BoundaryConditionsContainer<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> bcc<span class="p">;</span>

        bcc<span class="p">.</span>DefineZeroDirichletOnMeshBoundary<span class="p">(</span><span class="o">&amp;</span>mesh<span class="p">,</span><span class="mi">1</span> <span class="c">/*index of unknown, ie v*/</span><span class="p">);</span>
        bcc<span class="p">.</span>DefineZeroDirichletOnMeshBoundary<span class="p">(</span><span class="o">&amp;</span>mesh<span class="p">,</span><span class="mi">2</span> <span class="c">/*index of unknown, ie w*/</span><span class="p">);</span>

        ConstBoundaryCondition<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;*</span> p_neumann_bc <span class="o">=</span> <span class="k">new</span> ConstBoundaryCondition<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
        TetrahedralMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;::</span>BoundaryElementIterator iter <span class="o">=</span> mesh<span class="p">.</span>GetBoundaryElementIteratorBegin<span class="p">();</span>
        <span class="k">while</span> <span class="p">(</span>iter <span class="o">&lt;</span> mesh<span class="p">.</span>GetBoundaryElementIteratorEnd<span class="p">())</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span>fabs<span class="p">((</span><span class="o">*</span>iter<span class="p">)</span><span class="o">-&gt;</span>CalculateCentroid<span class="p">()[</span><span class="mi">0</span><span class="p">])</span><span class="o">&lt;</span><span class="mf">1e-6</span><span class="p">)</span>
            <span class="p">{</span>
                bcc<span class="p">.</span>AddNeumannBoundaryCondition<span class="p">(</span><span class="o">*</span>iter<span class="p">,</span> p_neumann_bc<span class="p">,</span> <span class="mi">0</span> <span class="c">/*index of unknown, ie u*/</span><span class="p">);</span>
            <span class="p">}</span>
            iter<span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>

        ThreeParabolicPdesSolver solver<span class="p">(</span><span class="o">&amp;</span>mesh<span class="p">,</span><span class="o">&amp;</span>bcc<span class="p">);</span>

        solver<span class="p">.</span>SetTimeStep<span class="p">(</span><span class="mf">0.01</span><span class="p">);</span>
        solver<span class="p">.</span>SetTimes<span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>

        Vec initial_condition <span class="o">=</span> PetscTools<span class="o">::</span>CreateAndSetVec<span class="p">(</span><span class="mi">3</span><span class="o">*</span>mesh<span class="p">.</span>GetNumNodes<span class="p">(),</span> <span class="mf">0.0</span><span class="p">);</span>
        solver<span class="p">.</span>SetInitialCondition<span class="p">(</span>initial_condition<span class="p">);</span>

        solver<span class="p">.</span>SetOutputDirectoryAndPrefix<span class="p">(</span><span class="s">"ThreeVarCoupledProblem"</span><span class="p">,</span><span class="s">"results"</span><span class="p">);</span>

        solver<span class="p">.</span>SetOutputToTxt<span class="p">(</span><span class="kc">true</span><span class="p">);</span>
        solver<span class="p">.</span>SetPrintingTimestepMultiple<span class="p">(</span><span class="mi">10</span><span class="p">);</span>

        Vec result <span class="o">=</span> solver<span class="p">.</span>Solve<span class="p">();</span>
        ReplicatableVector result_repl<span class="p">(</span>result<span class="p">);</span>

        TrianglesMeshWriter<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> mesh_writer<span class="p">(</span><span class="s">"ThreeVarCoupledProblem"</span><span class="p">,</span> <span class="s">"mesh"</span><span class="p">,</span> <span class="kc">false</span> <span class="c">/*don't clean (ie delete everything in) directory!*/</span><span class="p">);</span>
        mesh_writer<span class="p">.</span>WriteFilesUsingMesh<span class="p">(</span>mesh<span class="p">);</span>

        VecDestroy<span class="p">(</span>initial_condition<span class="p">);</span>
        VecDestroy<span class="p">(</span>result<span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
        
        
      </div>

    </div>
  </body>
</html>
