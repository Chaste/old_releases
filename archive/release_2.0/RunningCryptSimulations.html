<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
 <title>Chaste User Tutorial</title>
 <link rel="stylesheet" href="/trac/css/trac.css" type="text/css" />
 <link rel="stylesheet" href="/trac/css/wiki.css" type="text/css" />


 <style type="text/css">
/* Link styles */
:link, :visited, a em {
 text-decoration: none;
 color: #283f6b;
 border-bottom: 1px dotted #bbb;
}
/*
:link:hover, :visited:hover {
 background-color: #eee;
 color: #555;
}
*/
</style>

</head>
<body>
<a id="logo" href="http://www.comlab.ox.ac.uk/chaste">
  <img src="/logos/chaste-266x60.jpg" alt="Chaste logo" />
</a>
<h1> RunningCryptSimulations tutorial file </h1>      </div>
    <div id="content" class="wiki">
      <p class="path noprint">
        <a class="pathentry" title="View UserTutorials" href="/cgi-bin/trac.cgi/wiki/UserTutorials">UserTutorials</a><span class="pathentry sep">/</span><a class="pathentry" title="View UserTutorials/RunningCryptSimulations" href="/cgi-bin/trac.cgi/wiki/UserTutorials/RunningCryptSimulations">RunningCryptSimulations</a>
        <br style="clear: both" />
      </p>
      <div class="wikipage searchable">
        
          <p>
This tutorial is automatically generated from the file trunk/cell_based/test/tutorial/TestRunningCryptSimulationsTutorial.hpp at revision <a class="missing changeset">r8392</a>.
Note that the code is given in full at the bottom of the page.
</p>
<h1 id="Examplesshowinghowtoruncryptsimulationsonperiodicmesheswithdifferentcellcyclemodels">Examples showing how to run crypt simulations on periodic meshes with different cell cycle models</h1>
<h2 id="Introduction">Introduction</h2>
<p>
In this tutorial we show how Chaste is used to run crypt simulations.
Full details of the computational model can be found in the paper by
van Leeuwen <i>et al</i> (2009) [doi:10.1111/j.1365-2184.2009.00627.x].
The first thing to do is include the following header, which allows us
to use certain methods in our test (this header file should be included
in any Chaste test).
</p>
<div class="code"><pre>#include &lt;cxxtest/TestSuite.h&gt;
</pre></div><p>
The next header file defines a helper class for generating
cells for crypt simulations. 
</p>
<div class="code"><pre>#include "CryptCellsGenerator.hpp"
</pre></div><p>
The next two header files define two different types of cell-cycle model,
one with fixed cell-cycle times and one where the cell-cycle time depends
on the Wnt concentration.
</p>
<div class="code"><pre>#include "FixedDurationGenerationBasedCellCycleModel.hpp"
#include "WntCellCycleModel.hpp"
</pre></div><p>
The next header file defines a helper class for generating a suitable mesh. 
</p>
<div class="code"><pre>#include "HoneycombMeshGenerator.hpp"
</pre></div><p>
The next header file defines a <tt>Tissue</tt> class that uses a mesh, and allows
for the inclusion ghost nodes. These are nodes in the mesh that do not correspond
to cells; instead they help ensure that a sensible Delaunay triangulation is generated
at each timestep (since the triangulation algorithm requires a convex hull). 
</p>
<div class="code"><pre>#include "MeshBasedTissueWithGhostNodes.hpp"
</pre></div><p>
The next header file defines a force law, based on a linear spring, for describing
the mechanical interactions between neighbouring cells in the tissue.
</p>
<div class="code"><pre>#include "GeneralisedLinearSpringForce.hpp"
</pre></div><p>
The next header file defines the class that simulates the evolution of a <tt>Tissue</tt>,
specialized to deal with the cylindrical crypt model.
</p>
<div class="code"><pre>#include "CryptSimulation2d.hpp"
</pre></div><p>
The next header file defines a Wnt singleton class, which (if used) deals with the
imposed Wnt gradient in our crypt model.
</p>
<div class="code"><pre>#include "WntConcentration.hpp"
</pre></div><p>
The final header file defines a cell killer class, which implements sloughing of cells
into the lumen once they reach the top of the crypt.
</p>
<div class="code"><pre>#include "SloughingCellKiller.hpp"
</pre></div><p>
Next, we define the test class, which inherits from <tt>CxxTest::TestSuite</tt>
and defines some test methods.
</p>
<div class="code"><pre>class TestRunningCryptSimulationsTutorial : public CxxTest::TestSuite
{
public:
</pre></div><h2 id="Test1-abasiccryptsimulation">Test 1 - a basic crypt simulation</h2>
<p>
In the first test, we run a simple crypt simulation, in which we use
a cylindrical mesh, give each cell a fixed cell-cycle model, and enforce
sloughing at the top of the crypt.
</p>
<div class="code"><pre>    void TestCryptFixedCellCycle() throw(Exception)
    {
</pre></div><p>
As in <strong>all</strong> tissue simulations, we must first set the start time.
In addition, it is advisable to reset the values of all model parameters.
<tt>SimulationTime</tt> and <tt>TissueConfig</tt> are <i>singleton</i> classes; this
means that one and only one of each of these objects is instantiated at
any time, and that that single object is accessible from anywhere in the
code. As a result, we do not need to keep passing round the current time or
model parameter values.
</p>
<div class="code"><pre>        SimulationTime::Instance()-&gt;SetStartTime(0.0);
        TissueConfig::Instance()-&gt;Reset();
</pre></div><p>
Next, we generate a mesh. The basic Chaste mesh is <tt>TetrahedralMesh</tt>.
To enforce periodicity at the left and right hand sides of the mesh, we
use a sublcass called <tt>Cylindrical2dMesh</tt>, which has extra methods for
maintaining periodicity. To create a <tt>Cylindrical2dMesh</tt>, we can use
the <tt>HoneycombMeshGenerator</tt>. This generates a honeycomb-shaped mesh,
in which all nodes are equidistant. Here the first and second arguments
define the size of the mesh - we have chosen a mesh that is 6 nodes (i.e.
cells) wide, and 9 nodes high. The third argument indicates that we require
a double layer of ghost nodes around the mesh (technically, just above
and below the mesh, since it is periodic).
</p>
<div class="code"><pre>        HoneycombMeshGenerator generator(6, 9, 2, true); // parameters are: cells across, cells up, thickness of ghost layer, whether to be cylindrical
        Cylindrical2dMesh* p_mesh = generator.GetCylindricalMesh();
        std::vector&lt;unsigned&gt; location_indices = generator.GetCellLocationIndices();
</pre></div><p>
Having created a mesh, we now create a <tt>std::vector</tt> of <tt>TissueCell</tt>s.
To do this, we the <tt>CryptCellsGenerator</tt> helper class, which is templated over the type
of cell model required (here <tt>FixedDurationGenerationBasedCellCycleModel</tt>)
and the dimension. We create an empty vector of cells and pass this into the
method along with the mesh. The third argument 'true' indicates that the cells
should be assigned random birth times, to avoid synchronous division. The
<tt>cells</tt> vector is populated once the method <tt>Generate</tt> is
called. 
</p>
<div class="code"><pre>        std::vector&lt;TissueCell&gt; cells;
        CryptCellsGenerator&lt;FixedDurationGenerationBasedCellCycleModel&gt; cells_generator;
        cells_generator.Generate(cells, p_mesh, location_indices, true);
</pre></div><p>
Now we have a mesh, a set of cells to go with it, and ghost nodes indices,
we can create a <i>Tissue</i>. In general, this class associates a collection
of cells with a set of nodes or a mesh. For this test, because we have a
mesh and ghost nodes, we use aparticular type of tissue called a
<tt>MeshBasedTissueWithGhostNodes</tt>.
</p>
<div class="code"><pre>        MeshBasedTissueWithGhostNodes&lt;2&gt; tissue(*p_mesh, cells, location_indices);
</pre></div><p>
We must now create one or more force laws, which determine the mechanics of
the tissue. For this test, we assume that a cell experiences a force from each
neighbour that can be represented as a linear overdamped spring. We put a pointer
to this force into a vector.
</p>
<div class="code"><pre>        GeneralisedLinearSpringForce&lt;2&gt; linear_force;
        std::vector&lt;AbstractForce&lt;2&gt;*&gt; force_collection;
        force_collection.push_back(&amp;linear_force);
</pre></div><p>
Now we define the tissue simulation object, passing in the tissue and collection
of force laws: 
</p>
<div class="code"><pre>        CryptSimulation2d simulator(tissue, force_collection);
</pre></div><p>
Set the output directory on the simulator (relative to
"/tmp/&lt;USER_NAME&gt;/testoutput") and the end time (in hours).
</p>
<div class="code"><pre>        simulator.SetOutputDirectory("CryptTutorialFixedCellCycle");
        simulator.SetEndTime(1);
</pre></div><p>
For longer simulations, you may not want to output the results
every time step. In this case you can use the following method,
to print results every 10 time steps instead. As the time step
used by the simulator, is 30 s, this method will cause the
simulator to print results every 5 min.
</p>
<div class="code"><pre>        //simulator.SetSamplingTimestepMultiple(10);
</pre></div><p>
Before running the simulation, we add a cell killer. This object
dictates conditions under which cells die. For this test, we use
a <tt>SloughingCellKiller</tt>, which kills cells above a certain height.
</p>
<div class="code"><pre>        SloughingCellKiller&lt;2&gt; killer(&amp;tissue);
        simulator.AddCellKiller(&amp;killer);
</pre></div><p>
To run the simulation, we call <tt>Solve()</tt>. 
</p>
<div class="code"><pre>        simulator.Solve();
</pre></div><p>
<tt>SimulationTime::Destroy()</tt> <strong>must</strong> be called at the end of the test.
If not, when <tt>SimulationTime::Instance()-&gt;SetStartTime(0.0);</tt> is called
at the beginning of the next test in this file, an assertion will be triggered.
</p>
<div class="code"><pre>        SimulationTime::Destroy();
    }
</pre></div><p>
To visualize the results, open a new terminal, <tt>cd</tt> to the Chaste directory,
then <tt>cd</tt> to <tt>anim</tt>. Then do: <tt>java Visualize2dCells /tmp/$USER/testoutput/CryptTutorialFixedCellCycle/results_from_time_0</tt>.
You may have to do: <tt>javac Visualize2dCells.java</tt> beforehand to create the
java executable.
</p>
<h2 id="Test2-usingWntbasedcell-cyclemodels">Test 2 - using Wnt based cell-cycle models</h2>
<p>
The next test is very similar (almost identical in fact), except instead of
using a fixed cell cycle model, we use a Wnt (a protein) based cell cycle model,
with the Wnt concentration depending on the position of the cell within the crypt.
</p>
<div class="code"><pre>    void TestCryptWntCellCycle() throw(Exception)
    {
</pre></div><p>
First re-initialize time to zero, and reset the <tt>TissueConfig</tt> singleton, again. 
</p>
<div class="code"><pre>        SimulationTime::Instance()-&gt;SetStartTime(0.0);
        RandomNumberGenerator::Instance()-&gt;Reseed(0);
        TissueConfig::Instance()-&gt;Reset();
</pre></div><p>
Create a cylindrical mesh, and get the cell location indices, exactly as before. 
</p>
<div class="code"><pre>        HoneycombMeshGenerator generator(6, 9, 2, true);
        Cylindrical2dMesh* p_mesh = generator.GetCylindricalMesh();
        std::vector&lt;unsigned&gt; location_indices = generator.GetCellLocationIndices();
</pre></div><p>
Create the cells, using the same method as before. Here, though, we use a <tt>WntCellCycleModel</tt>.
</p>
<div class="code"><pre>        std::vector&lt;TissueCell&gt; cells;
        CryptCellsGenerator&lt;WntCellCycleModel&gt; cells_generator;
        cells_generator.Generate(cells, p_mesh, location_indices, true);
</pre></div><p>
Create the tissue, as before. 
</p>
<div class="code"><pre>        MeshBasedTissueWithGhostNodes&lt;2&gt; tissue(*p_mesh, cells, location_indices);
</pre></div><p>
The other change needed: Cells with a Wnt-based cell cycle need to know
the concentration of Wnt wherever they are. To do this, we set up a <tt>WntConcentration</tt>
class. This is another singleton class (ie accessible from anywhere), so all
cells and cell cycle models can access it. We need to say what the profile of the
Wnt concentation should be - here, we say it is <tt>LINEAR</tt> (linear decreasing from 1 to 0
from the bottom of the crypt to the top). We also need to inform the <tt>WntConcentration</tt>
of the tissue.
</p>
<div class="code"><pre>        WntConcentration&lt;2&gt;::Instance()-&gt;SetType(LINEAR);
        WntConcentration&lt;2&gt;::Instance()-&gt;SetTissue(tissue);
</pre></div><p>
Create a force collection as above. 
</p>
<div class="code"><pre>        GeneralisedLinearSpringForce&lt;2&gt; linear_force;
        std::vector&lt;AbstractForce&lt;2&gt;*&gt; force_collection;
        force_collection.push_back(&amp;linear_force);
</pre></div><p>
Create a simulator as before (except setting a different output directory). 
</p>
<div class="code"><pre>        CryptSimulation2d simulator(tissue,force_collection);
        simulator.SetOutputDirectory("CryptTutorialWntCellCycle");
        simulator.SetEndTime(1);
</pre></div><p>
Create a killer, as before. 
</p>
<div class="code"><pre>        SloughingCellKiller&lt;2&gt; killer(&amp;tissue);
        simulator.AddCellKiller(&amp;killer);
</pre></div><p>
Solve. 
</p>
<div class="code"><pre>        simulator.Solve();
</pre></div><p>
Finally, tidy up by destroying the <tt>SimulationTime</tt> and the <tt>WntConcentration</tt> singleton objects.
The solution can be visualised using the visualizer as before, just with the different output directory. 
</p>
<div class="code"><pre>        WntConcentration&lt;2&gt;::Destroy();
        SimulationTime::Destroy();
    }
};
</pre></div><h1 id="Code">Code</h1>
<p>
The full code is given below
</p>
<div class="code"><pre>#include &lt;cxxtest/TestSuite.h&gt;
#include "CryptCellsGenerator.hpp"
#include "FixedDurationGenerationBasedCellCycleModel.hpp"
#include "WntCellCycleModel.hpp"
#include "HoneycombMeshGenerator.hpp"
#include "MeshBasedTissueWithGhostNodes.hpp"
#include "GeneralisedLinearSpringForce.hpp"
#include "CryptSimulation2d.hpp"
#include "WntConcentration.hpp"
#include "SloughingCellKiller.hpp"

class TestRunningCryptSimulationsTutorial : public CxxTest::TestSuite
{
public:
    void TestCryptFixedCellCycle() throw(Exception)
    {
        SimulationTime::Instance()-&gt;SetStartTime(0.0);
        TissueConfig::Instance()-&gt;Reset();

        HoneycombMeshGenerator generator(6, 9, 2, true); // parameters are: cells across, cells up, thickness of ghost layer, whether to be cylindrical
        Cylindrical2dMesh* p_mesh = generator.GetCylindricalMesh();
        std::vector&lt;unsigned&gt; location_indices = generator.GetCellLocationIndices();

        std::vector&lt;TissueCell&gt; cells;
        CryptCellsGenerator&lt;FixedDurationGenerationBasedCellCycleModel&gt; cells_generator;
        cells_generator.Generate(cells, p_mesh, location_indices, true);

        MeshBasedTissueWithGhostNodes&lt;2&gt; tissue(*p_mesh, cells, location_indices);

        GeneralisedLinearSpringForce&lt;2&gt; linear_force;
        std::vector&lt;AbstractForce&lt;2&gt;*&gt; force_collection;
        force_collection.push_back(&amp;linear_force);

        CryptSimulation2d simulator(tissue, force_collection);

        simulator.SetOutputDirectory("CryptTutorialFixedCellCycle");
        simulator.SetEndTime(1);
        //simulator.SetSamplingTimestepMultiple(10);

        SloughingCellKiller&lt;2&gt; killer(&amp;tissue);
        simulator.AddCellKiller(&amp;killer);

        simulator.Solve();

        SimulationTime::Destroy();
    }

    void TestCryptWntCellCycle() throw(Exception)
    {
        SimulationTime::Instance()-&gt;SetStartTime(0.0);
        RandomNumberGenerator::Instance()-&gt;Reseed(0);
        TissueConfig::Instance()-&gt;Reset();

        HoneycombMeshGenerator generator(6, 9, 2, true);
        Cylindrical2dMesh* p_mesh = generator.GetCylindricalMesh();
        std::vector&lt;unsigned&gt; location_indices = generator.GetCellLocationIndices();

        std::vector&lt;TissueCell&gt; cells;
        CryptCellsGenerator&lt;WntCellCycleModel&gt; cells_generator;
        cells_generator.Generate(cells, p_mesh, location_indices, true);

        MeshBasedTissueWithGhostNodes&lt;2&gt; tissue(*p_mesh, cells, location_indices);

        WntConcentration&lt;2&gt;::Instance()-&gt;SetType(LINEAR);
        WntConcentration&lt;2&gt;::Instance()-&gt;SetTissue(tissue);

        GeneralisedLinearSpringForce&lt;2&gt; linear_force;
        std::vector&lt;AbstractForce&lt;2&gt;*&gt; force_collection;
        force_collection.push_back(&amp;linear_force);

        CryptSimulation2d simulator(tissue,force_collection);
        simulator.SetOutputDirectory("CryptTutorialWntCellCycle");
        simulator.SetEndTime(1);

        SloughingCellKiller&lt;2&gt; killer(&amp;tissue);
        simulator.AddCellKiller(&amp;killer);

        simulator.Solve();

        WntConcentration&lt;2&gt;::Destroy();
        SimulationTime::Destroy();
    }
};
</pre></div>
        
        
      </div>
