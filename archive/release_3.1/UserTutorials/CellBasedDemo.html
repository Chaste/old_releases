<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>UserTutorials/CellBasedDemo - Chaste</title>
    <link rel="stylesheet" href="/trac/css/trac.css" type="text/css" />
    <link rel="stylesheet" href="/trac/css/wiki.css" type="text/css" />
    <link rel="stylesheet" href="/trac/css/site.css" type="text/css" />
    <style type="text/css">
/* Link styles */
:link, :visited, a em {
 text-decoration: none;
 color: #283f6b;
 border-bottom: 1px dotted #bbb;
}
/*
:link:hover, :visited:hover {
 background-color: #eee;
 color: #555;
}
*/
    </style>

  </head>
  <body>
    <div id="banner">
      <div id="header">
        <p>
          <a id="logo" href="http://www.cs.ox.ac.uk/chaste"><img src="/logos/chaste-266x60.jpg" alt="Chaste logo" height="60" width="266" /></a>
          <em>Documentation for <a href="/chaste/tutorials/release_3.1/">Release 3.1</a>.</em>
        </p>
      </div>
    </div>
    <p>&nbsp;</p>
    <div id="content" class="wiki">
      <p class="path noprint">
        <a class="pathentry" title="View UserTutorials" href="/chaste/tutorials/release_3.1/UserTutorials.html">UserTutorials</a><span class="pathentry sep">/</span><a class="pathentry" title="View UserTutorials/CellBasedDemo" href="/chaste/tutorials/release_3.1/UserTutorials/CellBasedDemo.html">CellBasedDemo</a>
        <br style="clear: both" />
      </p>
      <div class="wikipage searchable">
        
          <p>
This tutorial is automatically generated from the file trunk/cell_based/test/tutorial/TestCellBasedDemoTutorial.hpp at revision <a class="changeset" href="/cgi-bin/trac.cgi/changeset/14997" title="#1831 - apply BSD licence notice.">r14997</a>.
Note that the code is given in full at the bottom of the page.
</p>
<h1 id="Examplesshowinghowtocreaterunandcell-basedsimulationsinChaste">Examples showing how to create, run and cell-based simulations in Chaste</h1>
<h2 id="Introduction">Introduction</h2>
<p>
This tutroial is designed to give you a quick introduction to running cell-based
simulations in Chaste. Full details are postponed until later tutorials.
</p>
<p>
We begin with a simple monolayer simulation and see how to:
</p>
<ul><li>change the cell-level model;
</li><li>how to impose boundaries;
</li><li>how to impose periodic conditions;
</li><li>how to specify how to remove cells; and
</li><li>how to change cell-cycle models.
</li></ul><p>
 
</p>
<h2 id="Thetest">The test</h2>
<p>
We begin by including the necessary header files. These will be described in detail in
subsequent cell-based tutorials.
</p>
<div class="code"><pre><span class="cp">#include &lt;cxxtest/TestSuite.h&gt;
#include "CellBasedSimulationArchiver.hpp"
#include "SmartPointers.hpp"
#include "AbstractCellBasedTestSuite.hpp"

#include "AdhesionPottsUpdateRule.hpp"
#include "CellsGenerator.hpp"
#include "CylindricalHoneycombMeshGenerator.hpp"
#include "GeneralisedLinearSpringForce.hpp"
#include "HoneycombMeshGenerator.hpp"
#include "HoneycombVertexMeshGenerator.hpp"
#include "MeshBasedCellPopulationWithGhostNodes.hpp"
#include "NagaiHondaForce.hpp"
#include "NodeBasedCellPopulation.hpp"
#include "OffLatticeSimulation.hpp"
#include "OnLatticeSimulation.hpp"
#include "PlaneBoundaryCondition.hpp"
#include "PottsBasedCellPopulation.hpp"
#include "PottsMeshGenerator.hpp"
#include "RandomCellKiller.hpp"
#include "RepulsionForce.hpp"
#include "StochasticDurationCellCycleModel.hpp"
#include "SurfaceAreaConstraintPottsUpdateRule.hpp"
#include "TysonNovakCellCycleModel.hpp"
#include "VertexBasedCellPopulation.hpp"
#include "VolumeConstraintPottsUpdateRule.hpp"
</span></pre></div><p>
Next, we define the test class, which inherits from <tt>AbstractCellBasedTestSuite</tt>
and defines some test methods. We are using <tt>AbstractCellBasedTestSuite</tt> instead of <tt>CxxTest::TestSuite</tt> as this
handles some of the simulations set up for us, details are given in later tutorials,
<a class="wiki" href="/chaste/tutorials/release_3.1/UserTutorials/RunningMeshBasedSimulations.html">UserTutorials/RunningMeshBasedSimulations</a> and <a class="wiki" href="/chaste/tutorials/release_3.1/UserTutorials/RunningNodeBasedSimulations.html">UserTutorials/RunningNodeBasedSimulations</a>.
</p>
<div class="code"><pre><span class="k">class</span> <span class="nc">TestCellBasedDemoTutorial</span> <span class="o">:</span> <span class="k">public</span> AbstractCellBasedTestSuite
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
</pre></div><h2 id="Test1-abasicvertex-basedsimulation">Test 1 - a basic vertex-based simulation</h2>
<p>
In the first test, we run a simple vertex-based simulation of an epithelial monolayer.
Each cell in the simulation is assigned a simple stochastic cell-cycle model, the cells will divide randomly and never stop proliferating.
</p>
<div class="code"><pre>    <span class="kt">void</span> TestVertexBasedMonolayer<span class="p">()</span> <span class="k">throw</span> <span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
</pre></div><p>
The first thing we define is a 2D (specified by the &lt;2,2&gt;) mesh which holds the spatial information of the simulation. To do this we use one of a
number of <tt>MeshGenerators</tt>.
</p>
<div class="code"><pre>        HoneycombVertexMeshGenerator generator<span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
        MutableVertexMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetMesh<span class="p">();</span>
</pre></div><p>
We now generate a collection of cells. We do this by using a <tt>CellsGenerator</tt> and we specify the proliferative
behaviour of the cell by choosing a <tt>CellCycleModel</tt>, here we choose a <tt>StochasticDurationCellCycleModel</tt> where
each cell is given a division time, drawn from a uniform distribution, when it is created. For a vertex simulation
we need as may cells as elements in the mesh.
</p>
<div class="code"><pre>        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        CellsGenerator<span class="o">&lt;</span>StochasticDurationCellCycleModel<span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> cells_generator<span class="p">;</span>
        cells_generator<span class="p">.</span>GenerateBasicRandom<span class="p">(</span>cells<span class="p">,</span> p_mesh<span class="o">-&gt;</span>GetNumElements<span class="p">(),</span> TRANSIT<span class="p">);</span>
</pre></div><p>
We now create a <tt>CellPopulation</tt> object (passing in the mesh and cells) to connect the mesh and the cells together.
Here that is a <tt>VertexBasedCellPopulation</tt> and the dimension is &lt;2&gt;.
</p>
<div class="code"><pre>        VertexBasedCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">);</span>
</pre></div><p>
We now create an <tt>OffLatticeSimulation</tt> object and pass in the
<tt>CellPopulation</tt>. We also set some options on the simulation
like output directory, output multiple (so we don't visualize every
timestep), and end time.
</p>
<div class="code"><pre>        OffLatticeSimulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> simulator<span class="p">(</span>cell_population<span class="p">);</span>
        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"CellBasedDemo1"</span><span class="p">);</span>
        simulator<span class="p">.</span>SetSamplingTimestepMultiple<span class="p">(</span><span class="mi">200</span><span class="p">);</span>
        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mf">20.0</span><span class="p">);</span>
</pre></div><p>
In order to specify how cells move around we create a "shared pointer" to a
<tt>Force</tt> object and pass it to the <tt>OffLatticeSimulation</tt>. This is done using the MAKE_PTR macro as follows.
</p>
<div class="code"><pre>        MAKE_PTR<span class="p">(</span>NagaiHondaForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_force<span class="p">);</span>
        simulator<span class="p">.</span>AddForce<span class="p">(</span>p_force<span class="p">);</span>
</pre></div><p>
Finally we call the <tt>Solve</tt> method on the simulation to run the simulation.
</p>
<div class="code"><pre>        simulator<span class="p">.</span>Solve<span class="p">();</span>
    <span class="p">}</span>
</pre></div><p>
To visualize the results, open a new terminal, <tt>cd</tt> to the Chaste directory,
then <tt>cd</tt> to <tt>anim</tt>. Then do: <tt>java Visualize2dVertexCells /tmp/$USER/testoutput/CellBasedDemo1/results_from_time_0</tt>.
We may have to do: <tt>javac Visualize2dVertexCells.java</tt> beforehand to create the
java executable.
</p>
<h2 id="Test2-basicnode-basedsimulation">Test 2 - basic node-based simulation</h2>
<p>
We next show how to modify the previous test to implement a 'node-based' simulation,
in which cells are represented by overlapping spheres (actually circles, since we're
in 2D).
</p>
<div class="code"><pre>    <span class="kt">void</span> TestNodeBasedMonolayer<span class="p">()</span> <span class="k">throw</span> <span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
</pre></div><p>
We now need to create a <tt>NodesOnlyMesh</tt> we do this by first creating a <tt>MutableMesh</tt>
and passing this to a helper method <tt>ConstructNodesWithoutMesh</tt>. Note that we need to
delete <tt>p_mesh</tt> at the end of the test, to avoid memory leaks, as we created this pointer.
</p>
<div class="code"><pre>        HoneycombMeshGenerator generator<span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c">//**Changed**//
</span>        MutableMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> p_generating_mesh <span class="o">=</span> generator<span class="p">.</span>GetMesh<span class="p">();</span> <span class="c">//**Changed**//
</span>        NodesOnlyMesh<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;*</span> p_mesh <span class="o">=</span> <span class="k">new</span> NodesOnlyMesh<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">;</span> <span class="c">//**Changed**//
</span>        p_mesh<span class="o">-&gt;</span>ConstructNodesWithoutMesh<span class="p">(</span><span class="o">*</span>p_generating_mesh<span class="p">);</span> <span class="c">//**Changed**//
</span></pre></div><p>
We create the cells as before, only this time we need one cell per node.
</p>
<div class="code"><pre>        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        CellsGenerator<span class="o">&lt;</span>StochasticDurationCellCycleModel<span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> cells_generator<span class="p">;</span>
        cells_generator<span class="p">.</span>GenerateBasicRandom<span class="p">(</span>cells<span class="p">,</span> p_mesh<span class="o">-&gt;</span>GetNumNodes<span class="p">(),</span> TRANSIT<span class="p">);</span> <span class="c">//**Changed**//
</span></pre></div><p>
This time we create a <tt>NodeBasedCellPopulation</tt> as we are using a <tt>NodesOnlyMesh</tt>.
We also set a cut off length to speed up simulations. This defines a radius of interaction for the cells.
</p>
<div class="code"><pre>        NodeBasedCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">);</span><span class="c">//**Changed**//
</span>        cell_population<span class="p">.</span>SetMechanicsCutOffLength<span class="p">(</span><span class="mf">1.5</span><span class="p">);</span> <span class="c">//**Changed**//
</span></pre></div><p>
We create an <tt>OffLatticeSimulation</tt> object as before, all we change is the output directory
and output results more often as a larger default timestep is used for these simulations.
</p>
<div class="code"><pre>        OffLatticeSimulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> simulator<span class="p">(</span>cell_population<span class="p">);</span>
        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"CellBasedDemo2"</span><span class="p">);</span> <span class="c">//**Changed**//
</span>        simulator<span class="p">.</span>SetSamplingTimestepMultiple<span class="p">(</span><span class="mi">12</span><span class="p">);</span> <span class="c">//**Changed**//
</span>        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mf">20.0</span><span class="p">);</span>
</pre></div><p>
We use a different <tt>Force</tt> which is suitable for node based simulations.
</p>
<div class="code"><pre>        MAKE_PTR<span class="p">(</span>RepulsionForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_force<span class="p">);</span> <span class="c">//**Changed**//
</span>        simulator<span class="p">.</span>AddForce<span class="p">(</span>p_force<span class="p">);</span>
</pre></div><p>
In all types of simulation you may specify how cells are removed from the simulation by specifying
a <tt>CellKiller</tt>. You create these in the same was as the <tt>Force</tt> and pass them to the <tt>CellBasedSimulation</tt>.
Note that here the constructor for <tt>RandomCellKiller</tt> requires some arguments to be passed to it, therefore we use the
<tt>MAKE_PTR_ARGS</tt> macro.
</p>
<div class="code"><pre>        MAKE_PTR_ARGS<span class="p">(</span>RandomCellKiller<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_cell_killer<span class="p">,</span> <span class="p">(</span><span class="o">&amp;</span>cell_population<span class="p">,</span> <span class="mf">0.01</span><span class="p">));</span> <span class="c">//**Changed**//
</span>        simulator<span class="p">.</span>AddCellKiller<span class="p">(</span>p_cell_killer<span class="p">);</span>
</pre></div><p>
Again we call the <tt>Solve</tt> method on the simulation to run the simulation.
</p>
<div class="code"><pre>        simulator<span class="p">.</span>Solve<span class="p">();</span>
</pre></div><p>
Before finishing the test we delete the pointer to the mesh to avoid memory leaks
</p>
<div class="code"><pre>        <span class="k">delete</span> p_mesh<span class="p">;</span> <span class="c">//** Changed**// to stop memory leaks
</span>    <span class="p">}</span>
</pre></div><p>
To visualize the results, open a new terminal, <tt>cd</tt> to the Chaste directory,
then <tt>cd</tt> to <tt>anim</tt>. Then do: <tt>java Visualize2dCentreCells /tmp/$USER/testoutput/CellBasedDemo2/results_from_time_0</tt>.
We may have to do: <tt>javac Visualize2dCentreCells.java</tt> beforehand to create the
java executable.
</p>
<h2 id="Test3-basicmesh-basedsimulation">Test 3 - basic mesh-based simulation</h2>
<p>
We next show how to modify the previous test to implement a 'mesh-based' simulation,
in which cells are represented by their centres and a Voronoi tessellation is used to
find nearest neighbours.
</p>
<div class="code"><pre>    <span class="kt">void</span> TestMeshBasedMonolayer<span class="p">()</span> <span class="k">throw</span> <span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
</pre></div><p>
This time we just create a <tt>MutableMesh</tt> and use that to specify the spatial locations of cells.
</p>
<div class="code"><pre>        HoneycombMeshGenerator generator<span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
        MutableMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetMesh<span class="p">();</span>  <span class="c">//**Changed**//
</span></pre></div><p>
We create the same number of cells as the previous test.
</p>
<div class="code"><pre>        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        CellsGenerator<span class="o">&lt;</span>StochasticDurationCellCycleModel<span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> cells_generator<span class="p">;</span>
        cells_generator<span class="p">.</span>GenerateBasicRandom<span class="p">(</span>cells<span class="p">,</span> p_mesh<span class="o">-&gt;</span>GetNumNodes<span class="p">(),</span> TRANSIT<span class="p">);</span>
</pre></div><p>
This time we create a <tt>MeshBasedCellPopulation</tt> as we are using a <tt>MutableMesh</tt>.
</p>
<div class="code"><pre>        MeshBasedCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">);</span> <span class="c">//**Changed**//
</span></pre></div><p>
We create an <tt>OffLatticeSimulation</tt> object as before, all we change is the output directory.
</p>
<div class="code"><pre>        OffLatticeSimulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> simulator<span class="p">(</span>cell_population<span class="p">);</span>
        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"CellBasedDemo3"</span><span class="p">);</span> <span class="c">//**Changed**//
</span>        simulator<span class="p">.</span>SetSamplingTimestepMultiple<span class="p">(</span><span class="mi">12</span><span class="p">);</span>
        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mf">20.0</span><span class="p">);</span>
</pre></div><p>
We use a different <tt>Force</tt> which is suitable for mesh based simulations.
Note we could of used the same one as before as node based and mesh based simulations
share many of the same forces the only difference between the two models is in how cell-cell interactions
are specified.
</p>
<div class="code"><pre>        MAKE_PTR<span class="p">(</span>GeneralisedLinearSpringForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_force<span class="p">);</span> <span class="c">//**Changed**//
</span>        simulator<span class="p">.</span>AddForce<span class="p">(</span>p_force<span class="p">);</span>
</pre></div><p>
Again we call the <tt>Solve</tt> method on the simulation to run the simulation.
</p>
<div class="code"><pre>        simulator<span class="p">.</span>Solve<span class="p">();</span>
    <span class="p">}</span>
</pre></div><p>
The results may be visualized using <tt>Visualize2dCentreCells</tt> as described in the
previous test, with the results directory changed from <tt>CellBasedDemo2</tt> to <tt>CellBasedDemo3</tt>.
</p>
<h2 id="Test4-basicmesh-basedsimulationwithghostnodes">Test 4 - basic mesh-based simulation with ghost nodes</h2>
<p>
We next show how to modify the previous test to include 'ghost nodes', which do not
correspond to cells but are sometimes needed when using a Voronoi tessellation. We
will discuss ghost nodes in more detail in subsequent cell-based tutorials.
</p>
<div class="code"><pre>    <span class="kt">void</span> TestMeshBasedMonolayerWithGhostNodes<span class="p">()</span> <span class="k">throw</span> <span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
</pre></div><p>
This time we just create a <tt>MutableMesh</tt> and use that to specify the spatial locations of cells.
Here we pass an extra argument to the <tt>HoneycombMeshGenerator</tt> which adds another 2 rows of
nodes round the mesh, known as ghost nodes.
</p>
<div class="code"><pre>        HoneycombMeshGenerator generator<span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c">//**Changed**//
</span>        MutableMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetMesh<span class="p">();</span>
</pre></div><p>
We only want to create cells for non ghost nodes. To find these we get them from the <tt>HoneycombMeshGenerator</tt>
using the method <tt>GetCellLocationIndices</tt>. We also use a different <tt>CellCycleModel</tt>. Here we use a
<tt>TysonNovakCellCycleModel</tt> which solves a coupled set of ODEs for each cell to calculate when each cell divides.
</p>
<div class="code"><pre>        std<span class="o">::</span>vector<span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> location_indices <span class="o">=</span> generator<span class="p">.</span>GetCellLocationIndices<span class="p">();</span><span class="c">//**Changed**//
</span>        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        CellsGenerator<span class="o">&lt;</span>TysonNovakCellCycleModel<span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> cells_generator<span class="p">;</span> <span class="c">//**Changed**//
</span>        cells_generator<span class="p">.</span>GenerateBasicRandom<span class="p">(</span>cells<span class="p">,</span> location_indices<span class="p">.</span>size<span class="p">(),</span> TRANSIT<span class="p">);</span> <span class="c">//**Changed**//
</span></pre></div><p>
This time we create a <tt>MeshBasedCellPopulation</tt> as we are using a <tt>MutableMesh</tt> and have ghost nodes.
We also need to pass the indices of non ghost nodes as an extra argument.
</p>
<div class="code"><pre>        MeshBasedCellPopulationWithGhostNodes<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">,</span> location_indices<span class="p">);</span> <span class="c">//**Changed**//
</span></pre></div><p>
We create an <tt>OffLatticeSimulation</tt> object as before, all we change is the output directory and the end time.
The Tyson Novak model is for yeast cells and therefore cells proliferate much more often and so we run the simulation for
less time to keep cell numbers relatively small for this demo.
</p>
<div class="code"><pre>        OffLatticeSimulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> simulator<span class="p">(</span>cell_population<span class="p">);</span>
        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"CellBasedDemo4"</span><span class="p">);</span> <span class="c">//**Changed**//
</span>        simulator<span class="p">.</span>SetSamplingTimestepMultiple<span class="p">(</span><span class="mi">12</span><span class="p">);</span>
        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mf">2.0</span><span class="p">);</span> <span class="c">//**Changed**//
</span></pre></div><p>
We use the same <tt>Force</tt> as before and run the simulation in the same way.
</p>
<div class="code"><pre>        MAKE_PTR<span class="p">(</span>GeneralisedLinearSpringForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_force<span class="p">);</span>
        simulator<span class="p">.</span>AddForce<span class="p">(</span>p_force<span class="p">);</span>

        simulator<span class="p">.</span>Solve<span class="p">();</span>
    <span class="p">}</span>
</pre></div><p>
The results may be visualized using <tt>Visualize2dCentreCells</tt> as described in the
previous test, with the results directory changed from <tt>CellBasedDemo3</tt> to <tt>CellBasedDemo4</tt>.
</p>
<h2 id="Test5-basicperiodicmesh-basedsimulation">Test 5 - basic periodic mesh-based simulation</h2>
<p>
We next show how to modify the previous test to implement a periodic boundary to the
left and right of the domain.
</p>
<div class="code"><pre>    <span class="kt">void</span> TestMeshBasedMonolayerPeriodic<span class="p">()</span> <span class="k">throw</span> <span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
</pre></div><p>
We now want to impose periodic boundaries on the domain. To do this we create a <tt>Cylindrical2dMesh</tt>
using a <tt>CylindricalHoneycombMeshGenerator</tt>.
</p>
<div class="code"><pre>        CylindricalHoneycombMeshGenerator generator<span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c">//**Changed**//
</span>        Cylindrical2dMesh<span class="o">*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetCylindricalMesh<span class="p">();</span> <span class="c">//**Changed**//
</span></pre></div><p>
Again we create one cell for each non ghost node. Note that we have changed back to using a <tt>StochasticDurationCellCycleModel</tt>.
</p>
<div class="code"><pre>        std<span class="o">::</span>vector<span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> location_indices <span class="o">=</span> generator<span class="p">.</span>GetCellLocationIndices<span class="p">();</span>
        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        CellsGenerator<span class="o">&lt;</span>StochasticDurationCellCycleModel<span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> cells_generator<span class="p">;</span> <span class="c">//**Changed**//
</span>        cells_generator<span class="p">.</span>GenerateBasicRandom<span class="p">(</span>cells<span class="p">,</span> location_indices<span class="p">.</span>size<span class="p">(),</span> TRANSIT<span class="p">);</span>
</pre></div><p>
We use the same <tt>CellPopulation</tt>, <tt>CellBasedSimulation</tt> (only changing the output directory and end time) and <tt>Force</tt> as before and run the simulation.
</p>
<div class="code"><pre>        MeshBasedCellPopulationWithGhostNodes<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">,</span> location_indices<span class="p">);</span>

        OffLatticeSimulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> simulator<span class="p">(</span>cell_population<span class="p">);</span>
        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"CellBasedDemo5"</span><span class="p">);</span> <span class="c">//**Changed**//
</span>        simulator<span class="p">.</span>SetSamplingTimestepMultiple<span class="p">(</span><span class="mi">12</span><span class="p">);</span>
        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mf">20.0</span><span class="p">);</span> <span class="c">//**Changed**//
</span>
        MAKE_PTR<span class="p">(</span>GeneralisedLinearSpringForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_force<span class="p">);</span>
        simulator<span class="p">.</span>AddForce<span class="p">(</span>p_force<span class="p">);</span>

        simulator<span class="p">.</span>Solve<span class="p">();</span>
    <span class="p">}</span>
</pre></div><p>
The results may be visualized using <tt>Visualize2dCentreCells</tt> as described in the
previous test, with the results directory changed from <tt>CellBasedDemo4</tt> to <tt>CellBasedDemo5</tt>.
</p>
<h2 id="Test6-basicperiodicmesh-basedsimulationwithobstructions">Test 6 - basic periodic mesh-based simulation with obstructions</h2>
<p>
We next show how to modify the previous test to include one
or more 'obstructions' within the domain.
</p>
<div class="code"><pre>    <span class="kt">void</span> TestMeshBasedMonolayerPeriodicSolidBottomBoundary<span class="p">()</span> <span class="k">throw</span> <span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
</pre></div><p>
We make the same <tt>Mesh</tt>, <tt>Cells</tt>, <tt>CellPopulation</tt>,
<tt>CellBasedSimulation</tt> and forces as before, all we change is the output directory.
</p>
<div class="code"><pre>        CylindricalHoneycombMeshGenerator generator<span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
        Cylindrical2dMesh<span class="o">*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetCylindricalMesh<span class="p">();</span>

        std<span class="o">::</span>vector<span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> location_indices <span class="o">=</span> generator<span class="p">.</span>GetCellLocationIndices<span class="p">();</span>
        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        CellsGenerator<span class="o">&lt;</span>StochasticDurationCellCycleModel<span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> cells_generator<span class="p">;</span>
        cells_generator<span class="p">.</span>GenerateBasicRandom<span class="p">(</span>cells<span class="p">,</span> location_indices<span class="p">.</span>size<span class="p">(),</span> STEM<span class="p">);</span>

        MeshBasedCellPopulationWithGhostNodes<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">,</span> location_indices<span class="p">);</span>

        OffLatticeSimulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> simulator<span class="p">(</span>cell_population<span class="p">);</span>
        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"CellBasedDemo6"</span><span class="p">);</span> <span class="c">//**Changed**//
</span>        simulator<span class="p">.</span>SetSamplingTimestepMultiple<span class="p">(</span><span class="mi">50</span><span class="p">);</span>
        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mf">20.0</span><span class="p">);</span>

        MAKE_PTR<span class="p">(</span>GeneralisedLinearSpringForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_force<span class="p">);</span>
        simulator<span class="p">.</span>AddForce<span class="p">(</span>p_force<span class="p">);</span>
</pre></div><p>
We now want to impose the condition y&gt;0 on the cells. To do this we create a "shared pointer" to a <tt>PlaneBoundaryCondition</tt>.
Much like the <tt>RandomCellKiller</tt> earlier we pass arguments to the constructor (a point (0,0) on the plane (line in 2D) and an outward pointing normal to the plane (0,-1) ) using the <tt>MAKE_PTR_ARGS</tt> macro.
</p>
<div class="code"><pre>        c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> point <span class="o">=</span> zero_vector<span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> normal <span class="o">=</span> zero_vector<span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        normal<span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">;</span>
        MAKE_PTR_ARGS<span class="p">(</span>PlaneBoundaryCondition<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_bc<span class="p">,</span> <span class="p">(</span><span class="o">&amp;</span>cell_population<span class="p">,</span> point<span class="p">,</span> normal<span class="p">));</span>
        simulator<span class="p">.</span>AddCellPopulationBoundaryCondition<span class="p">(</span>p_bc<span class="p">);</span>
</pre></div><p>
Finally we call the <tt>Solve</tt> method as in all other simulations.
</p>
<div class="code"><pre>        simulator<span class="p">.</span>Solve<span class="p">();</span>
    <span class="p">}</span>
</pre></div><p>
The results may be visualized using <tt>Visualize2dCentreCells</tt> as described in the
previous test, with the results directory changed from <tt>CellBasedDemo5</tt> to <tt>CellBasedDemo6</tt>.
</p>
<h2 id="Test7-basicPotts-basedsimulation">Test 7 - basic Potts-based simulation</h2>
<p>
In the final test we show how to modify the earlier tests (using off lattice models) to implement a 'Potts-based' simulation,
in which cells are represented by collections of sites on a fixed lattice.
</p>
<div class="code"><pre>   <span class="kt">void</span> TestPottsBasedMonolayer<span class="p">()</span> <span class="k">throw</span> <span class="p">(</span>Exception<span class="p">)</span>
   <span class="p">{</span>
</pre></div><p>
In common with the off lattice simulations we begin by creating a mesh. Here we use the <tt>PottsMeshGenerator</tt>
class to generate a <tt>PottsMesh</tt> each element in the mesh is a collection of lattice sites (represented by nodes at their centres).
All the connectivity between lattice sites is defined by the <tt>PottsMeshGenerator</tt>,
and there are arguments to make the domains periodic.
</p>
<div class="code"><pre>       PottsMeshGenerator<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> generator<span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span> <span class="c">//**Changed**//
</span>       PottsMesh<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetMesh<span class="p">();</span> <span class="c">//**Changed**//
</span></pre></div><p>
We generate one cell for each element as in vertex based simulations.
</p>
<div class="code"><pre>       std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
       CellsGenerator<span class="o">&lt;</span>StochasticDurationCellCycleModel<span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> cells_generator<span class="p">;</span>
       cells_generator<span class="p">.</span>GenerateBasicRandom<span class="p">(</span>cells<span class="p">,</span> p_mesh<span class="o">-&gt;</span>GetNumElements<span class="p">(),</span> TRANSIT<span class="p">);</span>
</pre></div><p>
As we have a <tt>PottsMesh</tt> we use a <tt>PottsBasedCellPopulation</tt>. Note here we also change the
"temperature" of the Potts simulation to make cells more motile.
</p>
<div class="code"><pre>       PottsBasedCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">);</span><span class="c">//**Changed**//
</span>       cell_population<span class="p">.</span>SetTemperature<span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
</pre></div><p>
As a Potts simulation is restricted to a lattice we create a <tt>OnSimulation</tt> object and pass in the <tt>CellPopulation</tt> in much the same
way as an <tt>OffLatticeSimulation</tt> in the above examples. We also set some
options on the simulation like output directory and end time.
</p>
<div class="code"><pre>       OnLatticeSimulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> simulator<span class="p">(</span>cell_population<span class="p">);</span><span class="c">//**Changed**//
</span>       simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"CellBasedDemo7"</span><span class="p">);</span> <span class="c">//**Changed**//
</span>       simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mf">20.0</span><span class="p">);</span>
</pre></div><p>
In order to specify how cells move around we create "shared pointer"s to
<tt>UpdateRule</tt> objects and pass them to the <tt>OnLatticeSimulation</tt>.
This is analogous to <tt>Forces</tt> in earlier examples.
</p>
<div class="code"><pre>       MAKE_PTR<span class="p">(</span>VolumeConstraintPottsUpdateRule<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_volume_constraint_update_rule<span class="p">);</span> <span class="c">//**Changed**//
</span>       simulator<span class="p">.</span>AddPottsUpdateRule<span class="p">(</span>p_volume_constraint_update_rule<span class="p">);</span> <span class="c">//**Changed**//
</span>       MAKE_PTR<span class="p">(</span>SurfaceAreaConstraintPottsUpdateRule<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_surface_area_update_rule<span class="p">);</span> <span class="c">//**Changed**//
</span>       simulator<span class="p">.</span>AddPottsUpdateRule<span class="p">(</span>p_surface_area_update_rule<span class="p">);</span> <span class="c">//**Changed**//
</span>       MAKE_PTR<span class="p">(</span>AdhesionPottsUpdateRule<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_adhesion_update_rule<span class="p">);</span> <span class="c">//**Changed**//
</span>       simulator<span class="p">.</span>AddPottsUpdateRule<span class="p">(</span>p_adhesion_update_rule<span class="p">);</span> <span class="c">//**Changed**//
</span></pre></div><p>
We can add <tt>CellKillers</tt> as before.
</p>
<div class="code"><pre>       MAKE_PTR_ARGS<span class="p">(</span>RandomCellKiller<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_cell_killer<span class="p">,</span> <span class="p">(</span><span class="o">&amp;</span>cell_population<span class="p">,</span> <span class="mf">0.01</span><span class="p">));</span>
       simulator<span class="p">.</span>AddCellKiller<span class="p">(</span>p_cell_killer<span class="p">);</span>
</pre></div><p>
Again we run the simulation by calling the <tt>Solve</tt> method.
</p>
<div class="code"><pre>       simulator<span class="p">.</span>Solve<span class="p">();</span>
   <span class="p">}</span>
</pre></div><p>
To visualize the results, open a new terminal, <tt>cd</tt> to the Chaste directory,
then <tt>cd</tt> to <tt>anim</tt>. Then do: <tt>java Visualize2dVertexCells /tmp/$USER/testoutput/CellBasedDemo7/results_from_time_0</tt>.
We may have to do: <tt>javac Visualize2dVertexCells.java</tt> beforehand to create the
java executable.
</p>
<div class="code"><pre><span class="p">};</span>
</pre></div><h1 id="Code">Code</h1>
<p>
The full code is given below
</p>
<h2 id="FilenameTestCellBasedDemoTutorial.hpp">File name <tt>TestCellBasedDemoTutorial.hpp</tt></h2>
<div class="code"><pre><span class="cp">#include &lt;cxxtest/TestSuite.h&gt;
#include "CellBasedSimulationArchiver.hpp"
#include "SmartPointers.hpp"
#include "AbstractCellBasedTestSuite.hpp"

#include "AdhesionPottsUpdateRule.hpp"
#include "CellsGenerator.hpp"
#include "CylindricalHoneycombMeshGenerator.hpp"
#include "GeneralisedLinearSpringForce.hpp"
#include "HoneycombMeshGenerator.hpp"
#include "HoneycombVertexMeshGenerator.hpp"
#include "MeshBasedCellPopulationWithGhostNodes.hpp"
#include "NagaiHondaForce.hpp"
#include "NodeBasedCellPopulation.hpp"
#include "OffLatticeSimulation.hpp"
#include "OnLatticeSimulation.hpp"
#include "PlaneBoundaryCondition.hpp"
#include "PottsBasedCellPopulation.hpp"
#include "PottsMeshGenerator.hpp"
#include "RandomCellKiller.hpp"
#include "RepulsionForce.hpp"
#include "StochasticDurationCellCycleModel.hpp"
#include "SurfaceAreaConstraintPottsUpdateRule.hpp"
#include "TysonNovakCellCycleModel.hpp"
#include "VertexBasedCellPopulation.hpp"
#include "VolumeConstraintPottsUpdateRule.hpp"
</span><span class="k">class</span> <span class="nc">TestCellBasedDemoTutorial</span> <span class="o">:</span> <span class="k">public</span> AbstractCellBasedTestSuite
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> TestVertexBasedMonolayer<span class="p">()</span> <span class="k">throw</span> <span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
        HoneycombVertexMeshGenerator generator<span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
        MutableVertexMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetMesh<span class="p">();</span>

        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        CellsGenerator<span class="o">&lt;</span>StochasticDurationCellCycleModel<span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> cells_generator<span class="p">;</span>
        cells_generator<span class="p">.</span>GenerateBasicRandom<span class="p">(</span>cells<span class="p">,</span> p_mesh<span class="o">-&gt;</span>GetNumElements<span class="p">(),</span> TRANSIT<span class="p">);</span>

        VertexBasedCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">);</span>

        OffLatticeSimulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> simulator<span class="p">(</span>cell_population<span class="p">);</span>
        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"CellBasedDemo1"</span><span class="p">);</span>
        simulator<span class="p">.</span>SetSamplingTimestepMultiple<span class="p">(</span><span class="mi">200</span><span class="p">);</span>
        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mf">20.0</span><span class="p">);</span>

        MAKE_PTR<span class="p">(</span>NagaiHondaForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_force<span class="p">);</span>
        simulator<span class="p">.</span>AddForce<span class="p">(</span>p_force<span class="p">);</span>

        simulator<span class="p">.</span>Solve<span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> TestNodeBasedMonolayer<span class="p">()</span> <span class="k">throw</span> <span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
        HoneycombMeshGenerator generator<span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c">//**Changed**//
</span>        MutableMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> p_generating_mesh <span class="o">=</span> generator<span class="p">.</span>GetMesh<span class="p">();</span> <span class="c">//**Changed**//
</span>        NodesOnlyMesh<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;*</span> p_mesh <span class="o">=</span> <span class="k">new</span> NodesOnlyMesh<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">;</span> <span class="c">//**Changed**//
</span>        p_mesh<span class="o">-&gt;</span>ConstructNodesWithoutMesh<span class="p">(</span><span class="o">*</span>p_generating_mesh<span class="p">);</span> <span class="c">//**Changed**//
</span>
        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        CellsGenerator<span class="o">&lt;</span>StochasticDurationCellCycleModel<span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> cells_generator<span class="p">;</span>
        cells_generator<span class="p">.</span>GenerateBasicRandom<span class="p">(</span>cells<span class="p">,</span> p_mesh<span class="o">-&gt;</span>GetNumNodes<span class="p">(),</span> TRANSIT<span class="p">);</span> <span class="c">//**Changed**//
</span>
        NodeBasedCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">);</span><span class="c">//**Changed**//
</span>        cell_population<span class="p">.</span>SetMechanicsCutOffLength<span class="p">(</span><span class="mf">1.5</span><span class="p">);</span> <span class="c">//**Changed**//
</span>
        OffLatticeSimulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> simulator<span class="p">(</span>cell_population<span class="p">);</span>
        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"CellBasedDemo2"</span><span class="p">);</span> <span class="c">//**Changed**//
</span>        simulator<span class="p">.</span>SetSamplingTimestepMultiple<span class="p">(</span><span class="mi">12</span><span class="p">);</span> <span class="c">//**Changed**//
</span>        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mf">20.0</span><span class="p">);</span>

        MAKE_PTR<span class="p">(</span>RepulsionForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_force<span class="p">);</span> <span class="c">//**Changed**//
</span>        simulator<span class="p">.</span>AddForce<span class="p">(</span>p_force<span class="p">);</span>

        MAKE_PTR_ARGS<span class="p">(</span>RandomCellKiller<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_cell_killer<span class="p">,</span> <span class="p">(</span><span class="o">&amp;</span>cell_population<span class="p">,</span> <span class="mf">0.01</span><span class="p">));</span> <span class="c">//**Changed**//
</span>        simulator<span class="p">.</span>AddCellKiller<span class="p">(</span>p_cell_killer<span class="p">);</span>

        simulator<span class="p">.</span>Solve<span class="p">();</span>

        <span class="k">delete</span> p_mesh<span class="p">;</span> <span class="c">//** Changed**// to stop memory leaks
</span>    <span class="p">}</span>

    <span class="kt">void</span> TestMeshBasedMonolayer<span class="p">()</span> <span class="k">throw</span> <span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
        HoneycombMeshGenerator generator<span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
        MutableMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetMesh<span class="p">();</span>  <span class="c">//**Changed**//
</span>
        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        CellsGenerator<span class="o">&lt;</span>StochasticDurationCellCycleModel<span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> cells_generator<span class="p">;</span>
        cells_generator<span class="p">.</span>GenerateBasicRandom<span class="p">(</span>cells<span class="p">,</span> p_mesh<span class="o">-&gt;</span>GetNumNodes<span class="p">(),</span> TRANSIT<span class="p">);</span>

        MeshBasedCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">);</span> <span class="c">//**Changed**//
</span>
        OffLatticeSimulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> simulator<span class="p">(</span>cell_population<span class="p">);</span>
        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"CellBasedDemo3"</span><span class="p">);</span> <span class="c">//**Changed**//
</span>        simulator<span class="p">.</span>SetSamplingTimestepMultiple<span class="p">(</span><span class="mi">12</span><span class="p">);</span>
        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mf">20.0</span><span class="p">);</span>

        MAKE_PTR<span class="p">(</span>GeneralisedLinearSpringForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_force<span class="p">);</span> <span class="c">//**Changed**//
</span>        simulator<span class="p">.</span>AddForce<span class="p">(</span>p_force<span class="p">);</span>

        simulator<span class="p">.</span>Solve<span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> TestMeshBasedMonolayerWithGhostNodes<span class="p">()</span> <span class="k">throw</span> <span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
        HoneycombMeshGenerator generator<span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c">//**Changed**//
</span>        MutableMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetMesh<span class="p">();</span>

        std<span class="o">::</span>vector<span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> location_indices <span class="o">=</span> generator<span class="p">.</span>GetCellLocationIndices<span class="p">();</span><span class="c">//**Changed**//
</span>        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        CellsGenerator<span class="o">&lt;</span>TysonNovakCellCycleModel<span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> cells_generator<span class="p">;</span> <span class="c">//**Changed**//
</span>        cells_generator<span class="p">.</span>GenerateBasicRandom<span class="p">(</span>cells<span class="p">,</span> location_indices<span class="p">.</span>size<span class="p">(),</span> TRANSIT<span class="p">);</span> <span class="c">//**Changed**//
</span>
        MeshBasedCellPopulationWithGhostNodes<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">,</span> location_indices<span class="p">);</span> <span class="c">//**Changed**//
</span>
        OffLatticeSimulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> simulator<span class="p">(</span>cell_population<span class="p">);</span>
        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"CellBasedDemo4"</span><span class="p">);</span> <span class="c">//**Changed**//
</span>        simulator<span class="p">.</span>SetSamplingTimestepMultiple<span class="p">(</span><span class="mi">12</span><span class="p">);</span>
        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mf">2.0</span><span class="p">);</span> <span class="c">//**Changed**//
</span>
        MAKE_PTR<span class="p">(</span>GeneralisedLinearSpringForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_force<span class="p">);</span>
        simulator<span class="p">.</span>AddForce<span class="p">(</span>p_force<span class="p">);</span>

        simulator<span class="p">.</span>Solve<span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> TestMeshBasedMonolayerPeriodic<span class="p">()</span> <span class="k">throw</span> <span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
        CylindricalHoneycombMeshGenerator generator<span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c">//**Changed**//
</span>        Cylindrical2dMesh<span class="o">*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetCylindricalMesh<span class="p">();</span> <span class="c">//**Changed**//
</span>
        std<span class="o">::</span>vector<span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> location_indices <span class="o">=</span> generator<span class="p">.</span>GetCellLocationIndices<span class="p">();</span>
        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        CellsGenerator<span class="o">&lt;</span>StochasticDurationCellCycleModel<span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> cells_generator<span class="p">;</span> <span class="c">//**Changed**//
</span>        cells_generator<span class="p">.</span>GenerateBasicRandom<span class="p">(</span>cells<span class="p">,</span> location_indices<span class="p">.</span>size<span class="p">(),</span> TRANSIT<span class="p">);</span>

        MeshBasedCellPopulationWithGhostNodes<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">,</span> location_indices<span class="p">);</span>

        OffLatticeSimulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> simulator<span class="p">(</span>cell_population<span class="p">);</span>
        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"CellBasedDemo5"</span><span class="p">);</span> <span class="c">//**Changed**//
</span>        simulator<span class="p">.</span>SetSamplingTimestepMultiple<span class="p">(</span><span class="mi">12</span><span class="p">);</span>
        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mf">20.0</span><span class="p">);</span> <span class="c">//**Changed**//
</span>
        MAKE_PTR<span class="p">(</span>GeneralisedLinearSpringForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_force<span class="p">);</span>
        simulator<span class="p">.</span>AddForce<span class="p">(</span>p_force<span class="p">);</span>

        simulator<span class="p">.</span>Solve<span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> TestMeshBasedMonolayerPeriodicSolidBottomBoundary<span class="p">()</span> <span class="k">throw</span> <span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
        CylindricalHoneycombMeshGenerator generator<span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
        Cylindrical2dMesh<span class="o">*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetCylindricalMesh<span class="p">();</span>

        std<span class="o">::</span>vector<span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> location_indices <span class="o">=</span> generator<span class="p">.</span>GetCellLocationIndices<span class="p">();</span>
        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        CellsGenerator<span class="o">&lt;</span>StochasticDurationCellCycleModel<span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> cells_generator<span class="p">;</span>
        cells_generator<span class="p">.</span>GenerateBasicRandom<span class="p">(</span>cells<span class="p">,</span> location_indices<span class="p">.</span>size<span class="p">(),</span> STEM<span class="p">);</span>

        MeshBasedCellPopulationWithGhostNodes<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">,</span> location_indices<span class="p">);</span>

        OffLatticeSimulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> simulator<span class="p">(</span>cell_population<span class="p">);</span>
        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"CellBasedDemo6"</span><span class="p">);</span> <span class="c">//**Changed**//
</span>        simulator<span class="p">.</span>SetSamplingTimestepMultiple<span class="p">(</span><span class="mi">50</span><span class="p">);</span>
        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mf">20.0</span><span class="p">);</span>

        MAKE_PTR<span class="p">(</span>GeneralisedLinearSpringForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_force<span class="p">);</span>
        simulator<span class="p">.</span>AddForce<span class="p">(</span>p_force<span class="p">);</span>

        c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> point <span class="o">=</span> zero_vector<span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> normal <span class="o">=</span> zero_vector<span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        normal<span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">;</span>
        MAKE_PTR_ARGS<span class="p">(</span>PlaneBoundaryCondition<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_bc<span class="p">,</span> <span class="p">(</span><span class="o">&amp;</span>cell_population<span class="p">,</span> point<span class="p">,</span> normal<span class="p">));</span>
        simulator<span class="p">.</span>AddCellPopulationBoundaryCondition<span class="p">(</span>p_bc<span class="p">);</span>

        simulator<span class="p">.</span>Solve<span class="p">();</span>
    <span class="p">}</span>
   <span class="kt">void</span> TestPottsBasedMonolayer<span class="p">()</span> <span class="k">throw</span> <span class="p">(</span>Exception<span class="p">)</span>
   <span class="p">{</span>
       PottsMeshGenerator<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> generator<span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span> <span class="c">//**Changed**//
</span>       PottsMesh<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetMesh<span class="p">();</span> <span class="c">//**Changed**//
</span>
       std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
       CellsGenerator<span class="o">&lt;</span>StochasticDurationCellCycleModel<span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> cells_generator<span class="p">;</span>
       cells_generator<span class="p">.</span>GenerateBasicRandom<span class="p">(</span>cells<span class="p">,</span> p_mesh<span class="o">-&gt;</span>GetNumElements<span class="p">(),</span> TRANSIT<span class="p">);</span>

       PottsBasedCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">);</span><span class="c">//**Changed**//
</span>       cell_population<span class="p">.</span>SetTemperature<span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>

       OnLatticeSimulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> simulator<span class="p">(</span>cell_population<span class="p">);</span><span class="c">//**Changed**//
</span>       simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"CellBasedDemo7"</span><span class="p">);</span> <span class="c">//**Changed**//
</span>       simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mf">20.0</span><span class="p">);</span>

       MAKE_PTR<span class="p">(</span>VolumeConstraintPottsUpdateRule<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_volume_constraint_update_rule<span class="p">);</span> <span class="c">//**Changed**//
</span>       simulator<span class="p">.</span>AddPottsUpdateRule<span class="p">(</span>p_volume_constraint_update_rule<span class="p">);</span> <span class="c">//**Changed**//
</span>       MAKE_PTR<span class="p">(</span>SurfaceAreaConstraintPottsUpdateRule<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_surface_area_update_rule<span class="p">);</span> <span class="c">//**Changed**//
</span>       simulator<span class="p">.</span>AddPottsUpdateRule<span class="p">(</span>p_surface_area_update_rule<span class="p">);</span> <span class="c">//**Changed**//
</span>       MAKE_PTR<span class="p">(</span>AdhesionPottsUpdateRule<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_adhesion_update_rule<span class="p">);</span> <span class="c">//**Changed**//
</span>       simulator<span class="p">.</span>AddPottsUpdateRule<span class="p">(</span>p_adhesion_update_rule<span class="p">);</span> <span class="c">//**Changed**//
</span>
       MAKE_PTR_ARGS<span class="p">(</span>RandomCellKiller<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_cell_killer<span class="p">,</span> <span class="p">(</span><span class="o">&amp;</span>cell_population<span class="p">,</span> <span class="mf">0.01</span><span class="p">));</span>
       simulator<span class="p">.</span>AddCellKiller<span class="p">(</span>p_cell_killer<span class="p">);</span>

       simulator<span class="p">.</span>Solve<span class="p">();</span>
   <span class="p">}</span>
<span class="p">};</span>
</pre></div>
        
        
      </div>

    </div>
  </body>
</html>
