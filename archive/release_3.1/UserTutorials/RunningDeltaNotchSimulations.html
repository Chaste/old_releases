<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>UserTutorials/RunningDeltaNotchSimulations - Chaste</title>
    <link rel="stylesheet" href="https://chaste.github.io/old_releases/trac.css" type="text/css" />
    <link rel="stylesheet" href="https://chaste.github.io/old_releases/wiki.css" type="text/css" />
    <link rel="stylesheet" href="/trac/css/site.css" type="text/css" />
    <style type="text/css">
/* Link styles */
:link, :visited, a em {
 text-decoration: none;
 color: #283f6b;
 border-bottom: 1px dotted #bbb;
}
/*
:link:hover, :visited:hover {
 background-color: #eee;
 color: #555;
}
*/
    </style>

  </head>
  <body>
    <div id="banner">
      <div id="header">
        <p>
          <a id="logo" href="https://chaste.github.io/"><img src="https://chaste.github.io/chaste_0256.png" alt="Chaste logo" height="60" /></a>
          <em>Documentation for <a href="https://chaste.github.io/old_releases/release_3.1/">Release 3.1</a>.</em>
        </p>
      </div>
    </div>
    <p>&nbsp;</p>
    <div id="content" class="wiki">
      <p class="path noprint">
        <a class="pathentry" title="View UserTutorials" href="https://chaste.github.io/old_releases/release_3.1/UserTutorials.html">UserTutorials</a><span class="pathentry sep">/</span><a class="pathentry" title="View UserTutorials/RunningDeltaNotchSimulations" href="https://chaste.github.io/old_releases/release_3.1/UserTutorials/RunningDeltaNotchSimulations.html">RunningDeltaNotchSimulations</a>
        <br style="clear: both" />
      </p>
      <div class="wikipage searchable">
        
          <p>
This tutorial is automatically generated from the file trunk/cell_based/test/tutorial/TestRunningDeltaNotchSimulationsTutorial.hpp at revision <a class="changeset" href="/cgi-bin/trac.cgi/changeset/16454" title=" * #2101 - add tutorial using `NagaiHondaDifferentialAdhesionForce`
 * ...">r16454</a>.
Note that the code is given in full at the bottom of the page.
</p>
<h1 id="AnexampleshowinghowtorunDeltaNotchsimulations">An example showing how to run Delta/Notch simulations</h1>
<h2 id="Introduction">Introduction</h2>
<p>
In this tutorial we show how Chaste can be used to simulate a growing cell monolayer culture
into which a simple model of Delta/Notch signalling is incorporated. This model was developed
by Collier et al. ("Pattern formation by lateral inhibition with feedback: a mathematical
model of delta-notch intercellular signalling", J. Theor. Biol. 183:429-446) and comprises
two ODEs to describe the evolution in concentrations of Delta and Notch in each cell. The ODE
for Notch includes a reaction term that depends on the mean Delta concentration among neighbouring
cells. Thus in this simulation each cell needs to be able to access information about its
neighbours. We use the <tt>CellData</tt> class to facilitate this, and introduce a subclass
of <tt>OffLatticeSimulation</tt> called <tt>DeltaNotchOffLatticeSimulation</tt> to handle the updating
of <tt>CellData</tt> at each time step as cell neighbours change.
</p>
<h2 id="Thetest">The test</h2>
<p>
As in previous tutorials, we begin by including the necessary header files. We have
encountered these files already. Recall that often, either <tt>CheckpointArchiveTypes.hpp</tt>
or <tt>CellBasedSimulationArchiver.hpp</tt> must be included the first Chaste header.
</p>
<div class="code"><pre><span class="cp">#include &lt;cxxtest/TestSuite.h&gt;
#include "CheckpointArchiveTypes.hpp"
#include "AbstractCellBasedTestSuite.hpp"
#include "HoneycombMeshGenerator.hpp"
#include "HoneycombVertexMeshGenerator.hpp"
#include "NodeBasedCellPopulation.hpp"
#include "VertexBasedCellPopulation.hpp"
#include "NagaiHondaForce.hpp"
#include "GeneralisedLinearSpringForce.hpp"
#include "SmartPointers.hpp"
</span></pre></div><p>
The next header file defines a simple stochastic cell-cycle model that includes the functionality
for solving each cell's Delta/Notch signalling ODE system at each time step, using information about neighbouring
cells through the <tt>CellData</tt> class. We note that in this simple cell-cycle model, the
proliferative status of each cell is unaffected by its Delta/Notch activity; such dependence could
easily be introduced given an appropriate model of this coupling.
</p>
<div class="code"><pre><span class="cp">#include "DeltaNotchCellCycleModel.hpp"
</span></pre></div><p>
The next header file defines the class that simulates the evolution of a <tt>CellPopulation</tt>,
specialized to deal with updating of the <tt>CellData</tt> class to deal with Delta-Notch
signalling between cells.
</p>
<div class="code"><pre><span class="cp">#include "DeltaNotchOffLatticeSimulation.hpp"
</span></pre></div><p>
Having included all the necessary header files, we proceed by defining the test class.
</p>
<div class="code"><pre><span class="k">class</span> <span class="nc">TestRunningDeltaNotchSimulationsTutorial</span> <span class="o">:</span> <span class="k">public</span> AbstractCellBasedTestSuite
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
</pre></div><h2 id="Test1:avertex-basedmonolayerwithDeltaNotchsignalling">Test 1: a vertex-based monolayer with Delta/Notch signalling</h2>
<p>
In the first test, we demonstrate how to simulate a monolayer that incorporates
Delta/Notch signalling, using a vertex-based approach.
</p>
<div class="code"><pre>    <span class="kt">void</span> TestVertexBasedMonolayerWithDeltaNotch<span class="p">()</span> <span class="k">throw</span> <span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
</pre></div><p>
First we create a regular vertex mesh.
</p>
<div class="code"><pre>        HoneycombVertexMeshGenerator generator<span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
        MutableVertexMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetMesh<span class="p">();</span>
</pre></div><p>
We then create some cells, each with a cell-cycle model, <tt>DeltaNotchCellCycleModel</tt>, which
incorporates a Delta/Notch ODE system. In this example we choose to make each cell differentiated,
so that no cell division occurs.
</p>
<div class="code"><pre>        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        MAKE_PTR<span class="p">(</span>WildTypeCellMutationState<span class="p">,</span> p_state<span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> elem_index<span class="o">=</span><span class="mi">0</span><span class="p">;</span> elem_index<span class="o">&lt;</span>p_mesh<span class="o">-&gt;</span>GetNumElements<span class="p">();</span> elem_index<span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            DeltaNotchCellCycleModel<span class="o">*</span> p_model <span class="o">=</span> <span class="k">new</span> DeltaNotchCellCycleModel<span class="p">();</span>
            p_model<span class="o">-&gt;</span>SetDimension<span class="p">(</span><span class="mi">2</span><span class="p">);</span>

            CellPtr p_cell<span class="p">(</span><span class="k">new</span> Cell<span class="p">(</span>p_state<span class="p">,</span> p_model<span class="p">));</span>
            p_cell<span class="o">-&gt;</span>SetCellProliferativeType<span class="p">(</span>DIFFERENTIATED<span class="p">);</span>
            <span class="kt">double</span> birth_time <span class="o">=</span> <span class="o">-</span>RandomNumberGenerator<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>ranf<span class="p">()</span><span class="o">*</span><span class="mf">12.0</span><span class="p">;</span>
            p_cell<span class="o">-&gt;</span>SetBirthTime<span class="p">(</span>birth_time<span class="p">);</span>
            cells<span class="p">.</span>push_back<span class="p">(</span>p_cell<span class="p">);</span>
        <span class="p">}</span>
</pre></div><p>
Using the vertex mesh and cells, we create a cell-based population object, and specify which results to
output to file.
</p>
<div class="code"><pre>        VertexBasedCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">);</span>
        cell_population<span class="p">.</span>SetOutputCellMutationStates<span class="p">(</span><span class="kc">true</span><span class="p">);</span>
        cell_population<span class="p">.</span>SetOutputCellProliferativeTypes<span class="p">(</span><span class="kc">true</span><span class="p">);</span>
        cell_population<span class="p">.</span>SetOutputCellCyclePhases<span class="p">(</span><span class="kc">true</span><span class="p">);</span>
        cell_population<span class="p">.</span>SetOutputCellAges<span class="p">(</span><span class="kc">true</span><span class="p">);</span>
        cell_population<span class="p">.</span>SetOutputCellVolumes<span class="p">(</span><span class="kc">true</span><span class="p">);</span>
        cell_population<span class="p">.</span>SetOutputCellVariables<span class="p">(</span><span class="kc">true</span><span class="p">);</span>
</pre></div><p>
As we are using the <tt>CellData</tt> class to store the information about each cell required to
solve the Delta/Notch ODE system, we must first instantiate this singleton and associate it with the
cell population. Note that we set the number of variables to 3. This is because each cell's ODE system
comprises two ODEs describing Delta/Notch activity, and an additional 'dummy' ODE with zero reaction term
that describes how the mean concentration of Delta among neighbouring cells changes. This latter quantity
remains constant for the purposes of solving the ODE system over each time step, but is updated at the
end of the time step by a method on <tt>DeltaNotchOffLatticeSimulation</tt>.
</p>
<p>
We choose to initialise the concentrations to random levels in each cell.
</p>
<div class="code"><pre>        <span class="k">for</span> <span class="p">(</span>AbstractCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>Iterator cell_iter <span class="o">=</span> cell_population<span class="p">.</span>Begin<span class="p">();</span>
             cell_iter <span class="o">!=</span> cell_population<span class="p">.</span>End<span class="p">();</span>
             <span class="o">++</span>cell_iter<span class="p">)</span>
        <span class="p">{</span>
            cell_iter<span class="o">-&gt;</span>GetCellData<span class="p">()</span><span class="o">-&gt;</span>SetItem<span class="p">(</span><span class="s">"notch"</span><span class="p">,</span> RandomNumberGenerator<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>ranf<span class="p">());</span>
            cell_iter<span class="o">-&gt;</span>GetCellData<span class="p">()</span><span class="o">-&gt;</span>SetItem<span class="p">(</span><span class="s">"delta"</span><span class="p">,</span> RandomNumberGenerator<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>ranf<span class="p">());</span>
            cell_iter<span class="o">-&gt;</span>GetCellData<span class="p">()</span><span class="o">-&gt;</span>SetItem<span class="p">(</span><span class="s">"mean delta"</span><span class="p">,</span> RandomNumberGenerator<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>ranf<span class="p">());</span>
        <span class="p">}</span>
</pre></div><p>
We are now in a position to create and configure the cell-based simulation object, pass a force law to it,
and run the simulation. We can make the simulation run for longer to see more patterning by increasing the end time.
</p>
<div class="code"><pre>        DeltaNotchOffLatticeSimulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> simulator<span class="p">(</span>cell_population<span class="p">);</span>
        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"TestVertexBasedMonolayerWithDeltaNotch"</span><span class="p">);</span>
        simulator<span class="p">.</span>SetSamplingTimestepMultiple<span class="p">(</span><span class="mi">10</span><span class="p">);</span>
        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>

        MAKE_PTR<span class="p">(</span>NagaiHondaForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_force<span class="p">);</span>
        simulator<span class="p">.</span>AddForce<span class="p">(</span>p_force<span class="p">);</span>

        simulator<span class="p">.</span>Solve<span class="p">();</span>
    <span class="p">}</span>
</pre></div><p>
To visualize the results, use Paraview. See the <a class="wiki" href="https://chaste.github.io/old_releases/release_3.1/UserTutorials/VisualizingWithParaview.html">UserTutorials/VisualizingWithParaview</a> tutorial for more information.
</p>
<p>
Load the file <tt>/tmp/$USER/testoutput/TestVertexBasedMonolayerWithDeltaNotch/results_from_time_0/results.pvd</tt>.
</p>
<h2 id="Test2-anode-basedmonolayerwithDeltaNotchsignalling">Test 2 - a node-based monolayer with Delta/Notch signalling</h2>
<p>
In the next test we run a similar simulation as before, but this time with node-based
'overlapping spheres' model.
</p>
<div class="code"><pre>    <span class="kt">void</span> TestNodeBasedMonolayerWithDeltaNotch<span class="p">()</span> <span class="k">throw</span> <span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
</pre></div><p>
Most of the code in this test is the same as in the previous test,
except we now create a 'nodes-only mesh' and <tt>NodeBasedCellPopulation</tt>.
</p>
<div class="code"><pre>        HoneycombMeshGenerator generator<span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
        MutableMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> p_generating_mesh <span class="o">=</span> generator<span class="p">.</span>GetMesh<span class="p">();</span>
        NodesOnlyMesh<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;*</span> p_mesh <span class="o">=</span> <span class="k">new</span> NodesOnlyMesh<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">;</span>
        p_mesh<span class="o">-&gt;</span>ConstructNodesWithoutMesh<span class="p">(</span><span class="o">*</span>p_generating_mesh<span class="p">);</span>

        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        MAKE_PTR<span class="p">(</span>WildTypeCellMutationState<span class="p">,</span> p_state<span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> i<span class="o">=</span><span class="mi">0</span><span class="p">;</span> i<span class="o">&lt;</span>p_mesh<span class="o">-&gt;</span>GetNumNodes<span class="p">();</span> i<span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            DeltaNotchCellCycleModel<span class="o">*</span> p_model <span class="o">=</span> <span class="k">new</span> DeltaNotchCellCycleModel<span class="p">();</span>
            p_model<span class="o">-&gt;</span>SetDimension<span class="p">(</span><span class="mi">2</span><span class="p">);</span>

            CellPtr p_cell<span class="p">(</span><span class="k">new</span> Cell<span class="p">(</span>p_state<span class="p">,</span> p_model<span class="p">));</span>
            p_cell<span class="o">-&gt;</span>SetCellProliferativeType<span class="p">(</span>DIFFERENTIATED<span class="p">);</span>
            <span class="kt">double</span> birth_time <span class="o">=</span> <span class="o">-</span>RandomNumberGenerator<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>ranf<span class="p">()</span><span class="o">*</span><span class="mf">12.0</span><span class="p">;</span>
            p_cell<span class="o">-&gt;</span>SetBirthTime<span class="p">(</span>birth_time<span class="p">);</span>
            cells<span class="p">.</span>push_back<span class="p">(</span>p_cell<span class="p">);</span>
        <span class="p">}</span>

        NodeBasedCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">);</span>
</pre></div><p>
The mechanics cut-off length is also used in this simulation to determine nearest
neighbours for the purpose of the Delta/Notch intercellular signalling model.
</p>
<div class="code"><pre>        cell_population<span class="p">.</span>SetMechanicsCutOffLength<span class="p">(</span><span class="mf">1.5</span><span class="p">);</span>

        cell_population<span class="p">.</span>SetOutputCellProliferativeTypes<span class="p">(</span><span class="kc">true</span><span class="p">);</span>
        cell_population<span class="p">.</span>SetOutputCellMutationStates<span class="p">(</span><span class="kc">true</span><span class="p">);</span>
        cell_population<span class="p">.</span>SetOutputCellIdData<span class="p">(</span><span class="kc">true</span><span class="p">);</span>
        cell_population<span class="p">.</span>SetOutputCellCyclePhases<span class="p">(</span><span class="kc">true</span><span class="p">);</span>
        cell_population<span class="p">.</span>SetOutputCellAges<span class="p">(</span><span class="kc">true</span><span class="p">);</span>
</pre></div><p>
We choose to initialise the concentrations to random levels in each cell.
</p>
<div class="code"><pre>        <span class="k">for</span> <span class="p">(</span>AbstractCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>Iterator cell_iter <span class="o">=</span> cell_population<span class="p">.</span>Begin<span class="p">();</span>
             cell_iter <span class="o">!=</span> cell_population<span class="p">.</span>End<span class="p">();</span>
             <span class="o">++</span>cell_iter<span class="p">)</span>
        <span class="p">{</span>
            cell_iter<span class="o">-&gt;</span>GetCellData<span class="p">()</span><span class="o">-&gt;</span>SetItem<span class="p">(</span><span class="s">"notch"</span><span class="p">,</span> RandomNumberGenerator<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>ranf<span class="p">());</span>
            cell_iter<span class="o">-&gt;</span>GetCellData<span class="p">()</span><span class="o">-&gt;</span>SetItem<span class="p">(</span><span class="s">"delta"</span><span class="p">,</span> RandomNumberGenerator<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>ranf<span class="p">());</span>
            cell_iter<span class="o">-&gt;</span>GetCellData<span class="p">()</span><span class="o">-&gt;</span>SetItem<span class="p">(</span><span class="s">"mean delta"</span><span class="p">,</span> RandomNumberGenerator<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>ranf<span class="p">());</span>
        <span class="p">}</span>

        DeltaNotchOffLatticeSimulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> simulator<span class="p">(</span>cell_population<span class="p">);</span>
        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"TestNodeBasedMonolayerWithDeltaNotch"</span><span class="p">);</span>
        simulator<span class="p">.</span>SetSamplingTimestepMultiple<span class="p">(</span><span class="mi">10</span><span class="p">);</span>
        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mf">5.0</span><span class="p">);</span>
</pre></div><p>
As we are using a node-based cell population, we use an appropriate force law.
</p>
<div class="code"><pre>        MAKE_PTR<span class="p">(</span>GeneralisedLinearSpringForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_force<span class="p">);</span>
        p_force<span class="o">-&gt;</span>SetCutOffLength<span class="p">(</span><span class="mf">1.5</span><span class="p">);</span>
        simulator<span class="p">.</span>AddForce<span class="p">(</span>p_force<span class="p">);</span>

        simulator<span class="p">.</span>Solve<span class="p">();</span>
</pre></div><p>
To avoid memory leaks, we also delete any pointers we created in the test.
</p>
<div class="code"><pre>        <span class="k">delete</span> p_mesh<span class="p">;</span>
    <span class="p">}</span>
</pre></div><p>
To visualize the results, use Paraview. See the <a class="wiki" href="https://chaste.github.io/old_releases/release_3.1/UserTutorials/VisualizingWithParaview.html">UserTutorials/VisualizingWithParaview</a> tutorial for more information
</p>
<p>
Load the file <tt>/tmp/$USER/testoutput/TestNodeBasedMonolayerWithDeltaNotch/results_from_time_0/results.pvd</tt>,
add a spherical glyph.
</p>
<div class="code"><pre><span class="p">};</span>
</pre></div><h1 id="Code">Code</h1>
<p>
The full code is given below
</p>
<h2 id="FilenameTestRunningDeltaNotchSimulationsTutorial.hpp">File name <tt>TestRunningDeltaNotchSimulationsTutorial.hpp</tt></h2>
<div class="code"><pre><span class="cp">#include &lt;cxxtest/TestSuite.h&gt;
#include "CheckpointArchiveTypes.hpp"
#include "AbstractCellBasedTestSuite.hpp"
#include "HoneycombMeshGenerator.hpp"
#include "HoneycombVertexMeshGenerator.hpp"
#include "NodeBasedCellPopulation.hpp"
#include "VertexBasedCellPopulation.hpp"
#include "NagaiHondaForce.hpp"
#include "GeneralisedLinearSpringForce.hpp"
#include "SmartPointers.hpp"
#include "DeltaNotchCellCycleModel.hpp"
#include "DeltaNotchOffLatticeSimulation.hpp"
</span>
<span class="k">class</span> <span class="nc">TestRunningDeltaNotchSimulationsTutorial</span> <span class="o">:</span> <span class="k">public</span> AbstractCellBasedTestSuite
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

    <span class="kt">void</span> TestVertexBasedMonolayerWithDeltaNotch<span class="p">()</span> <span class="k">throw</span> <span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
        HoneycombVertexMeshGenerator generator<span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
        MutableVertexMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetMesh<span class="p">();</span>

        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        MAKE_PTR<span class="p">(</span>WildTypeCellMutationState<span class="p">,</span> p_state<span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> elem_index<span class="o">=</span><span class="mi">0</span><span class="p">;</span> elem_index<span class="o">&lt;</span>p_mesh<span class="o">-&gt;</span>GetNumElements<span class="p">();</span> elem_index<span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            DeltaNotchCellCycleModel<span class="o">*</span> p_model <span class="o">=</span> <span class="k">new</span> DeltaNotchCellCycleModel<span class="p">();</span>
            p_model<span class="o">-&gt;</span>SetDimension<span class="p">(</span><span class="mi">2</span><span class="p">);</span>

            CellPtr p_cell<span class="p">(</span><span class="k">new</span> Cell<span class="p">(</span>p_state<span class="p">,</span> p_model<span class="p">));</span>
            p_cell<span class="o">-&gt;</span>SetCellProliferativeType<span class="p">(</span>DIFFERENTIATED<span class="p">);</span>
            <span class="kt">double</span> birth_time <span class="o">=</span> <span class="o">-</span>RandomNumberGenerator<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>ranf<span class="p">()</span><span class="o">*</span><span class="mf">12.0</span><span class="p">;</span>
            p_cell<span class="o">-&gt;</span>SetBirthTime<span class="p">(</span>birth_time<span class="p">);</span>
            cells<span class="p">.</span>push_back<span class="p">(</span>p_cell<span class="p">);</span>
        <span class="p">}</span>

        VertexBasedCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">);</span>
        cell_population<span class="p">.</span>SetOutputCellMutationStates<span class="p">(</span><span class="kc">true</span><span class="p">);</span>
        cell_population<span class="p">.</span>SetOutputCellProliferativeTypes<span class="p">(</span><span class="kc">true</span><span class="p">);</span>
        cell_population<span class="p">.</span>SetOutputCellCyclePhases<span class="p">(</span><span class="kc">true</span><span class="p">);</span>
        cell_population<span class="p">.</span>SetOutputCellAges<span class="p">(</span><span class="kc">true</span><span class="p">);</span>
        cell_population<span class="p">.</span>SetOutputCellVolumes<span class="p">(</span><span class="kc">true</span><span class="p">);</span>
        cell_population<span class="p">.</span>SetOutputCellVariables<span class="p">(</span><span class="kc">true</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span>AbstractCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>Iterator cell_iter <span class="o">=</span> cell_population<span class="p">.</span>Begin<span class="p">();</span>
             cell_iter <span class="o">!=</span> cell_population<span class="p">.</span>End<span class="p">();</span>
             <span class="o">++</span>cell_iter<span class="p">)</span>
        <span class="p">{</span>
            cell_iter<span class="o">-&gt;</span>GetCellData<span class="p">()</span><span class="o">-&gt;</span>SetItem<span class="p">(</span><span class="s">"notch"</span><span class="p">,</span> RandomNumberGenerator<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>ranf<span class="p">());</span>
            cell_iter<span class="o">-&gt;</span>GetCellData<span class="p">()</span><span class="o">-&gt;</span>SetItem<span class="p">(</span><span class="s">"delta"</span><span class="p">,</span> RandomNumberGenerator<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>ranf<span class="p">());</span>
            cell_iter<span class="o">-&gt;</span>GetCellData<span class="p">()</span><span class="o">-&gt;</span>SetItem<span class="p">(</span><span class="s">"mean delta"</span><span class="p">,</span> RandomNumberGenerator<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>ranf<span class="p">());</span>
        <span class="p">}</span>

        DeltaNotchOffLatticeSimulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> simulator<span class="p">(</span>cell_population<span class="p">);</span>
        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"TestVertexBasedMonolayerWithDeltaNotch"</span><span class="p">);</span>
        simulator<span class="p">.</span>SetSamplingTimestepMultiple<span class="p">(</span><span class="mi">10</span><span class="p">);</span>
        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>

        MAKE_PTR<span class="p">(</span>NagaiHondaForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_force<span class="p">);</span>
        simulator<span class="p">.</span>AddForce<span class="p">(</span>p_force<span class="p">);</span>

        simulator<span class="p">.</span>Solve<span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> TestNodeBasedMonolayerWithDeltaNotch<span class="p">()</span> <span class="k">throw</span> <span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
        HoneycombMeshGenerator generator<span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
        MutableMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> p_generating_mesh <span class="o">=</span> generator<span class="p">.</span>GetMesh<span class="p">();</span>
        NodesOnlyMesh<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;*</span> p_mesh <span class="o">=</span> <span class="k">new</span> NodesOnlyMesh<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">;</span>
        p_mesh<span class="o">-&gt;</span>ConstructNodesWithoutMesh<span class="p">(</span><span class="o">*</span>p_generating_mesh<span class="p">);</span>

        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        MAKE_PTR<span class="p">(</span>WildTypeCellMutationState<span class="p">,</span> p_state<span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> i<span class="o">=</span><span class="mi">0</span><span class="p">;</span> i<span class="o">&lt;</span>p_mesh<span class="o">-&gt;</span>GetNumNodes<span class="p">();</span> i<span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            DeltaNotchCellCycleModel<span class="o">*</span> p_model <span class="o">=</span> <span class="k">new</span> DeltaNotchCellCycleModel<span class="p">();</span>
            p_model<span class="o">-&gt;</span>SetDimension<span class="p">(</span><span class="mi">2</span><span class="p">);</span>

            CellPtr p_cell<span class="p">(</span><span class="k">new</span> Cell<span class="p">(</span>p_state<span class="p">,</span> p_model<span class="p">));</span>
            p_cell<span class="o">-&gt;</span>SetCellProliferativeType<span class="p">(</span>DIFFERENTIATED<span class="p">);</span>
            <span class="kt">double</span> birth_time <span class="o">=</span> <span class="o">-</span>RandomNumberGenerator<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>ranf<span class="p">()</span><span class="o">*</span><span class="mf">12.0</span><span class="p">;</span>
            p_cell<span class="o">-&gt;</span>SetBirthTime<span class="p">(</span>birth_time<span class="p">);</span>
            cells<span class="p">.</span>push_back<span class="p">(</span>p_cell<span class="p">);</span>
        <span class="p">}</span>

        NodeBasedCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">);</span>
        cell_population<span class="p">.</span>SetMechanicsCutOffLength<span class="p">(</span><span class="mf">1.5</span><span class="p">);</span>

        cell_population<span class="p">.</span>SetOutputCellProliferativeTypes<span class="p">(</span><span class="kc">true</span><span class="p">);</span>
        cell_population<span class="p">.</span>SetOutputCellMutationStates<span class="p">(</span><span class="kc">true</span><span class="p">);</span>
        cell_population<span class="p">.</span>SetOutputCellIdData<span class="p">(</span><span class="kc">true</span><span class="p">);</span>
        cell_population<span class="p">.</span>SetOutputCellCyclePhases<span class="p">(</span><span class="kc">true</span><span class="p">);</span>
        cell_population<span class="p">.</span>SetOutputCellAges<span class="p">(</span><span class="kc">true</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span>AbstractCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>Iterator cell_iter <span class="o">=</span> cell_population<span class="p">.</span>Begin<span class="p">();</span>
             cell_iter <span class="o">!=</span> cell_population<span class="p">.</span>End<span class="p">();</span>
             <span class="o">++</span>cell_iter<span class="p">)</span>
        <span class="p">{</span>
            cell_iter<span class="o">-&gt;</span>GetCellData<span class="p">()</span><span class="o">-&gt;</span>SetItem<span class="p">(</span><span class="s">"notch"</span><span class="p">,</span> RandomNumberGenerator<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>ranf<span class="p">());</span>
            cell_iter<span class="o">-&gt;</span>GetCellData<span class="p">()</span><span class="o">-&gt;</span>SetItem<span class="p">(</span><span class="s">"delta"</span><span class="p">,</span> RandomNumberGenerator<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>ranf<span class="p">());</span>
            cell_iter<span class="o">-&gt;</span>GetCellData<span class="p">()</span><span class="o">-&gt;</span>SetItem<span class="p">(</span><span class="s">"mean delta"</span><span class="p">,</span> RandomNumberGenerator<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>ranf<span class="p">());</span>
        <span class="p">}</span>

        DeltaNotchOffLatticeSimulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> simulator<span class="p">(</span>cell_population<span class="p">);</span>
        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"TestNodeBasedMonolayerWithDeltaNotch"</span><span class="p">);</span>
        simulator<span class="p">.</span>SetSamplingTimestepMultiple<span class="p">(</span><span class="mi">10</span><span class="p">);</span>
        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mf">5.0</span><span class="p">);</span>

        MAKE_PTR<span class="p">(</span>GeneralisedLinearSpringForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_force<span class="p">);</span>
        p_force<span class="o">-&gt;</span>SetCutOffLength<span class="p">(</span><span class="mf">1.5</span><span class="p">);</span>
        simulator<span class="p">.</span>AddForce<span class="p">(</span>p_force<span class="p">);</span>

        simulator<span class="p">.</span>Solve<span class="p">();</span>

        <span class="k">delete</span> p_mesh<span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
        
        
      </div>

    </div>
  </body>
</html>
