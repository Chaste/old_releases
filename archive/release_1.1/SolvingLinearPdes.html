<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
 <title>Chaste User Tutorial</title>
 <link rel="stylesheet" href="/trac/css/trac.css" type="text/css" />
 <link rel="stylesheet" href="/trac/css/wiki.css" type="text/css" />


 <style type="text/css">
/* Link styles */
:link, :visited, a em {
 text-decoration: none;
 color: #283f6b;
 border-bottom: 1px dotted #bbb;
}
/*
:link:hover, :visited:hover {
 background-color: #eee;
 color: #555;
}
*/
</style>

</head>
<body>
<a id="logo" href="http://www.comlab.ox.ac.uk/chaste">
  <img src="/logos/chaste-266x60.jpg" alt="Chaste logo" />
</a>
<h1> SolvingLinearPdes tutorial file </h1>      </div>
    <div id="content" class="wiki">
      <p class="path noprint">
        <a class="pathentry" title="View UserTutorials" href="/cgi-bin/trac.cgi/wiki/UserTutorials">UserTutorials</a><span class="pathentry sep">/</span><a class="pathentry" title="View UserTutorials/SolvingLinearPdes" href="/cgi-bin/trac.cgi/wiki/UserTutorials/SolvingLinearPdes">SolvingLinearPdes</a>
        <br style="clear: both" />
      </p>
      <div class="wikipage searchable">
        
          <p>
This tutorial is automatically generated from the file trunk/pde/test/TestSolvingLinearPdesTutorial.hpp at revision <a class="missing changeset">r6538</a>.
Note that the code is given in full at the bottom of the page.
</p>
<h1 id="ExamplesshowinghowtosolvelinearellipticandparabolicPDEs">Examples showing how to solve linear elliptic and parabolic PDEs</h1>
<p>
In this tutorial we show how Chaste can be used to solve linear PDEs. The first test
uses the <tt>SimpleLinearEllipticAssembler</tt> to solve a linear elliptic PDE, and the
second test uses the <tt>SimpleDg0ParabolicAssembler</tt> to solve a parabolic time-dependent
linear PDE
</p>
<p>
The following header files need to be included.
First we include the header needed to define this class as a test suite 
</p>
<div class="code"><pre>#include &lt;cxxtest/TestSuite.h&gt;
</pre></div><p>
On some systems there is a clash between Boost Ublas includes and PETSc.  This can be
resolved by making sure that Chaste's interface to the Boost libraries are included
as early as possible.
</p>
<div class="code"><pre>#include "UblasCustomFunctions.hpp"
</pre></div><p>
This is the class that is needed to solve a linear elliptic pde 
</p>
<div class="code"><pre>#include "SimpleLinearEllipticAssembler.hpp"
</pre></div><p>
This is the class that is needed to solve a linear parabolic PDE 
</p>
<div class="code"><pre>#include "SimpleDg0ParabolicAssembler.hpp"
</pre></div><p>
This is a parabolic PDE, one of the PDEs we will solve 
</p>
<div class="code"><pre>#include "HeatEquationWithSourceTerm.hpp"
</pre></div><p>
We will also solve this PDE 
</p>
<div class="code"><pre>#include "SimplePoissonEquation.hpp"
</pre></div><p>
This is needed to read mesh datafiles of the 'Triangles' format 
</p>
<div class="code"><pre>#include "TrianglesMeshReader.hpp"
</pre></div><p>
This class represents the mesh internally 
</p>
<div class="code"><pre>#include "TetrahedralMesh.hpp"
</pre></div><p>
These are used to specify boundary conditions for the PDEs 
</p>
<div class="code"><pre>#include "BoundaryConditionsContainer.hpp"
#include "ConstBoundaryCondition.hpp"
</pre></div><p>
This class helps us deal with output files 
</p>
<div class="code"><pre>#include "OutputFileHandler.hpp"
</pre></div><p>
PetscSetupAndFinalize.hpp must be included in every test that uses PETSc. Note that it
cannot be included in the source code. 
</p>
<div class="code"><pre>#include "PetscSetupAndFinalize.hpp"
</pre></div><h2 id="Test1:SolvingalinearellipticPDE">Test 1: Solving a linear elliptic PDE</h2>
<p>
Here, we solve the PDE: div(D grad u) + u = x<sup>2</sup>+y<sup>2</sup>, in 2D, where
D is the diffusion tensor (1 1; 0 1) (ie D11=D12=D22=1, D21=0), on a square
domain, with boundary conditions u=0 on x=0 or y=0, and (D grad u).n = 0 on x=1 and y=1,
where n is the surface normal.
</p>
<p>
We need to create a class representing the PDE we want to solve, which will be
passed into the solver. The PDE we are solving is of the type
<tt>AbstractLinearEllipticPde</tt>, which is an abstract class with 3 pure methods
which have to implemented. The template variables in the following line are both the dimension
of the space.
</p>
<div class="code"><pre>class MyPde : public AbstractLinearEllipticPde&lt;2,2&gt;
{
private:
</pre></div><p>
For efficiency, we will save the diffusion tensor that will be returned by one of the
class' methods as a member variable. The diffusion tensor which has to be returned
by the <tt>GetDiffusionTensor</tt> method in PDE classes is of the type
<tt>c_matrix&lt;double,SIZE,SIZE&gt;</tt>, which is a u-blas matrix. We use ublas vectors
and matrices where small vectors and matrices are needed. Note that ublas objects
are only particularly efficient if optimisation is on (<tt>scons build=GccOpt ..</tt>).
</p>
<div class="code"><pre>    c_matrix&lt;double,2,2&gt; mDiffusionTensor;
public:
</pre></div><p>
The constructor just sets up the diffusion tensor. 
</p>
<div class="code"><pre>    MyPde()
    {
        mDiffusionTensor(0,0) = 1.0;
        mDiffusionTensor(0,1) = 1.0;
        mDiffusionTensor(1,0) = 0.0;
        mDiffusionTensor(1,1) = 1.0;
    }
</pre></div><p>
The first method which has to be implemented returns the constant
(not dependent on u) part of the source term, which for our PDE is
x<sup>2</sup> + y<sup>2</sup> 
</p>
<div class="code"><pre>    double ComputeConstantInUSourceTerm(const ChastePoint&lt;2&gt;&amp; rX)
    {
        return rX[0]*rX[0] + rX[1]*rX[1];
    }
</pre></div><p>
The second method which has to be implemented returns the coefficient in the linear-in-u
part of the source term, which for our PDE is just 1.0 
</p>
<div class="code"><pre>    double ComputeLinearInUCoeffInSourceTerm(const ChastePoint&lt;2&gt;&amp; rX, Element&lt;2,2&gt;* pElement)
    {
        return 1.0;
    }
</pre></div><p>
The third method returns the diffusion tensor D 
</p>
<div class="code"><pre>    c_matrix&lt;double,2,2&gt; ComputeDiffusionTerm(const ChastePoint&lt;2&gt;&amp; rX)
    {
        return mDiffusionTensor;
    }
};
</pre></div><p>
Next, we define the test suite (a class). It is sensible to name it the same
as the filename. The class should inherit from <tt>CxxTest::TestSuite</tt> 
</p>
<div class="code"><pre>class TestSolvingLinearPdesTutorial : public CxxTest::TestSuite
{
</pre></div><p>
All individual test defined in this test suite <strong>must</strong> be declared as public 
</p>
<div class="code"><pre>public:
</pre></div><p>
Define a particular test 
</p>
<div class="code"><pre>    void TestSolvingEllipticPde()
    {
</pre></div><p>
First we declare a mesh reader which reads mesh data files of the 'Triangle'
format. The path given is the relative to the main Chaste directory. The reader
will look for three datafiles, [name].nodes, [name].ele and (in 2d or 3d)
[name].edge. Note that the first template argument here is the dimension of the
elements in the mesh (<tt>ELEM_DIM</tt>), and the second is the dimension of the nodes,
i.e. the dimension of the space the mesh lives in (<tt>SPACE_DIM</tt>). Usually
<tt>ELEM_DIM</tt> and <tt>SPACE_DIM</tt> will be equal. 
</p>
<div class="code"><pre>        TrianglesMeshReader&lt;2,2&gt; mesh_reader("mesh/test/data/square_128_elements");
</pre></div><p>
Now declare a tetrahedral mesh with the same dimensions 
</p>
<div class="code"><pre>        TetrahedralMesh&lt;2,2&gt; mesh;
</pre></div><p>
Construct the mesh using the mesh reader 
</p>
<div class="code"><pre>        mesh.ConstructFromMeshReader(mesh_reader);
</pre></div><p>
Next we instantiate an instance of our PDE we which to solve 
</p>
<div class="code"><pre>        MyPde pde;
</pre></div><p>
A set of boundary conditions are stored in a <tt>BoundaryConditionsContainer</tt>. The
three template arguments are ELEM_DIM, SPACE_DIM and PROBLEM_DIM, the latter being
the number of unknowns we are solving for. We have one unknown (ie u is a scalar, not
a vector), so in this case <tt>PROBLEM_DIM</tt>=1. 
</p>
<div class="code"><pre>        BoundaryConditionsContainer&lt;2,2,1&gt; bcc;
</pre></div><p>
Defining the boundary conditions is the only particularly fiddly part of solving PDEs,
unless they are very simple, such as u=0 on the boundary, which could be done
as follows 
</p>
<div class="code"><pre>        //bcc.DefineZeroDirichletOnMeshBoundary(&amp;mesh);
</pre></div><p>
We want to specify u=0 on x=0 and y=0. To do this, get a boundary node iterator
from the mesh 
</p>
<div class="code"><pre>        TetrahedralMesh&lt;2,2&gt;::BoundaryNodeIterator iter
           = mesh.GetBoundaryNodeIteratorBegin();
</pre></div><p>
Then loop over the boundary nodes, getting the x and y value 
</p>
<div class="code"><pre>        while (iter &lt; mesh.GetBoundaryNodeIteratorEnd())
        {
            double x = (*iter)-&gt;GetPoint()[0];
            double y = (*iter)-&gt;GetPoint()[1];
</pre></div><p>
if x=0 or y=0.. 
</p>
<div class="code"><pre>            if ((x==0) || (y==0))
            {
</pre></div><p>
..create a new <tt>ConstBoundaryConditions</tt> object. This is a subclass of
<tt>AbstractBoundaryCondition</tt>, and tells the caller what value to return
given a particular point in space. In the first line below we say that value
should be 0.0. The second line tells the <tt>BoundaryConditionsContainer</tt>
object that it should associate this boundary condition with this node
(<tt>*iter</tt> being a pointer to a <tt>Node&lt;2&gt;</tt>).
</p>
<div class="code"><pre>                ConstBoundaryCondition&lt;2&gt; *p_dirichlet_boundary_condition = new ConstBoundaryCondition&lt;2&gt;(0.0);
                bcc.AddDirichletBoundaryCondition(*iter, p_dirichlet_boundary_condition);
            }
            iter++;
        }
</pre></div><p>
Now we create Neumann boundary conditions for the <i>surface elements</i> on x=1 and y=1. Note that
Dirichlet boundary conditions are defined on nodes, whereas Neumann boundary conditions are
defined on surface elements. Note also that the natural boundary condition statement for this
PDE is (D grad u).n = g(x) (where n is the outward-facing surface normal), and g(x) is a prescribed
function, <i>not</i> something like du/dn=g(x). Hence the boundary condition we are specifying is
(D grad u).n = 0.
</p>
<p>
<strong>Important note for 1D:</strong> This means that if we were solving 2u<sub>xx</sub>=f(x) in 1D, and
wanted to specify du/dx=1 on the LHS boundary, the Neumann boundary value we have to specify is
-2, as n=-1 (outward facing normal) so (D gradu).n = -2 when du/dx=1.
</p>
<p>
To define Neumann bcs, we define another constant boundary condition object (created using
<tt>new</tt> - note that the <tt>BoundaryConditionsContainer</tt> object deals with deleting
its <tt>AbstractBoundaryCondition</tt> objects), and then loop over surface elements, using the
iterator provided by the mesh class.
</p>
<div class="code"><pre>        ConstBoundaryCondition&lt;2&gt; *p_neumann_boundary_condition = new ConstBoundaryCondition&lt;2&gt;(0.0);
        TetrahedralMesh&lt;2,2&gt;::BoundaryElementIterator surf_iter
          = mesh.GetBoundaryElementIteratorBegin();
        while (surf_iter &lt; mesh.GetBoundaryElementIteratorEnd())
        {
</pre></div><p>
Get the x and y values of any node (here, the 0th) in the element 
</p>
<div class="code"><pre>            unsigned node_index = (*surf_iter)-&gt;GetNodeGlobalIndex(0);
            double x = mesh.GetNode(node_index)-&gt;GetPoint()[0];
            double y = mesh.GetNode(node_index)-&gt;GetPoint()[1];
</pre></div><p>
if x=1 or y=1.. 
</p>
<div class="code"><pre>            if ( (fabs(x-1.0) &lt; 1e-6) || (fabs(y-1.0) &lt; 1e-6) )
            {
</pre></div><p>
associate the boundary condition with the surface element 
</p>
<div class="code"><pre>                bcc.AddNeumannBoundaryCondition(*surf_iter, p_neumann_boundary_condition);
            }
</pre></div><p>
and increment the iterator 
</p>
<div class="code"><pre>            surf_iter++;
        }
</pre></div><p>
Next we define the assembler - the solver of the PDE. (Assembler is a bit of a
misnomer - assemblers both assemble the finite element equations, and solve them.
To solve <tt>AbstractLinearEllipticPde</tt> (which is the type of pde <tt>MyPde</tt> is),
we use a <tt>SimpleLinearEllipticAssembler</tt>. The assembler, again templated over
<tt>ELEM_DIM</tt> and <tt>SPACE_DIM</tt>, needs to be given (pointers to) the mesh,
pde and boundary conditions.
</p>
<div class="code"><pre>        SimpleLinearEllipticAssembler&lt;2,2&gt; assembler(&amp;mesh,&amp;pde,&amp;bcc);
</pre></div><p>
To solve, just call <tt>Solve()</tt>. A Petsc vector is returned. 
</p>
<div class="code"><pre>        Vec result = assembler.Solve();
</pre></div><p>
It is a pain to access the individual components of a Petsc vector, even in
sequential. A helper class called <tt>ReplicatableVector</tt> has been created. Create
an instance of one of these, using the Petsc <tt>Vec</tt> as the data. The ith
component of <tt>result</tt> can now be obtained by simply doing <tt>result_repl[i]</tt>.
</p>
<div class="code"><pre>        ReplicatableVector result_repl(result);
</pre></div><p>
Let us write out the solution to a file. To do this, create an
<tt>OutputFileHandler</tt>, passing in the directory we want files written to.
This is relative to the directory defined by the CHASTE_TEST_OUTPUT environment
variable - usually /tmp/chaste/testoutput. Note by default the output directory
passed in is cleaned. To avoid this, <tt>false</tt> can be passed in as a second
parameter
</p>
<div class="code"><pre>        OutputFileHandler output_file_handler("TestSolvingLinearPdeTutorial");
</pre></div><p>
Create an <tt>out_stream</tt>, which is a stream to a particular file. An <tt>out_stream</tt>
is a pointer to a ofstream 
</p>
<div class="code"><pre>        out_stream p_file = output_file_handler.OpenOutputFile("linear_solution.txt");
</pre></div><p>
Loop over the entries of the solution 
</p>
<div class="code"><pre>        for (unsigned i=0; i&lt;result_repl.size(); i++)
        {
</pre></div><p>
Get the x and y-values of the node corresponding to this entry. The method
<tt>GetNode</tt> on the mesh class returns a pointer to a <tt>Node</tt> 
</p>
<div class="code"><pre>            double x = mesh.GetNode(i)-&gt;rGetLocation()[0];
            double y = mesh.GetNode(i)-&gt;rGetLocation()[1];
</pre></div><p>
Get the computed solution at this node from the <tt>ReplicatableVector</tt> 
</p>
<div class="code"><pre>            double u = result_repl[i];
</pre></div><p>
Finally, write x, y and u to the output file. The solution could then be
visualised in (eg) matlab, using the commands:
<tt>sol=load('linear_solution.txt'); plot3(sol(:,1),sol(:,2),sol(:,3),'.');</tt>
</p>
<div class="code"><pre>            (*p_file) &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; " " &lt;&lt; u &lt;&lt; "\n";
        }
</pre></div><p>
All Petsc <tt>Vec</tt>s should be destroyed when they are no longer needed 
</p>
<div class="code"><pre>        VecDestroy(result);
    }
</pre></div><h2 id="Test2:SolvingalinearparabolicPDE">Test 2: Solving a linear parabolic PDE</h2>
<p>
Now we solve a parabolic PDE. We choose a simple problem so that the code changes
needed from the elliptic case are clearer. We will solve
du/dt = div(grad u) + u, in 3d, with boundary conditions u=1 on the boundary, and initial
conditions u=1
</p>
<div class="code"><pre>    void TestSolvingParabolicPde()
    {
</pre></div><p>
Create a 10 by 10 by 10 mesh in 3D, this time using the <tt>ConstructCuboid</tt> method
on the mesh. 
</p>
<div class="code"><pre>        TetrahedralMesh&lt;3,3&gt; mesh;
        mesh.ConstructCuboid(10,10,10);
</pre></div><p>
This returns a mesh over the region <a class="missing source">[0,10]</a><sup>3</sup> with 10 elements in each direction, so
we have to scale it down to <a class="missing source">[0,1]</a><sup>3</sup> 
</p>
<div class="code"><pre>        mesh.Scale(1.0/10, 1.0/10, 1.0/10);
</pre></div><p>
Our PDE object should be a class that is derived from the <tt>AbstractLinearParabolicPde</tt>.
We could write it ourselves as in the previous test, but since the PDE we want to solve is
so simple, it has already been defined (look it up! - it is located in pde/test/pdes)
</p>
<div class="code"><pre>        HeatEquationWithSourceTerm&lt;3&gt; pde;
</pre></div><p>
Create a new boundary conditions container and specify u=1.0 on the boundary 
</p>
<div class="code"><pre>        BoundaryConditionsContainer&lt;3,3,1&gt; bcc;
        bcc.DefineConstantDirichletOnMeshBoundary(&amp;mesh, 1.0);
</pre></div><p>
Create an instance of the assembler, passing in the mesh, pde and boundary conditions.
The '<tt>true</tt>' template parameter says this is a NON_HEART problem (so the certain
optimisations for cardiac problems are not used). 
</p>
<div class="code"><pre>        SimpleDg0ParabolicAssembler&lt;3,3,true&gt; assembler(&amp;mesh,&amp;pde,&amp;bcc);
</pre></div><p>
For parabolic problems, initial conditions are also needed. The assembler will expect
a Petsc vector, where the i-th entry is the initial solution at node i, to be passed
in. To create this Petsc <tt>Vec</tt>, we will use a helper function in the <tt>PetscTools</tt>
class to create a <tt>Vec</tt> of size num_nodes, with each entry set to 1.0. Then we
set the initial condition on the assembler 
</p>
<div class="code"><pre>        Vec initial_condition = PetscTools::CreateVec(mesh.GetNumNodes(), 1.0);
        assembler.SetInitialCondition(initial_condition);
</pre></div><p>
Next define the start time, end time, and timestep, and set them. 
</p>
<div class="code"><pre>        double t_start = 0;
        double t_end = 1;
        double dt = 0.01;
        assembler.SetTimes(t_start, t_end, dt);
</pre></div><p>
Now we can solve the problem. The <tt>Vec</tt> that is returned can be passed into a
<tt>ReplicatableVector</tt> as before
</p>
<div class="code"><pre>        Vec solution = assembler.Solve();
        ReplicatableVector solution_repl(solution);
</pre></div><p>
Let's also solve the equivalent static PDE, ie set du/dt=0, so 0=div(gradu) + u. This
is easy, as the PDE class has already been defined 
</p>
<div class="code"><pre>        SimplePoissonEquation&lt;3,3&gt; static_pde;
        SimpleLinearEllipticAssembler&lt;3,3&gt; static_assembler(&amp;mesh, &amp;static_pde, &amp;bcc);
        Vec static_solution = static_assembler.Solve();
        ReplicatableVector static_solution_repl(static_solution);
</pre></div><p>
We can now compare the solution of the parabolic PDE at t=1 with the static solution,
to see if the static equilibrium solution was reached in the former. (Ideally we should
compute some relative error, but we just compute an absolute error for simplicity). 
</p>
<div class="code"><pre>        for (unsigned i=0; i&lt;static_solution_repl.size(); i++)
        {
            TS_ASSERT_DELTA( solution_repl[i], static_solution_repl[i], 1e-3);
        }
</pre></div><p>
All Petsc vectors should be destroyed when they are no longer needed 
</p>
<div class="code"><pre>        VecDestroy(initial_condition);
        VecDestroy(solution);
        VecDestroy(static_solution);
    }
};
</pre></div><h1 id="Code">Code</h1>
<p>
The full code is given below
</p>
<div class="code"><pre>#include &lt;cxxtest/TestSuite.h&gt;
#include "UblasCustomFunctions.hpp"
#include "SimpleLinearEllipticAssembler.hpp"
#include "SimpleDg0ParabolicAssembler.hpp"
#include "HeatEquationWithSourceTerm.hpp"
#include "SimplePoissonEquation.hpp"
#include "TrianglesMeshReader.hpp"
#include "TetrahedralMesh.hpp"
#include "BoundaryConditionsContainer.hpp"
#include "ConstBoundaryCondition.hpp"
#include "OutputFileHandler.hpp"
#include "PetscSetupAndFinalize.hpp"

class MyPde : public AbstractLinearEllipticPde&lt;2,2&gt;
{
private:
    c_matrix&lt;double,2,2&gt; mDiffusionTensor;

public:
    MyPde()
    {
        mDiffusionTensor(0,0) = 1.0;
        mDiffusionTensor(0,1) = 1.0;
        mDiffusionTensor(1,0) = 0.0;
        mDiffusionTensor(1,1) = 1.0;
    }

    double ComputeConstantInUSourceTerm(const ChastePoint&lt;2&gt;&amp; rX)
    {
        return rX[0]*rX[0] + rX[1]*rX[1];
    }

    double ComputeLinearInUCoeffInSourceTerm(const ChastePoint&lt;2&gt;&amp; rX, Element&lt;2,2&gt;* pElement)
    {
        return 1.0;
    }

    c_matrix&lt;double,2,2&gt; ComputeDiffusionTerm(const ChastePoint&lt;2&gt;&amp; rX)
    {
        return mDiffusionTensor;
    }
};

class TestSolvingLinearPdesTutorial : public CxxTest::TestSuite
{
public:
    void TestSolvingEllipticPde()
    {
        TrianglesMeshReader&lt;2,2&gt; mesh_reader("mesh/test/data/square_128_elements");
        TetrahedralMesh&lt;2,2&gt; mesh;
        mesh.ConstructFromMeshReader(mesh_reader);

        MyPde pde;

        BoundaryConditionsContainer&lt;2,2,1&gt; bcc;

        //bcc.DefineZeroDirichletOnMeshBoundary(&amp;mesh);

        TetrahedralMesh&lt;2,2&gt;::BoundaryNodeIterator iter
           = mesh.GetBoundaryNodeIteratorBegin();
        while (iter &lt; mesh.GetBoundaryNodeIteratorEnd())
        {
            double x = (*iter)-&gt;GetPoint()[0];
            double y = (*iter)-&gt;GetPoint()[1];
            if ((x==0) || (y==0))
            {
                ConstBoundaryCondition&lt;2&gt; *p_dirichlet_boundary_condition = new ConstBoundaryCondition&lt;2&gt;(0.0);
                bcc.AddDirichletBoundaryCondition(*iter, p_dirichlet_boundary_condition);
            }
            iter++;
        }

        ConstBoundaryCondition&lt;2&gt; *p_neumann_boundary_condition = new ConstBoundaryCondition&lt;2&gt;(0.0);

        TetrahedralMesh&lt;2,2&gt;::BoundaryElementIterator surf_iter
          = mesh.GetBoundaryElementIteratorBegin();
        while (surf_iter &lt; mesh.GetBoundaryElementIteratorEnd())
        {
            unsigned node_index = (*surf_iter)-&gt;GetNodeGlobalIndex(0);
            double x = mesh.GetNode(node_index)-&gt;GetPoint()[0];
            double y = mesh.GetNode(node_index)-&gt;GetPoint()[1];

            if ( (fabs(x-1.0) &lt; 1e-6) || (fabs(y-1.0) &lt; 1e-6) )
            {
                bcc.AddNeumannBoundaryCondition(*surf_iter, p_neumann_boundary_condition);
            }

            surf_iter++;
        }

        SimpleLinearEllipticAssembler&lt;2,2&gt; assembler(&amp;mesh,&amp;pde,&amp;bcc);

        Vec result = assembler.Solve();

        ReplicatableVector result_repl(result);

        OutputFileHandler output_file_handler("TestSolvingLinearPdeTutorial");

        out_stream p_file = output_file_handler.OpenOutputFile("linear_solution.txt");

        for (unsigned i=0; i&lt;result_repl.size(); i++)
        {
            double x = mesh.GetNode(i)-&gt;rGetLocation()[0];
            double y = mesh.GetNode(i)-&gt;rGetLocation()[1];

            double u = result_repl[i];

            (*p_file) &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; " " &lt;&lt; u &lt;&lt; "\n";
        }

        VecDestroy(result);
    }

    void TestSolvingParabolicPde()
    {
        TetrahedralMesh&lt;3,3&gt; mesh;
        mesh.ConstructCuboid(10,10,10);
        mesh.Scale(1.0/10, 1.0/10, 1.0/10);

        HeatEquationWithSourceTerm&lt;3&gt; pde;

        BoundaryConditionsContainer&lt;3,3,1&gt; bcc;
        bcc.DefineConstantDirichletOnMeshBoundary(&amp;mesh, 1.0);

        SimpleDg0ParabolicAssembler&lt;3,3,true&gt; assembler(&amp;mesh,&amp;pde,&amp;bcc);

        Vec initial_condition = PetscTools::CreateVec(mesh.GetNumNodes(), 1.0);
        assembler.SetInitialCondition(initial_condition);

        double t_start = 0;
        double t_end = 1;
        double dt = 0.01;
        assembler.SetTimes(t_start, t_end, dt);

        Vec solution = assembler.Solve();
        ReplicatableVector solution_repl(solution);

        SimplePoissonEquation&lt;3,3&gt; static_pde;
        SimpleLinearEllipticAssembler&lt;3,3&gt; static_assembler(&amp;mesh, &amp;static_pde, &amp;bcc);
        Vec static_solution = static_assembler.Solve();
        ReplicatableVector static_solution_repl(static_solution);

        for (unsigned i=0; i&lt;static_solution_repl.size(); i++)
        {
            TS_ASSERT_DELTA( solution_repl[i], static_solution_repl[i], 1e-3);
        }

        VecDestroy(initial_condition);
        VecDestroy(solution);
        VecDestroy(static_solution);
    }
};

</pre></div>
        
        
      </div>
