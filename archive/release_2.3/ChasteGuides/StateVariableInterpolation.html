<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>ChasteGuides/StateVariableInterpolation - Chaste</title>
    <link rel="stylesheet" href="/trac/css/trac.css" type="text/css" />
    <link rel="stylesheet" href="/trac/css/wiki.css" type="text/css" />
    <link rel="stylesheet" href="/trac/css/site.css" type="text/css" />
    <style type="text/css">
/* Link styles */
:link, :visited, a em {
 text-decoration: none;
 color: #283f6b;
 border-bottom: 1px dotted #bbb;
}
/*
:link:hover, :visited:hover {
 background-color: #eee;
 color: #555;
}
*/
    </style>

  </head>
  <body>
    <div id="banner">
      <div id="header">
        <p>
          <a id="logo" href="http://www.cs.ox.ac.uk/chaste"><img src="/logos/chaste-266x60.jpg" alt="Chaste logo" height="60" width="266" /></a>
          <em>Documentation for <a href="/chaste/tutorials/release_2.3/">Release 2.3</a>.</em>
        </p>
      </div>
    </div>
    <p>&nbsp;</p>
    <div id="content" class="wiki">
      <p class="path noprint">
        <a class="pathentry" title="View ChasteGuides" href="/chaste/tutorials/release_2.3/ChasteGuides.html">ChasteGuides</a><span class="pathentry sep">/</span><a class="pathentry" title="View ChasteGuides/StateVariableInterpolation" href="/chaste/tutorials/release_2.3/ChasteGuides/StateVariableInterpolation.html">StateVariableInterpolation</a>
        <br style="clear: both" />
      </p>
      <div class="wikipage searchable">
        
          <p>
State-variable interpolation is an alternative way of computing the ionic current in tissue simulations, which can improve accuracy, in particular in the conduction velocity, without too great a loss in efficiency. 
</p>
<h2 id="WhatisStateVariableInterpolationSVI">What is State Variable Interpolation (SVI)?</h2>
<p>
In solving the monodomain/bidomain equations using the finite element method, the ionic current needs to be evaluated in the interior of the elements* (onto the quadrature points). Since we store the cell models at the nodes, we only know the ionic current at the nodes. The obvious approach for computing the current in the interior of the elements: compute the current at the nodes using the cell models, and interpolate into the interior. This is the default behaviour in Chaste, and referred to as <i>ionic current interpolation (ICI)</i>. 
</p>
<p>
An alternative approach is to interpolate <strong>all the state variables</strong> from the cell models ODEs 
at the nodes, into the interior of the elements. We refer to this as <i>state-variable interpolation (SVI)</i>. This has been shown to have a surprisingly large effect, especially on conduction velocity, and even on meshes that are considered high-resolution (100 micrometre spatial resolution) - see below for a discussion.
</p>
<h2 id="HowdoIuseit">How do I use it?</h2>
<p>
<strong>Cardiac executable:</strong> in the <tt>&lt;Numerical&gt;</tt> part of the XML input file, add
</p>
<div class="code"><pre><span class="nt">&lt;UseStateVariableInterpolation&gt;</span>yes<span class="nt">&lt;/UseStateVariableInterpolation&gt;</span>
</pre></div><p>
<i>after</i> the mesh partitioning block. For example:
</p>
<div class="code"><pre><span class="nt">&lt;Numerical&gt;</span>
   ...
 
   <span class="c">&lt;!-- How to partition the mesh when running in parallel --&gt;</span>
   <span class="nt">&lt;MeshPartitioning&gt;</span>metis<span class="nt">&lt;/MeshPartitioning&gt;</span>
   
   <span class="c">&lt;!-- How to integrate the ionic current term (defaults to no) --&gt;</span>
   <span class="nt">&lt;UseStateVariableInterpolation&gt;</span>yes<span class="nt">&lt;/UseStateVariableInterpolation&gt;</span>

   ...
<span class="nt">&lt;/Numerical&gt;</span>
</pre></div><p>
<strong>Source code:</strong> simply call
</p>
<div class="code"><pre>HeartConfig<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>SetUseStateVariableInterpolation<span class="p">();</span>
</pre></div><h2 id="HowdoesSVIaffectcomputationtimeandhowisitimplemented">How does SVI affect computation time, and how is it implemented?</h2>
<p>
Implementing SVI naively would <i>massively</i> increase computation time (even more than might originally be expected). Instead, it has been implemented in Chaste in an efficient manner where SVI is only used on elements around the wavefront. This slows down computation (in a cell model and problem dependent manner), but not massively. 
</p>
<p>
For further details on the method, see <tt>[1]</tt>. The form of SVI implemented in Chaste is what is referred to as the <i>hybrid</i> method in this paper**. 
</p>
<h2 id="Whenshoulditbeused">When should it be used?</h2>
<p>
The paper <tt>[1]</tt> describes in detail the effect of SVI over ICI. In brief
</p>
<ul><li>ICI erroneously decreases conduction velocity on coarse meshes (~500 micrometres), and can massively decrease CV in the cross-fibre direction 
</li><li>ICI erroneously <i>increases</i> conduction velocity in the fibre direction on mediumly fine meshes (~100 micrometres)
</li><li>ICI and SVI give the same results on very fine meshes
</li></ul><p>
We recommend using SVI if refining the mesh would be too costly and either (i) good CV accuracy is required in the fibre direction (ii) decent cross-fibre CV accuracy is required in anisotropic simulations.
</p>
<p>
A recent survey of several cardiac electrophysiology solvers <tt>[2]</tt> used conduction velocity as a metric for comparison. It should be noted that Chaste used SVI for the results in this paper. (Without SVI switched on, the Chaste results would have been similar to the Sundnes et al results in this paper).
</p>
<p>
One complication that should be noted: the SVI results are closer to the true finite element solution, which, if the mesh is too coarse, may be oscillatory around the upstroke. ICI numerically smooths out these oscillations (effectively two sources of error cancelling out to make the result 'look' more accurate). So switching on SVI may lead to the action potential looking less accurate, and may in fact lead to the simulation failing if these oscillations are too large.
</p>
<h2 id="References">References</h2>
<p>
<tt>[1]</tt> P. Pathmanathan, G. Mirams, J. Southern, J. Whiteley, "The significant effect of the choice of ionic current integration method in cardiac electro-physiological simulations", International Journal for Numerical Methods in Biomedical Engineering, 2011 (in press)
</p>
<p>
<tt>[2]</tt> S. Niederer. N-Version Benchmark Evaluation of Cardiac Electrophysiology Simulators.
Royal Society Philosophical Transactions A, 2011 (in press).
</p>
<h2 id="Footnotes">Footnotes</h2>
<p>
*Other solvers use <i>operator splitting</i> of the reaction term (ionic current) from the PDEs, for which the ionic current is not required in the interior. The simplest form of operator splitting (Godunov splitting) is formally equivalent to ICI. Other forms such as Strang splitting are temporally different but spatially the same. However, SVI cannot be applied to operator splitting methods to improve accuracy.
</p>
<p>
**The criterion for which elements to use SVI on is based on the maximum difference in nodal ionic current values, and can be read off from <tt>AbstractCorrectionTermAssembler&lt;ELEMENT_DIM,SPACE_DIM,PROBLEM_DIM&gt;::ElementAssemblyCriterion()</tt> 
</p>

        
        
      </div>

    </div>
  </body>
</html>
