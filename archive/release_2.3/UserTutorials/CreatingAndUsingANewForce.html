<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>UserTutorials/CreatingAndUsingANewForce - Chaste</title>
    <link rel="stylesheet" href="https://chaste.github.io/old_releases/trac.css" type="text/css" />
    <link rel="stylesheet" href="https://chaste.github.io/old_releases/wiki.css" type="text/css" />
    <link rel="stylesheet" href="/trac/css/site.css" type="text/css" />
    <style type="text/css">
/* Link styles */
:link, :visited, a em {
 text-decoration: none;
 color: #283f6b;
 border-bottom: 1px dotted #bbb;
}
/*
:link:hover, :visited:hover {
 background-color: #eee;
 color: #555;
}
*/
    </style>

  </head>
  <body>
    <div id="banner">
      <div id="header">
        <p>
          <a id="logo" href="https://chaste.github.io/"><img src="https://chaste.github.io/chaste_0256.png" alt="Chaste logo" height="60" /></a>
          <em>Documentation for <a href="https://chaste.github.io/old_releases/release_2.3/">Release 2.3</a>.</em>
        </p>
      </div>
    </div>
    <p>&nbsp;</p>
    <div id="content" class="wiki">
      <p class="path noprint">
        <a class="pathentry" title="View UserTutorials" href="https://chaste.github.io/old_releases/release_2.3/UserTutorials.html">UserTutorials</a><span class="pathentry sep">/</span><a class="pathentry" title="View UserTutorials/CreatingAndUsingANewForce" href="https://chaste.github.io/old_releases/release_2.3/UserTutorials/CreatingAndUsingANewForce.html">CreatingAndUsingANewForce</a>
        <br style="clear: both" />
      </p>
      <div class="wikipage searchable">
        
          <p>
This tutorial is automatically generated from the file trunk/cell_based/test/tutorial/TestCreatingAndUsingANewForceTutorial.hpp at revision <a class="changeset" href="/cgi-bin/trac.cgi/changeset/12669" title="#1592 - strengthen cell-based tutorial archiving tests">r12669</a>.
Note that the code is given in full at the bottom of the page.
</p>
<h1 id="Anexampleshowinghowtocreateanduseanewforce">An example showing how to create and use a new force</h1>
<h2 id="Introduction">Introduction</h2>
<p>
In previous cell-based Chaste tutorial, we used existing force classes to define
how cells interact mechanically. In this tutorial we show
how to create a new force class, and how this can be used in a cell-based
simulation.
</p>
<h2 id="a1.Includingheaderfiles">1. Including header files</h2>
<p>
As in previous cell-based Chaste tutorials, we begin by including the necessary header files.
</p>
<div class="code"><pre><span class="cp">#include &lt;cxxtest/TestSuite.h&gt;
#include "CheckpointArchiveTypes.hpp"
</span></pre></div><p>
The next header defines a base class for forces, from which the new class will inherit.
</p>
<div class="code"><pre><span class="cp">#include "AbstractForce.hpp"
</span></pre></div><p>
The remaining header files define classes that will be used in the cell population
simulation test. We have encountered each of these header files in previous cell-based
Chaste tutorials.
</p>
<div class="code"><pre><span class="cp">#include "HoneycombMeshGenerator.hpp"
#include "FixedDurationGenerationBasedCellCycleModel.hpp"
#include "GeneralisedLinearSpringForce.hpp"
#include "CellBasedSimulation.hpp"
#include "CellsGenerator.hpp"
</span></pre></div><h2 id="Definingtheforceclass">Defining the force class</h2>
<p>
As an example, let us consider a force for a two-dimensional cell-based
simulation, that mimics gravity. To implement this we define a force
boundary condition class, <tt>MyBoundaryCondition</tt>, which inherits from
<tt>AbstractForce</tt> and overrides the methods <tt>AddForceContribution()</tt> and
<tt>OutputForceParameters()</tt>.
</p>
<div class="code"><pre><span class="k">class</span> <span class="nc">MyForce</span> <span class="o">:</span> <span class="k">public</span> AbstractForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
</pre></div><p>
This force class includes a member variable, <tt>mStrength</tt>, which
defines the strength of the force. This member variables will be set
in the constructor.
</p>
<div class="code"><pre>    <span class="kt">double</span> mStrength<span class="p">;</span>
</pre></div><p>
We only need to include the next block of code if we wish to be able
to archive (save or load) the force model object in a cell-based simulation.
The code consists of a serialize method, in which we first archive the force
using the serialization code defined in the base class <tt>AbstractForce</tt>,
then archive the member variable.
</p>
<div class="code"><pre>    <span class="k">friend</span> <span class="k">class</span> <span class="nc">boost</span><span class="o">::</span>serialization<span class="o">::</span>access<span class="p">;</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Archive</span><span class="o">&gt;</span>
    <span class="kt">void</span> serialize<span class="p">(</span>Archive <span class="o">&amp;</span> archive<span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> version<span class="p">)</span>
    <span class="p">{</span>
        archive <span class="o">&amp;</span> boost<span class="o">::</span>serialization<span class="o">::</span>base_object<span class="o">&lt;</span>AbstractForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
        archive <span class="o">&amp;</span> mStrength<span class="p">;</span>
    <span class="p">}</span>
<span class="k">public</span><span class="o">:</span>
</pre></div><p>
The first public method is a default constructor, which calls the base
constructor. There is a single input argument, which defines the strength
of the force. We provide a default value of 1.0 for this argument. Inside
the method, we add an assertion to make sure that the strength is strictly
positive.
</p>
<div class="code"><pre>    MyForce<span class="p">(</span><span class="kt">double</span> strength<span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="o">:</span> AbstractForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(),</span>
          mStrength<span class="p">(</span>strength<span class="p">)</span>
    <span class="p">{</span>
        assert<span class="p">(</span>mStrength <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div><p>
The second public method overrides <tt>AddForceContribution()</tt>.
This method takes in two arguments: a reference to a vector of
total forces on nodes in a cell population, which is update to by the
force object; and a reference to the cell population itself.
</p>
<div class="code"><pre>    <span class="kt">void</span> AddForceContribution<span class="p">(</span>std<span class="o">::</span>vector<span class="o">&lt;</span>c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> rForces<span class="p">,</span>
                              AbstractCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;&amp;</span> rCellPopulation<span class="p">)</span>
    <span class="p">{</span>
</pre></div><p>
Inside the method, we loop over nodes, and add a constant vector to
each node, in the negative <i>y</i>-direction and of magnitude <tt>mStrength</tt>.
</p>
<div class="code"><pre>        c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> force <span class="o">=</span> zero_vector<span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        force<span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span>mStrength<span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> node_index<span class="o">=</span><span class="mi">0</span><span class="p">;</span> node_index<span class="o">&lt;</span>rForces<span class="p">.</span>size<span class="p">();</span> node_index<span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            rForces<span class="p">[</span>node_index<span class="p">]</span> <span class="o">+=</span> force<span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div><p>
We also add a get method for <tt>mStrength</tt>, to allow for testing.
</p>
<div class="code"><pre>    <span class="kt">double</span> GetStrength<span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> mStrength<span class="p">;</span>
    <span class="p">}</span>
</pre></div><p>
Just as we encountered in the cell killer tutorial, here we must override
a method that outputs any member variables to a specified results file <tt>rParamsFile</tt>.
In our case, we output the member variable {{{mStrength}, then call the method on the base class.
</p>
<div class="code"><pre>    <span class="kt">void</span> OutputForceParameters<span class="p">(</span>out_stream<span class="o">&amp;</span> rParamsFile<span class="p">)</span>
    <span class="p">{</span>
        <span class="o">*</span>rParamsFile <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\t\t\t</span><span class="s">&lt;Strength&gt;"</span> <span class="o">&lt;&lt;</span> mStrength <span class="o">&lt;&lt;</span> <span class="s">"&lt;/Strength&gt; </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        AbstractForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>OutputForceParameters<span class="p">(</span>rParamsFile<span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div><p>
As mentioned in previous cell-based Chaste tutorials, we need to include the next block
of code to be able to archive the force object in a cell-based
simulation, and to obtain a unique identifier for our new force for writing
results to file.
</p>
<div class="code"><pre><span class="cp">#include "SerializationExportWrapper.hpp"
</span>CHASTE_CLASS_EXPORT<span class="p">(</span>MyForce<span class="p">)</span>
<span class="cp">#include "SerializationExportWrapperForCpp.hpp"
</span>CHASTE_CLASS_EXPORT<span class="p">(</span>MyForce<span class="p">)</span>
</pre></div><p>
This completes the code for <tt>MyForce</tt>. Note that usually this code
would be separated out into a separate declaration in a .hpp file and definition
in a .cpp file.
</p>
<h3 id="TheTests">The Tests</h3>
<p>
We now define the test class, which inherits from <tt>CxxTest::TestSuite</tt>.
</p>
<div class="code"><pre><span class="k">class</span> <span class="nc">TestCreatingAndUsingANewForceTutorial</span> <span class="o">:</span> <span class="k">public</span> CxxTest<span class="o">::</span>TestSuite
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
</pre></div><h2 id="Testingtheforce">Testing the force</h2>
<p>
We now test that our new force is implemented correctly.
</p>
<div class="code"><pre>    <span class="kt">void</span> TestMyForce<span class="p">()</span> <span class="k">throw</span><span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
</pre></div><p>
The first thing to do, as before, is to set up the start time.
</p>
<div class="code"><pre>        SimulationTime<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>SetStartTime<span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
</pre></div><p>
We now create a <tt>MeshBasedCellPopulation</tt> using the helper
classes <tt>HoneycombMeshGenerator</tt> and <tt>CellsGenerator</tt>,
as in previous cell-based Chaste tutorials.
</p>
<div class="code"><pre>        HoneycombMeshGenerator generator<span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        MutableMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetMesh<span class="p">();</span>
        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        CellsGenerator<span class="o">&lt;</span>FixedDurationGenerationBasedCellCycleModel<span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> cells_generator<span class="p">;</span>
        cells_generator<span class="p">.</span>GenerateBasic<span class="p">(</span>cells<span class="p">,</span> p_mesh<span class="o">-&gt;</span>GetNumNodes<span class="p">());</span>
        MeshBasedCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">);</span>
</pre></div><p>
The next step is to initialise a vector of node forces.
</p>
<div class="code"><pre>        std<span class="o">::</span>vector<span class="o">&lt;</span>c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> <span class="o">&gt;</span> node_forces<span class="p">;</span>
        node_forces<span class="p">.</span>reserve<span class="p">(</span>cell_population<span class="p">.</span>GetNumNodes<span class="p">());</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> i<span class="o">=</span><span class="mi">0</span><span class="p">;</span> i<span class="o">&lt;</span>cell_population<span class="p">.</span>GetNumNodes<span class="p">();</span> i<span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
             node_forces<span class="p">.</span>push_back<span class="p">(</span>zero_vector<span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
        <span class="p">}</span>
</pre></div><p>
We now create a force object of strength 5.0.
</p>
<div class="code"><pre>        MyForce force<span class="p">(</span><span class="mf">5.0</span><span class="p">);</span>
</pre></div><p>
We test that the force calculation is correct.
</p>
<div class="code"><pre>        force<span class="p">.</span>AddForceContribution<span class="p">(</span>node_forces<span class="p">,</span> cell_population<span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> node_index<span class="o">=</span><span class="mi">0</span><span class="p">;</span> node_index<span class="o">&lt;</span>cell_population<span class="p">.</span>GetNumNodes<span class="p">();</span> node_index<span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            TS_ASSERT_DELTA<span class="p">(</span>node_forces<span class="p">[</span>node_index<span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1e-4</span><span class="p">);</span>
            TS_ASSERT_DELTA<span class="p">(</span>node_forces<span class="p">[</span>node_index<span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mf">5.0</span><span class="p">,</span> <span class="mf">1e-4</span><span class="p">);</span>
        <span class="p">}</span>
</pre></div><p>
The last block of code provides an archiving test for the force class,
in a similar way to previous cell-based Chaste tutorials:
</p>
<p>
Note that it is important to test archiving by using an abstract
pointer, so that you check that boost can identify and record which
concrete class it should be dealing with.
This tests the CHASTE_CLASS_EXPORT(<a class="missing wiki" href="/cgi-bin/trac.cgi/wiki/MyForce" rel="nofollow">MyForce?</a>) lines are implemented correctly.
</p>
<div class="code"><pre>        OutputFileHandler handler<span class="p">(</span><span class="s">"archive"</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
        std<span class="o">::</span>string archive_filename <span class="o">=</span> handler<span class="p">.</span>GetOutputDirectoryFullPath<span class="p">()</span> <span class="o">+</span> <span class="s">"my_force.arch"</span><span class="p">;</span>
        <span class="p">{</span>
            AbstractForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;*</span> <span class="k">const</span> p_force <span class="o">=</span> <span class="k">new</span> MyForce<span class="p">(</span><span class="mf">2.6</span><span class="p">);</span>
            std<span class="o">::</span>ofstream ofs<span class="p">(</span>archive_filename<span class="p">.</span>c_str<span class="p">());</span>
            boost<span class="o">::</span>archive<span class="o">::</span>text_oarchive output_arch<span class="p">(</span>ofs<span class="p">);</span>
            output_arch <span class="o">&lt;&lt;</span> p_force<span class="p">;</span>
            <span class="k">delete</span> p_force<span class="p">;</span>
        <span class="p">}</span>
        <span class="p">{</span>
            std<span class="o">::</span>ifstream ifs<span class="p">(</span>archive_filename<span class="p">.</span>c_str<span class="p">(),</span> std<span class="o">::</span>ios<span class="o">::</span>binary<span class="p">);</span>
            boost<span class="o">::</span>archive<span class="o">::</span>text_iarchive input_arch<span class="p">(</span>ifs<span class="p">);</span>
            AbstractForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;*</span> p_force<span class="p">;</span>
            input_arch <span class="o">&gt;&gt;</span> p_force<span class="p">;</span>
            TS_ASSERT_DELTA<span class="p">(</span><span class="k">dynamic_cast</span><span class="o">&lt;</span>MyForce<span class="o">*&gt;</span><span class="p">(</span>p_force<span class="p">)</span><span class="o">-&gt;</span>GetStrength<span class="p">(),</span> <span class="mf">2.6</span><span class="p">,</span> <span class="mf">1e-4</span><span class="p">);</span>
            <span class="k">delete</span> p_force<span class="p">;</span>
        <span class="p">}</span>
</pre></div><p>
We conclude the test by calling Destroy() on any singleton classes.
</p>
<div class="code"><pre>        SimulationTime<span class="o">::</span>Destroy<span class="p">();</span>
    <span class="p">}</span>
</pre></div><h2 id="Usingtheforceinacell-basedsimulation">Using the force in a cell-based simulation</h2>
<p>
We now provide a test demonstrating how <tt>MyForce</tt> can be used
in a cell-based simulation.
</p>
<div class="code"><pre>    <span class="kt">void</span> TestCellBasedSimulationWithMyBoundaryCondition<span class="p">()</span> <span class="k">throw</span><span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
</pre></div><p>
The first thing to do, as before, is to set up the start time.
</p>
<div class="code"><pre>        SimulationTime<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>SetStartTime<span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
</pre></div><p>
Once again we create a <tt>MeshBasedCellPopulation</tt>.
</p>
<div class="code"><pre>        HoneycombMeshGenerator generator<span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        MutableMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetMesh<span class="p">();</span>
        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        CellsGenerator<span class="o">&lt;</span>FixedDurationGenerationBasedCellCycleModel<span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> cells_generator<span class="p">;</span>
        cells_generator<span class="p">.</span>GenerateBasic<span class="p">(</span>cells<span class="p">,</span> p_mesh<span class="o">-&gt;</span>GetNumNodes<span class="p">());</span>
        MeshBasedCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">);</span>
</pre></div><p>
We then pass in the cell population into a <tt>CellBasedSimulation</tt>,
and set the output directory and end time.
</p>
<div class="code"><pre>        CellBasedSimulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> simulator<span class="p">(</span>cell_population<span class="p">);</span>
        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"TestCellBasedSimulationWithMyForce"</span><span class="p">);</span>
        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mf">10.0</span><span class="p">);</span>
</pre></div><p>
We create our force law and pass it to the <tt>CellBasedSimulation</tt>.
</p>
<div class="code"><pre>        MyForce force<span class="p">(</span><span class="mf">0.5</span><span class="p">);</span>
        simulator<span class="p">.</span>AddForce<span class="p">(</span><span class="o">&amp;</span>force<span class="p">);</span>
</pre></div><p>
We test that the Solve() method does not throw any exceptions.
</p>
<div class="code"><pre>        TS_ASSERT_THROWS_NOTHING<span class="p">(</span>simulator<span class="p">.</span>Solve<span class="p">());</span>
</pre></div><p>
We conclude the test by calling <tt>Destroy()</tt> on any singleton classes.
</p>
<div class="code"><pre>        SimulationTime<span class="o">::</span>Destroy<span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div><h1 id="Code">Code</h1>
<p>
The full code is given below
</p>
<h2 id="FilenameTestCreatingAndUsingANewForceTutorial.hpp">File name <tt>TestCreatingAndUsingANewForceTutorial.hpp</tt></h2>
<div class="code"><pre><span class="cp">#include &lt;cxxtest/TestSuite.h&gt;
#include "CheckpointArchiveTypes.hpp"
#include "AbstractForce.hpp"
#include "HoneycombMeshGenerator.hpp"
#include "FixedDurationGenerationBasedCellCycleModel.hpp"
#include "GeneralisedLinearSpringForce.hpp"
#include "CellBasedSimulation.hpp"
#include "CellsGenerator.hpp"
</span>
<span class="k">class</span> <span class="nc">MyForce</span> <span class="o">:</span> <span class="k">public</span> AbstractForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>

    <span class="kt">double</span> mStrength<span class="p">;</span>

    <span class="k">friend</span> <span class="k">class</span> <span class="nc">boost</span><span class="o">::</span>serialization<span class="o">::</span>access<span class="p">;</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Archive</span><span class="o">&gt;</span>
    <span class="kt">void</span> serialize<span class="p">(</span>Archive <span class="o">&amp;</span> archive<span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> version<span class="p">)</span>
    <span class="p">{</span>
        archive <span class="o">&amp;</span> boost<span class="o">::</span>serialization<span class="o">::</span>base_object<span class="o">&lt;</span>AbstractForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
        archive <span class="o">&amp;</span> mStrength<span class="p">;</span>
    <span class="p">}</span>

<span class="k">public</span><span class="o">:</span>
    MyForce<span class="p">(</span><span class="kt">double</span> strength<span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="o">:</span> AbstractForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(),</span>
          mStrength<span class="p">(</span>strength<span class="p">)</span>
    <span class="p">{</span>
        assert<span class="p">(</span>mStrength <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> AddForceContribution<span class="p">(</span>std<span class="o">::</span>vector<span class="o">&lt;</span>c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> rForces<span class="p">,</span>
                              AbstractCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;&amp;</span> rCellPopulation<span class="p">)</span>
    <span class="p">{</span>
        c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> force <span class="o">=</span> zero_vector<span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        force<span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span>mStrength<span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> node_index<span class="o">=</span><span class="mi">0</span><span class="p">;</span> node_index<span class="o">&lt;</span>rForces<span class="p">.</span>size<span class="p">();</span> node_index<span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            rForces<span class="p">[</span>node_index<span class="p">]</span> <span class="o">+=</span> force<span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">double</span> GetStrength<span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> mStrength<span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> OutputForceParameters<span class="p">(</span>out_stream<span class="o">&amp;</span> rParamsFile<span class="p">)</span>
    <span class="p">{</span>
        <span class="o">*</span>rParamsFile <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\t\t\t</span><span class="s">&lt;Strength&gt;"</span> <span class="o">&lt;&lt;</span> mStrength <span class="o">&lt;&lt;</span> <span class="s">"&lt;/Strength&gt; </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        AbstractForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>OutputForceParameters<span class="p">(</span>rParamsFile<span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="cp">
#include "SerializationExportWrapper.hpp"
</span>CHASTE_CLASS_EXPORT<span class="p">(</span>MyForce<span class="p">)</span>
<span class="cp">#include "SerializationExportWrapperForCpp.hpp"
</span>CHASTE_CLASS_EXPORT<span class="p">(</span>MyForce<span class="p">)</span>

<span class="k">class</span> <span class="nc">TestCreatingAndUsingANewForceTutorial</span> <span class="o">:</span> <span class="k">public</span> CxxTest<span class="o">::</span>TestSuite
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

    <span class="kt">void</span> TestMyForce<span class="p">()</span> <span class="k">throw</span><span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
        SimulationTime<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>SetStartTime<span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>

        HoneycombMeshGenerator generator<span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        MutableMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetMesh<span class="p">();</span>

        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        CellsGenerator<span class="o">&lt;</span>FixedDurationGenerationBasedCellCycleModel<span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> cells_generator<span class="p">;</span>
        cells_generator<span class="p">.</span>GenerateBasic<span class="p">(</span>cells<span class="p">,</span> p_mesh<span class="o">-&gt;</span>GetNumNodes<span class="p">());</span>

        MeshBasedCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">);</span>

        std<span class="o">::</span>vector<span class="o">&lt;</span>c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> <span class="o">&gt;</span> node_forces<span class="p">;</span>
        node_forces<span class="p">.</span>reserve<span class="p">(</span>cell_population<span class="p">.</span>GetNumNodes<span class="p">());</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> i<span class="o">=</span><span class="mi">0</span><span class="p">;</span> i<span class="o">&lt;</span>cell_population<span class="p">.</span>GetNumNodes<span class="p">();</span> i<span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
             node_forces<span class="p">.</span>push_back<span class="p">(</span>zero_vector<span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
        <span class="p">}</span>

        MyForce force<span class="p">(</span><span class="mf">5.0</span><span class="p">);</span>

        force<span class="p">.</span>AddForceContribution<span class="p">(</span>node_forces<span class="p">,</span> cell_population<span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> node_index<span class="o">=</span><span class="mi">0</span><span class="p">;</span> node_index<span class="o">&lt;</span>cell_population<span class="p">.</span>GetNumNodes<span class="p">();</span> node_index<span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            TS_ASSERT_DELTA<span class="p">(</span>node_forces<span class="p">[</span>node_index<span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1e-4</span><span class="p">);</span>
            TS_ASSERT_DELTA<span class="p">(</span>node_forces<span class="p">[</span>node_index<span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mf">5.0</span><span class="p">,</span> <span class="mf">1e-4</span><span class="p">);</span>
        <span class="p">}</span>

        OutputFileHandler handler<span class="p">(</span><span class="s">"archive"</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
        std<span class="o">::</span>string archive_filename <span class="o">=</span> handler<span class="p">.</span>GetOutputDirectoryFullPath<span class="p">()</span> <span class="o">+</span> <span class="s">"my_force.arch"</span><span class="p">;</span>
        <span class="p">{</span>
            AbstractForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;*</span> <span class="k">const</span> p_force <span class="o">=</span> <span class="k">new</span> MyForce<span class="p">(</span><span class="mf">2.6</span><span class="p">);</span>
            std<span class="o">::</span>ofstream ofs<span class="p">(</span>archive_filename<span class="p">.</span>c_str<span class="p">());</span>
            boost<span class="o">::</span>archive<span class="o">::</span>text_oarchive output_arch<span class="p">(</span>ofs<span class="p">);</span>

            output_arch <span class="o">&lt;&lt;</span> p_force<span class="p">;</span>
            <span class="k">delete</span> p_force<span class="p">;</span>
        <span class="p">}</span>
        <span class="p">{</span>
            std<span class="o">::</span>ifstream ifs<span class="p">(</span>archive_filename<span class="p">.</span>c_str<span class="p">(),</span> std<span class="o">::</span>ios<span class="o">::</span>binary<span class="p">);</span>
            boost<span class="o">::</span>archive<span class="o">::</span>text_iarchive input_arch<span class="p">(</span>ifs<span class="p">);</span>

            AbstractForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;*</span> p_force<span class="p">;</span>
            input_arch <span class="o">&gt;&gt;</span> p_force<span class="p">;</span>

            TS_ASSERT_DELTA<span class="p">(</span><span class="k">dynamic_cast</span><span class="o">&lt;</span>MyForce<span class="o">*&gt;</span><span class="p">(</span>p_force<span class="p">)</span><span class="o">-&gt;</span>GetStrength<span class="p">(),</span> <span class="mf">2.6</span><span class="p">,</span> <span class="mf">1e-4</span><span class="p">);</span>

            <span class="k">delete</span> p_force<span class="p">;</span>
        <span class="p">}</span>

        SimulationTime<span class="o">::</span>Destroy<span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> TestCellBasedSimulationWithMyBoundaryCondition<span class="p">()</span> <span class="k">throw</span><span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
        SimulationTime<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>SetStartTime<span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>

        HoneycombMeshGenerator generator<span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        MutableMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetMesh<span class="p">();</span>

        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        CellsGenerator<span class="o">&lt;</span>FixedDurationGenerationBasedCellCycleModel<span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> cells_generator<span class="p">;</span>
        cells_generator<span class="p">.</span>GenerateBasic<span class="p">(</span>cells<span class="p">,</span> p_mesh<span class="o">-&gt;</span>GetNumNodes<span class="p">());</span>

        MeshBasedCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">);</span>

        CellBasedSimulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> simulator<span class="p">(</span>cell_population<span class="p">);</span>
        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"TestCellBasedSimulationWithMyForce"</span><span class="p">);</span>
        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mf">10.0</span><span class="p">);</span>

        MyForce force<span class="p">(</span><span class="mf">0.5</span><span class="p">);</span>
        simulator<span class="p">.</span>AddForce<span class="p">(</span><span class="o">&amp;</span>force<span class="p">);</span>

        TS_ASSERT_THROWS_NOTHING<span class="p">(</span>simulator<span class="p">.</span>Solve<span class="p">());</span>

        SimulationTime<span class="o">::</span>Destroy<span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
        
        
      </div>

    </div>
  </body>
</html>
