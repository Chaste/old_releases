<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>UserTutorials/CreatingAndUsingANewCellProperty - Chaste</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="/trac-static/css/trac.css" type="text/css" />
    <link rel="stylesheet" href="/trac-static/css/wiki.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="/trac-static/css/site.css" />
  </head>
  <body>
    <div id="banner">
      <div id="header">
        <p>
          <a id="logo" href="http://www.cs.ox.ac.uk/chaste"><img src="/logos/chaste-266x60.jpg" alt="Chaste logo" height="60" width="266" /></a>
          <em>Documentation for <a href="/chaste/tutorials/release_3.4/">Release 3.4</a>.</em>
        </p>
      </div>
    </div>
    <p>&nbsp;</p>
    <div id="content" class="wiki">
      <div class="wikipage searchable">
        
          <div id="wikipage" class="trac-content"><p>
This tutorial is automatically generated from the file trunk/cell_based/test/tutorial/TestCreatingAndUsingANewCellPropertyTutorial.hpp at revision <a class="missing changeset" title="No permission to view changeset 25790 on (default)">r25790</a>.
Note that the code is given in full at the bottom of the page.
</p>
<h1 id="Anexampleshowinghowtocreateanewcellpropertyanduseitinacell-basedsimulation">An example showing how to create a new cell property and use it in a cell-based simulation</h1>
<h2 id="Introduction">Introduction</h2>
<p>
This tutorial assumes you have already read <a class="wiki" href="/chaste/tutorials/release_3.4/UserTutorials/CreatingAndUsingANewForce.html">UserTutorials/CreatingAndUsingANewForce</a>.
</p>
<p>
In the  <a class="wiki" href="/chaste/tutorials/release_3.4/UserTutorials/CreatingAndUsingANewCellMutationState.html">UserTutorials/CreatingAndUsingANewCellMutationState</a> we showed how to create a new cell mutation
state class, and how this can be used in a cell-based simulation. As well as
mutation states, cells may be given much more general properties, using the cell
property class hierarchy. In this tutorial, we show how to create a new cell property
class, and how this can be used in a cell-based simulation. We will also use a simple
new force to illustrate what you can do with cell properties (and also mutations).
</p>
<h2 id="a1.Includingheaderfiles">1. Including header files</h2>
<p>
As in previous cell-based Chaste tutorials, we begin by including the necessary
header file and archiving headers.
</p>
<div class="code"><pre><span class="cp">#include &lt;cxxtest/TestSuite.h&gt;
#include "CheckpointArchiveTypes.hpp"
#include "AbstractCellBasedTestSuite.hpp"
</span>
</pre></div><p>
The next header defines a base class for cell properties. Our new
cell property will inherit from this abstract class.
</p>
<div class="code"><pre><span class="cp">#include "AbstractCellProperty.hpp"
</span></pre></div><p>
The remaining header files define classes that will be used in the cell-based
simulation test. We have encountered each of these header files in previous cell-based
Chaste tutorials.
</p>
<div class="code"><pre><span class="cp">#include "AbstractForce.hpp"
#include "HoneycombMeshGenerator.hpp"
#include "NodesOnlyMesh.hpp"
#include "WildTypeCellMutationState.hpp"
#include "DifferentiatedCellProliferativeType.hpp"
#include "FixedDurationGenerationBasedCellCycleModel.hpp"
#include "GeneralisedLinearSpringForce.hpp"
#include "CellMutationStatesCountWriter.hpp"
#include "OffLatticeSimulation.hpp"
#include "SmartPointers.hpp"
</span><span class="c1">//This test is always run sequentially (never in parallel)
</span><span class="cp">#include "FakePetscSetup.hpp"
</span>
</pre></div><h2 id="Definingthecellpropertyclass">Defining the cell property class</h2>
<p>
As an example, let us consider a cell property class that is used to label
those cells that are "motile". This cell property could then be used when
implementing some form of chemotaxis down an imposed chemoattractant gradient,
as occurs for example when macrophages migrate within a tumour towards high
concentrations of the vascular endothelial growth factor VEGF; for further
details, see for example Owen <em>et al.</em>, J. Theor. Biol.
226: 377-391 (2004).
</p>
<p>
Note that usually this code would be separated out into a separate declaration
in a .hpp file and definition in a .cpp file.
</p>
<div class="code"><pre><span class="k">class</span> <span class="nc">MotileCellProperty</span> <span class="o">:</span> <span class="k">public</span> AbstractCellProperty
<span class="p">{</span>
<span class="nl">private:</span>

</pre></div><p>
We define a member variable <tt>mColour</tt>, which can be used by visualization tools
to paint cells with this mutation state a distinct colour if required.
</p>
<div class="code"><pre>    <span class="kt">unsigned</span> mColour<span class="p">;</span>

</pre></div><p>
The next block of code allows us to archive (save or load) the cell property object
in a cell-based simulation. The code consists of a serialize() method, in which we first
archive the cell property using the serialization code defined in the base class
<tt>AbstractCellProperty</tt>, then archive the member variable <tt>mColour</tt>.
</p>
<div class="code"><pre>    <span class="k">friend</span> <span class="k">class</span> <span class="nc">boost</span><span class="o">::</span>serialization<span class="o">::</span>access<span class="p">;</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Archive</span><span class="o">&gt;</span>
    <span class="kt">void</span> serialize<span class="p">(</span>Archive <span class="o">&amp;</span> archive<span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> version<span class="p">)</span>
    <span class="p">{</span>
        archive <span class="o">&amp;</span> boost<span class="o">::</span>serialization<span class="o">::</span>base_object<span class="o">&lt;</span>AbstractCellProperty<span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
        archive <span class="o">&amp;</span> mColour<span class="p">;</span>
    <span class="p">}</span>

<span class="nl">public:</span>

</pre></div><p>
The default constructor allows us to specify a value for the member variable <tt>mColour</tt>,
or leave it with a default value.
</p>
<div class="code"><pre>    MotileCellProperty<span class="p">(</span><span class="kt">unsigned</span> colour<span class="o">=</span><span class="mi">5</span><span class="p">)</span>
        <span class="o">:</span> AbstractCellProperty<span class="p">(),</span>
          mColour<span class="p">(</span>colour<span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

</pre></div><p>
We then define a destructor and a get method for the member variable <tt>mColour</tt>.
</p>
<div class="code"><pre>    <span class="o">~</span>MotileCellProperty<span class="p">()</span>
    <span class="p">{}</span>

    <span class="kt">unsigned</span> GetColour<span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> mColour<span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div><p>
This completes the code for <tt>MotileCellProperty</tt>.  Note that usually this code would
be separated out into a separate declaration in a .hpp file and definition in a .cpp file.
</p>
<h2 id="Definingthemotiveforceclass">Defining the motive force class</h2>
<p>
In order to illustrate the use of cell properties we make a simple force law which
causes all cells with the <tt>MotileCellProperty</tt> to move towards the origin. To do this we
create a new force class, <tt>MyMotiveForce</tt>, which inherits from
<tt>AbstractForce</tt> and overrides the methods <tt>AddForceContribution()</tt> and
<tt>OutputForceParameters()</tt>.
</p>
<p>
Note that usually this code would be separated out into a separate declaration
in a .hpp file and definition in a .cpp file.
</p>
<div class="code"><pre><span class="k">class</span> <span class="nc">MyMotiveForce</span> <span class="o">:</span> <span class="k">public</span> AbstractForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="nl">private:</span>

</pre></div><p>
This force class includes a member variable, <tt>mStrength</tt>, which
defines the strength of the force. This member variable will be set
in the constructor.
</p>
<div class="code"><pre>    <span class="kt">double</span> mStrength<span class="p">;</span>

</pre></div><p>
We only need to include the next block of code if we wish to be able
to archive (save or load) the force model object in a cell-based simulation.
The code consists of a serialize method, in which we first archive the force
using the serialization code defined in the base class <tt>AbstractForce</tt>,
then archive the member variable.
</p>
<div class="code"><pre>    <span class="k">friend</span> <span class="k">class</span> <span class="nc">boost</span><span class="o">::</span>serialization<span class="o">::</span>access<span class="p">;</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Archive</span><span class="o">&gt;</span>
    <span class="kt">void</span> serialize<span class="p">(</span>Archive <span class="o">&amp;</span> archive<span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> version<span class="p">)</span>
    <span class="p">{</span>
        archive <span class="o">&amp;</span> boost<span class="o">::</span>serialization<span class="o">::</span>base_object<span class="o">&lt;</span>AbstractForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
        archive <span class="o">&amp;</span> mStrength<span class="p">;</span>
    <span class="p">}</span>

<span class="nl">public:</span>
</pre></div><p>
The first public method is a default constructor, which calls the base
constructor. There is a single input argument, which defines the strength
of the force. We provide a default value of 2.0 for this argument. Inside
the method, we add an assertion to make sure that the strength is strictly
positive.
</p>
<div class="code"><pre>    MyMotiveForce<span class="p">(</span><span class="kt">double</span> strength<span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>
        <span class="o">:</span> AbstractForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(),</span>
          mStrength<span class="p">(</span>strength<span class="p">)</span>
    <span class="p">{</span>
        assert<span class="p">(</span>mStrength <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">);</span>
    <span class="p">}</span>

</pre></div><p>
The second public method overrides <tt>AddForceContribution()</tt>.
This method takes in one argument, a reference to the cell population itself.
</p>
<div class="code"><pre>    <span class="kt">void</span> <span class="nf">AddForceContribution</span><span class="p">(</span>AbstractCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;&amp;</span> rCellPopulation<span class="p">)</span>
    <span class="p">{</span>
</pre></div><p>
Inside the method, we loop over cells, and add a vector to
each node associated with cells with the <tt>MotileCellProperty</tt>, which is proportional (with constant <tt>mStrength</tt>) to the negative of the position. Causing
cells to move inwards towards the origin. Note that this will currently only work with subclasses of <tt>AbstractCentreBasedCellPopulation</tt>s as
we associate cells with nodes in the force calculation. However, this could easily be modified to make it work for <tt>VertexBasedCellPopulation</tt>s.
</p>
<div class="code"><pre>        <span class="k">for</span> <span class="p">(</span>AbstractCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>Iterator cell_iter <span class="o">=</span> rCellPopulation<span class="p">.</span>Begin<span class="p">();</span>
             cell_iter <span class="o">!=</span> rCellPopulation<span class="p">.</span>End<span class="p">();</span>
             <span class="o">++</span>cell_iter<span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span>cell_iter<span class="o">-&gt;</span>HasCellProperty<span class="o">&lt;</span>MotileCellProperty<span class="o">&gt;</span><span class="p">())</span>
            <span class="p">{</span>
                <span class="kt">unsigned</span> node_index <span class="o">=</span> rCellPopulation<span class="p">.</span>GetLocationIndexUsingCell<span class="p">(</span><span class="o">*</span>cell_iter<span class="p">);</span>

                c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> location <span class="o">=</span> rCellPopulation<span class="p">.</span>GetLocationOfCellCentre<span class="p">(</span><span class="o">*</span>cell_iter<span class="p">);</span>
                c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> force <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> mStrength <span class="o">*</span> location<span class="p">;</span>
                rCellPopulation<span class="p">.</span>GetNode<span class="p">(</span>node_index<span class="p">)</span><span class="o">-&gt;</span>AddAppliedForceContribution<span class="p">(</span>force<span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

</pre></div><p>
Just as we encountered in <a class="wiki" href="/chaste/tutorials/release_3.4/UserTutorials/CreatingAndUsingANewCellKiller.html">UserTutorials/CreatingAndUsingANewCellKiller</a>, here we must override
a method that outputs any member variables to a specified results file <tt>rParamsFile</tt>.
In our case, we output the member variable <tt>mStrength</tt>, then call the method on the base class.
</p>
<div class="code"><pre>    <span class="kt">void</span> <span class="nf">OutputForceParameters</span><span class="p">(</span>out_stream<span class="o">&amp;</span> rParamsFile<span class="p">)</span>
    <span class="p">{</span>
        <span class="o">*</span>rParamsFile <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\t\t\t</span><span class="s">&lt;Strength&gt;"</span> <span class="o">&lt;&lt;</span> mStrength <span class="o">&lt;&lt;</span> <span class="s">"&lt;/Strength&gt;</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        AbstractForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>OutputForceParameters<span class="p">(</span>rParamsFile<span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

</pre></div><p>
As mentioned in previous cell-based Chaste tutorials, we need to include the next block
of code to be able to archive the cell property and force objects in a cell-based simulation,
and to obtain a unique identifier for our new classes for when writing results to file.
</p>
<p>
Identifiers for both classes are defined together here, since we can only have each #include once
in this source file.  Normally the first include and export would go in the class' header, and the second
include and export in the .cpp file for each respective class.
</p>
<div class="code"><pre><span class="cp">#include "SerializationExportWrapper.hpp"
</span>CHASTE_CLASS_EXPORT<span class="p">(</span>MotileCellProperty<span class="p">)</span>
CHASTE_CLASS_EXPORT<span class="p">(</span>MyMotiveForce<span class="p">)</span>
<span class="cp">#include "SerializationExportWrapperForCpp.hpp"
</span>CHASTE_CLASS_EXPORT<span class="p">(</span>MotileCellProperty<span class="p">)</span>
CHASTE_CLASS_EXPORT<span class="p">(</span>MyMotiveForce<span class="p">)</span>

</pre></div><p>
This completes the code for <tt>MyMotiveForce</tt>. Note that usually this code
would be separated out into a separate declaration in a .hpp file and definition
in a .cpp file.
</p>
<h2 id="TheTests">The Tests</h2>
<p>
We now define the test class, which inherits from <tt>AbstractCellBasedTestSuite</tt>.
</p>
<div class="code"><pre><span class="k">class</span> <span class="nc">TestCreatingAndUsingANewCellPropertyTutorial</span> <span class="o">:</span> <span class="k">public</span> AbstractCellBasedTestSuite
<span class="p">{</span>
<span class="nl">public:</span>

</pre></div><h3 id="Testingthecellproperty">Testing the cell property</h3>
<p>
We begin by testing that our new cell property is implemented correctly.
</p>
<div class="code"><pre>    <span class="kt">void</span> <span class="nf">TestMotileCellProperty</span><span class="p">()</span> <span class="k">throw</span><span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
</pre></div><p>
We begin by testing that some of the base class methods work correctly.
We typically use shared pointers to create and access a cell property
like <tt>MotileCellProperty</tt>, for which it makes sense for all cells
that have the same mutation to share a pointer to the same cell property
object (although strictly speaking, they are not required to). Observe that
in this case we have provided a value for the member variable <tt>mColour</tt>
in the <tt>MotileCellProperty</tt> constructor.
</p>
<div class="code"><pre>        MAKE_PTR_ARGS<span class="p">(</span>MotileCellProperty<span class="p">,</span> p_property<span class="p">,</span> <span class="p">(</span><span class="mi">8</span><span class="p">));</span>

</pre></div><p>
Each cell property has a member variable, <tt>mCellCount</tt>, which
stores the number of cells with this cell property. We can test whether
<tt>mCellCount</tt> is being updated correctly by our cell property, as follows.
</p>
<div class="code"><pre>        TS_ASSERT_EQUALS<span class="p">(</span>p_property<span class="o">-&gt;</span>GetCellCount<span class="p">(),</span> <span class="mi">0u</span><span class="p">);</span>
        p_property<span class="o">-&gt;</span>IncrementCellCount<span class="p">();</span>
        TS_ASSERT_EQUALS<span class="p">(</span>p_property<span class="o">-&gt;</span>GetCellCount<span class="p">(),</span> <span class="mi">1u</span><span class="p">);</span>
        p_property<span class="o">-&gt;</span>DecrementCellCount<span class="p">();</span>
        TS_ASSERT_EQUALS<span class="p">(</span>p_property<span class="o">-&gt;</span>GetCellCount<span class="p">(),</span> <span class="mi">0u</span><span class="p">);</span>
        TS_ASSERT_THROWS_THIS<span class="p">(</span>p_property<span class="o">-&gt;</span>DecrementCellCount<span class="p">(),</span>
                <span class="s">"Cannot decrement cell count: no cells have this cell property"</span><span class="p">);</span>

</pre></div><p>
We can also test whether our cell property is of a given type, as follows.
</p>
<div class="code"><pre>        TS_ASSERT_EQUALS<span class="p">(</span>p_property<span class="o">-&gt;</span>IsType<span class="o">&lt;</span>WildTypeCellMutationState<span class="o">&gt;</span><span class="p">(),</span> <span class="nb">false</span><span class="p">);</span>
        TS_ASSERT_EQUALS<span class="p">(</span>p_property<span class="o">-&gt;</span>IsType<span class="o">&lt;</span>MotileCellProperty<span class="o">&gt;</span><span class="p">(),</span> <span class="nb">true</span><span class="p">);</span>

</pre></div><p>
We can also test that archiving is implemented correctly for our cell
property, as follows (further details on how to implement and
test archiving can be found at <a class="wiki" href="/chaste/tutorials/release_3.4/ChasteGuides/BoostSerialization.html">ChasteGuides/BoostSerialization</a>).
</p>
<div class="code"><pre>        OutputFileHandler <span class="nf">handler</span><span class="p">(</span><span class="s">"archive"</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
        std<span class="o">::</span>string archive_filename <span class="o">=</span> handler<span class="p">.</span>GetOutputDirectoryFullPath<span class="p">()</span> <span class="o">+</span> <span class="s">"property.arch"</span><span class="p">;</span>

        <span class="p">{</span>
            AbstractCellProperty<span class="o">*</span> <span class="k">const</span> p_const_property <span class="o">=</span> <span class="k">new</span> MotileCellProperty<span class="p">(</span><span class="mi">7</span><span class="p">);</span>
            p_const_property<span class="o">-&gt;</span>IncrementCellCount<span class="p">();</span>

            TS_ASSERT_EQUALS<span class="p">(</span>p_const_property<span class="o">-&gt;</span>GetCellCount<span class="p">(),</span> <span class="mi">1u</span><span class="p">);</span>
            TS_ASSERT_EQUALS<span class="p">(</span><span class="k">dynamic_cast</span><span class="o">&lt;</span>MotileCellProperty<span class="o">*&gt;</span><span class="p">(</span>p_const_property<span class="p">)</span><span class="o">-&gt;</span>GetColour<span class="p">(),</span> <span class="mi">7u</span><span class="p">);</span>

            std<span class="o">::</span>ofstream ofs<span class="p">(</span>archive_filename<span class="p">.</span>c_str<span class="p">());</span>
            boost<span class="o">::</span>archive<span class="o">::</span>text_oarchive output_arch<span class="p">(</span>ofs<span class="p">);</span>

            output_arch <span class="o">&lt;&lt;</span> p_const_property<span class="p">;</span>

            <span class="k">delete</span> p_const_property<span class="p">;</span>
        <span class="p">}</span>

        <span class="p">{</span>
            AbstractCellProperty<span class="o">*</span> p_arch_property<span class="p">;</span>

            std<span class="o">::</span>ifstream ifs<span class="p">(</span>archive_filename<span class="p">.</span>c_str<span class="p">());</span>
            boost<span class="o">::</span>archive<span class="o">::</span>text_iarchive input_arch<span class="p">(</span>ifs<span class="p">);</span>

            input_arch <span class="o">&gt;&gt;</span> p_arch_property<span class="p">;</span>

            TS_ASSERT_EQUALS<span class="p">(</span>p_arch_property<span class="o">-&gt;</span>GetCellCount<span class="p">(),</span> <span class="mi">1u</span><span class="p">);</span>

            MotileCellProperty<span class="o">*</span> p_real_property <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span>MotileCellProperty<span class="o">*&gt;</span><span class="p">(</span>p_arch_property<span class="p">);</span>
            TS_ASSERT<span class="p">(</span>p_real_property <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
            TS_ASSERT_EQUALS<span class="p">(</span>p_real_property<span class="o">-&gt;</span>GetColour<span class="p">(),</span> <span class="mi">7u</span><span class="p">);</span>

            <span class="k">delete</span> p_arch_property<span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

</pre></div><h3 id="Usingthecellpropertyinacell-basedsimulation">Using the cell property in a cell-based simulation</h3>
<p>
We conclude with a brief test demonstrating how <tt>MotileCellProperty</tt> can be used
in a cell-based simulation.
</p>
<div class="code"><pre>    <span class="kt">void</span> <span class="nf">TestOffLatticeSimulationWithMotileCellProperty</span><span class="p">()</span> <span class="k">throw</span><span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
</pre></div><p>
Note that <a class="missing wiki" href="/chaste/tutorials/release_3.4/UserTutorials/HoneycombMeshGenerator.html" rel="nofollow">HoneycombMeshGenerator?</a>, used in this test, is not
yet implemented in parallel.
</p>
<p>
We use the <tt>HoneycombMeshGenerator</tt> to create a honeycomb mesh covering a
circular domain of given radius, and use this to generate a <tt>NodesOnlyMesh</tt>
as follows.
</p>
<div class="code"><pre>        HoneycombMeshGenerator <span class="nf">generator</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
        MutableMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> p_generating_mesh <span class="o">=</span> generator<span class="p">.</span>GetCircularMesh<span class="p">(</span><span class="mi">5</span><span class="p">);</span>

        NodesOnlyMesh<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> mesh<span class="p">;</span>
</pre></div><p>
We construct the mesh using the generating mesh and a cut-off 1.5 which defines the
connectivity in the mesh.
</p>
<div class="code"><pre>        mesh<span class="p">.</span>ConstructNodesWithoutMesh<span class="p">(</span><span class="o">*</span>p_generating_mesh<span class="p">,</span> <span class="mf">1.5</span><span class="p">);</span>

</pre></div><p>
We now create a shared pointer to our new property, as follows.
</p>
<div class="code"><pre>        MAKE_PTR<span class="p">(</span>MotileCellProperty<span class="p">,</span> p_motile<span class="p">);</span>
</pre></div><p>
Also create a shared pointer to a cell label so we can visualize the
different cell types. Note that this is also a <tt>CellProperty</tt>.
</p>
<div class="code"><pre>        MAKE_PTR<span class="p">(</span>CellLabel<span class="p">,</span> p_label<span class="p">);</span>

</pre></div><p>
Next, we create some cells. We don't use a Generator as we want to give some cells the new cell property, therefore
we create the cells in a loop, as follows.
</p>
<div class="code"><pre>        MAKE_PTR<span class="p">(</span>WildTypeCellMutationState<span class="p">,</span> p_state<span class="p">);</span>
        MAKE_PTR<span class="p">(</span>DifferentiatedCellProliferativeType<span class="p">,</span> p_diff_type<span class="p">);</span>
        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> i<span class="o">=</span><span class="mi">0</span><span class="p">;</span> i<span class="o">&lt;</span>mesh<span class="p">.</span>GetNumNodes<span class="p">();</span> i<span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
</pre></div><p>
For each node we create a cell with our cell-cycle model and the wild-type cell mutation state.
We then add the property <tt>MotileCellProperty</tt> to a random selection of the cells, as follows.
</p>
<div class="code"><pre>            FixedDurationGenerationBasedCellCycleModel<span class="o">*</span> p_model <span class="o">=</span> <span class="k">new</span> FixedDurationGenerationBasedCellCycleModel<span class="p">();</span>

            CellPropertyCollection collection<span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span>RandomNumberGenerator<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>ranf<span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.2</span><span class="p">)</span>
            <span class="p">{</span>
                collection<span class="p">.</span>AddProperty<span class="p">(</span>p_motile<span class="p">);</span>
                collection<span class="p">.</span>AddProperty<span class="p">(</span>p_label<span class="p">);</span>
            <span class="p">}</span>

            CellPtr p_cell<span class="p">(</span><span class="k">new</span> Cell<span class="p">(</span>p_state<span class="p">,</span> p_model<span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> collection<span class="p">));</span>
            p_cell<span class="o">-&gt;</span>SetCellProliferativeType<span class="p">(</span>p_diff_type<span class="p">);</span>

</pre></div><p>
Now, we define a random birth time, chosen from [-T,0], where
T = t<sub>1</sub> + t<sub>2</sub>, where t<sub>1</sub> is a parameter representing the G<sub>1</sub> duration
of a stem cell, and t<sub>2</sub> is the basic S+G<sub>2</sub>+M phases duration.
</p>
<div class="code"><pre>            <span class="kt">double</span> birth_time <span class="o">=</span> <span class="o">-</span> RandomNumberGenerator<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>ranf<span class="p">()</span> <span class="o">*</span>
                                    <span class="p">(</span>p_model<span class="o">-&gt;</span>GetStemCellG1Duration<span class="p">()</span>
                                        <span class="o">+</span> p_model<span class="o">-&gt;</span>GetSG2MDuration<span class="p">());</span>

</pre></div><p>
Finally, we set the birth time and push the cell back into the vector of cells.
</p>
<div class="code"><pre>            p_cell<span class="o">-&gt;</span>SetBirthTime<span class="p">(</span>birth_time<span class="p">);</span>
            cells<span class="p">.</span>push_back<span class="p">(</span>p_cell<span class="p">);</span>
        <span class="p">}</span>

</pre></div><p>
Now that we have defined the mesh and cells, we can define the cell population. The constructor
takes in the mesh and the cells vector.
</p>
<div class="code"><pre>        NodeBasedCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span>mesh<span class="p">,</span> cells<span class="p">);</span>

</pre></div><p>
In order to visualize labelled cells we need to use the following command.
</p>
<div class="code"><pre>        cell_population<span class="p">.</span>AddCellPopulationCountWriter<span class="o">&lt;</span>CellMutationStatesCountWriter<span class="o">&gt;</span><span class="p">();</span>

</pre></div><p>
We then pass in the cell population into an <tt>OffLatticeSimulation</tt>,
and set the output directory, output multiple, and end time.
</p>
<div class="code"><pre>        OffLatticeSimulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> simulator<span class="p">(</span>cell_population<span class="p">);</span>
        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"TestOffLatticeSimulationWithMotileCellProperty"</span><span class="p">);</span>
        simulator<span class="p">.</span>SetSamplingTimestepMultiple<span class="p">(</span><span class="mi">12</span><span class="p">);</span>
        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mf">10.0</span><span class="p">);</span>

</pre></div><p>
We create a force law and pass it to the <tt>OffLatticeSimulation</tt>.
</p>
<div class="code"><pre>        MAKE_PTR<span class="p">(</span>GeneralisedLinearSpringForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_linear_force<span class="p">);</span>
        p_linear_force<span class="o">-&gt;</span>SetCutOffLength<span class="p">(</span><span class="mf">1.5</span><span class="p">);</span>
        simulator<span class="p">.</span>AddForce<span class="p">(</span>p_linear_force<span class="p">);</span>

</pre></div><p>
Now create a <tt>MotlieForce</tt> and pass it to the <tt>OffLatticeSimulation</tt>.
</p>
<div class="code"><pre>        MAKE_PTR<span class="p">(</span>MyMotiveForce<span class="p">,</span> p_motive_force<span class="p">);</span>
        simulator<span class="p">.</span>AddForce<span class="p">(</span>p_motive_force<span class="p">);</span>

</pre></div><p>
To run the simulation, we call <tt>Solve()</tt>.
</p>
<div class="code"><pre>        simulator<span class="p">.</span>Solve<span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div><p>
When you visualize the results with
</p>
<p>
<tt>java Visualize2dCentreCells /tmp/$USER/testoutput/TestOffLatticeSimulationWithMotileCellProperty/results_from_time_0</tt>
</p>
<p>
you should see a collection of cells with the <tt>MotileCellProperty</tt> (labelled dark blue) moving towards the origin.
</p>
<h1 id="Code">Code</h1>
<p>
The full code is given below
</p>
<h2 id="FilenameTestCreatingAndUsingANewCellPropertyTutorial.hpp">File name <tt>TestCreatingAndUsingANewCellPropertyTutorial.hpp</tt></h2>
<div class="code"><pre><span class="cp">#include &lt;cxxtest/TestSuite.h&gt;
#include "CheckpointArchiveTypes.hpp"
#include "AbstractCellBasedTestSuite.hpp"
</span>
<span class="cp">#include "AbstractCellProperty.hpp"
#include "AbstractForce.hpp"
#include "HoneycombMeshGenerator.hpp"
#include "NodesOnlyMesh.hpp"
#include "WildTypeCellMutationState.hpp"
#include "DifferentiatedCellProliferativeType.hpp"
#include "FixedDurationGenerationBasedCellCycleModel.hpp"
#include "GeneralisedLinearSpringForce.hpp"
#include "CellMutationStatesCountWriter.hpp"
#include "OffLatticeSimulation.hpp"
#include "SmartPointers.hpp"
</span><span class="c1">//This test is always run sequentially (never in parallel)
</span><span class="cp">#include "FakePetscSetup.hpp"
</span>
<span class="k">class</span> <span class="nc">MotileCellProperty</span> <span class="o">:</span> <span class="k">public</span> AbstractCellProperty
<span class="p">{</span>
<span class="nl">private:</span>

    <span class="kt">unsigned</span> mColour<span class="p">;</span>

    <span class="k">friend</span> <span class="k">class</span> <span class="nc">boost</span><span class="o">::</span>serialization<span class="o">::</span>access<span class="p">;</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Archive</span><span class="o">&gt;</span>
    <span class="kt">void</span> serialize<span class="p">(</span>Archive <span class="o">&amp;</span> archive<span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> version<span class="p">)</span>
    <span class="p">{</span>
        archive <span class="o">&amp;</span> boost<span class="o">::</span>serialization<span class="o">::</span>base_object<span class="o">&lt;</span>AbstractCellProperty<span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
        archive <span class="o">&amp;</span> mColour<span class="p">;</span>
    <span class="p">}</span>

<span class="nl">public:</span>

    MotileCellProperty<span class="p">(</span><span class="kt">unsigned</span> colour<span class="o">=</span><span class="mi">5</span><span class="p">)</span>
        <span class="o">:</span> AbstractCellProperty<span class="p">(),</span>
          mColour<span class="p">(</span>colour<span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="o">~</span>MotileCellProperty<span class="p">()</span>
    <span class="p">{}</span>

    <span class="kt">unsigned</span> GetColour<span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> mColour<span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">MyMotiveForce</span> <span class="o">:</span> <span class="k">public</span> AbstractForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="nl">private:</span>

    <span class="kt">double</span> mStrength<span class="p">;</span>

    <span class="k">friend</span> <span class="k">class</span> <span class="nc">boost</span><span class="o">::</span>serialization<span class="o">::</span>access<span class="p">;</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Archive</span><span class="o">&gt;</span>
    <span class="kt">void</span> serialize<span class="p">(</span>Archive <span class="o">&amp;</span> archive<span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> version<span class="p">)</span>
    <span class="p">{</span>
        archive <span class="o">&amp;</span> boost<span class="o">::</span>serialization<span class="o">::</span>base_object<span class="o">&lt;</span>AbstractForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
        archive <span class="o">&amp;</span> mStrength<span class="p">;</span>
    <span class="p">}</span>

<span class="nl">public:</span>
    MyMotiveForce<span class="p">(</span><span class="kt">double</span> strength<span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>
        <span class="o">:</span> AbstractForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(),</span>
          mStrength<span class="p">(</span>strength<span class="p">)</span>
    <span class="p">{</span>
        assert<span class="p">(</span>mStrength <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> AddForceContribution<span class="p">(</span>AbstractCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;&amp;</span> rCellPopulation<span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span>AbstractCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>Iterator cell_iter <span class="o">=</span> rCellPopulation<span class="p">.</span>Begin<span class="p">();</span>
             cell_iter <span class="o">!=</span> rCellPopulation<span class="p">.</span>End<span class="p">();</span>
             <span class="o">++</span>cell_iter<span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span>cell_iter<span class="o">-&gt;</span>HasCellProperty<span class="o">&lt;</span>MotileCellProperty<span class="o">&gt;</span><span class="p">())</span>
            <span class="p">{</span>
                <span class="kt">unsigned</span> node_index <span class="o">=</span> rCellPopulation<span class="p">.</span>GetLocationIndexUsingCell<span class="p">(</span><span class="o">*</span>cell_iter<span class="p">);</span>

                c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> location <span class="o">=</span> rCellPopulation<span class="p">.</span>GetLocationOfCellCentre<span class="p">(</span><span class="o">*</span>cell_iter<span class="p">);</span>
                c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> force <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> mStrength <span class="o">*</span> location<span class="p">;</span>
                rCellPopulation<span class="p">.</span>GetNode<span class="p">(</span>node_index<span class="p">)</span><span class="o">-&gt;</span>AddAppliedForceContribution<span class="p">(</span>force<span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> OutputForceParameters<span class="p">(</span>out_stream<span class="o">&amp;</span> rParamsFile<span class="p">)</span>
    <span class="p">{</span>
        <span class="o">*</span>rParamsFile <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\t\t\t</span><span class="s">&lt;Strength&gt;"</span> <span class="o">&lt;&lt;</span> mStrength <span class="o">&lt;&lt;</span> <span class="s">"&lt;/Strength&gt;</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        AbstractForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>OutputForceParameters<span class="p">(</span>rParamsFile<span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="cp">#include "SerializationExportWrapper.hpp"
</span>CHASTE_CLASS_EXPORT<span class="p">(</span>MotileCellProperty<span class="p">)</span>
CHASTE_CLASS_EXPORT<span class="p">(</span>MyMotiveForce<span class="p">)</span>
<span class="cp">#include "SerializationExportWrapperForCpp.hpp"
</span>CHASTE_CLASS_EXPORT<span class="p">(</span>MotileCellProperty<span class="p">)</span>
CHASTE_CLASS_EXPORT<span class="p">(</span>MyMotiveForce<span class="p">)</span>

<span class="k">class</span> <span class="nc">TestCreatingAndUsingANewCellPropertyTutorial</span> <span class="o">:</span> <span class="k">public</span> AbstractCellBasedTestSuite
<span class="p">{</span>
<span class="nl">public:</span>

    <span class="kt">void</span> TestMotileCellProperty<span class="p">()</span> <span class="k">throw</span><span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
        MAKE_PTR_ARGS<span class="p">(</span>MotileCellProperty<span class="p">,</span> p_property<span class="p">,</span> <span class="p">(</span><span class="mi">8</span><span class="p">));</span>

        TS_ASSERT_EQUALS<span class="p">(</span>p_property<span class="o">-&gt;</span>GetCellCount<span class="p">(),</span> <span class="mi">0u</span><span class="p">);</span>
        p_property<span class="o">-&gt;</span>IncrementCellCount<span class="p">();</span>
        TS_ASSERT_EQUALS<span class="p">(</span>p_property<span class="o">-&gt;</span>GetCellCount<span class="p">(),</span> <span class="mi">1u</span><span class="p">);</span>
        p_property<span class="o">-&gt;</span>DecrementCellCount<span class="p">();</span>
        TS_ASSERT_EQUALS<span class="p">(</span>p_property<span class="o">-&gt;</span>GetCellCount<span class="p">(),</span> <span class="mi">0u</span><span class="p">);</span>
        TS_ASSERT_THROWS_THIS<span class="p">(</span>p_property<span class="o">-&gt;</span>DecrementCellCount<span class="p">(),</span>
                <span class="s">"Cannot decrement cell count: no cells have this cell property"</span><span class="p">);</span>

        TS_ASSERT_EQUALS<span class="p">(</span>p_property<span class="o">-&gt;</span>IsType<span class="o">&lt;</span>WildTypeCellMutationState<span class="o">&gt;</span><span class="p">(),</span> <span class="nb">false</span><span class="p">);</span>
        TS_ASSERT_EQUALS<span class="p">(</span>p_property<span class="o">-&gt;</span>IsType<span class="o">&lt;</span>MotileCellProperty<span class="o">&gt;</span><span class="p">(),</span> <span class="nb">true</span><span class="p">);</span>

        OutputFileHandler <span class="nf">handler</span><span class="p">(</span><span class="s">"archive"</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
        std<span class="o">::</span>string archive_filename <span class="o">=</span> handler<span class="p">.</span>GetOutputDirectoryFullPath<span class="p">()</span> <span class="o">+</span> <span class="s">"property.arch"</span><span class="p">;</span>

        <span class="p">{</span>
            AbstractCellProperty<span class="o">*</span> <span class="k">const</span> p_const_property <span class="o">=</span> <span class="k">new</span> MotileCellProperty<span class="p">(</span><span class="mi">7</span><span class="p">);</span>
            p_const_property<span class="o">-&gt;</span>IncrementCellCount<span class="p">();</span>

            TS_ASSERT_EQUALS<span class="p">(</span>p_const_property<span class="o">-&gt;</span>GetCellCount<span class="p">(),</span> <span class="mi">1u</span><span class="p">);</span>
            TS_ASSERT_EQUALS<span class="p">(</span><span class="k">dynamic_cast</span><span class="o">&lt;</span>MotileCellProperty<span class="o">*&gt;</span><span class="p">(</span>p_const_property<span class="p">)</span><span class="o">-&gt;</span>GetColour<span class="p">(),</span> <span class="mi">7u</span><span class="p">);</span>

            std<span class="o">::</span>ofstream ofs<span class="p">(</span>archive_filename<span class="p">.</span>c_str<span class="p">());</span>
            boost<span class="o">::</span>archive<span class="o">::</span>text_oarchive output_arch<span class="p">(</span>ofs<span class="p">);</span>

            output_arch <span class="o">&lt;&lt;</span> p_const_property<span class="p">;</span>

            <span class="k">delete</span> p_const_property<span class="p">;</span>
        <span class="p">}</span>

        <span class="p">{</span>
            AbstractCellProperty<span class="o">*</span> p_arch_property<span class="p">;</span>

            std<span class="o">::</span>ifstream ifs<span class="p">(</span>archive_filename<span class="p">.</span>c_str<span class="p">());</span>
            boost<span class="o">::</span>archive<span class="o">::</span>text_iarchive input_arch<span class="p">(</span>ifs<span class="p">);</span>

            input_arch <span class="o">&gt;&gt;</span> p_arch_property<span class="p">;</span>

            TS_ASSERT_EQUALS<span class="p">(</span>p_arch_property<span class="o">-&gt;</span>GetCellCount<span class="p">(),</span> <span class="mi">1u</span><span class="p">);</span>

            MotileCellProperty<span class="o">*</span> p_real_property <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span>MotileCellProperty<span class="o">*&gt;</span><span class="p">(</span>p_arch_property<span class="p">);</span>
            TS_ASSERT<span class="p">(</span>p_real_property <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
            TS_ASSERT_EQUALS<span class="p">(</span>p_real_property<span class="o">-&gt;</span>GetColour<span class="p">(),</span> <span class="mi">7u</span><span class="p">);</span>

            <span class="k">delete</span> p_arch_property<span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> TestOffLatticeSimulationWithMotileCellProperty<span class="p">()</span> <span class="k">throw</span><span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
        HoneycombMeshGenerator generator<span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
        MutableMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> p_generating_mesh <span class="o">=</span> generator<span class="p">.</span>GetCircularMesh<span class="p">(</span><span class="mi">5</span><span class="p">);</span>

        NodesOnlyMesh<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> mesh<span class="p">;</span>
        mesh<span class="p">.</span>ConstructNodesWithoutMesh<span class="p">(</span><span class="o">*</span>p_generating_mesh<span class="p">,</span> <span class="mf">1.5</span><span class="p">);</span>

        MAKE_PTR<span class="p">(</span>MotileCellProperty<span class="p">,</span> p_motile<span class="p">);</span>
        MAKE_PTR<span class="p">(</span>CellLabel<span class="p">,</span> p_label<span class="p">);</span>

        MAKE_PTR<span class="p">(</span>WildTypeCellMutationState<span class="p">,</span> p_state<span class="p">);</span>
        MAKE_PTR<span class="p">(</span>DifferentiatedCellProliferativeType<span class="p">,</span> p_diff_type<span class="p">);</span>
        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> i<span class="o">=</span><span class="mi">0</span><span class="p">;</span> i<span class="o">&lt;</span>mesh<span class="p">.</span>GetNumNodes<span class="p">();</span> i<span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            FixedDurationGenerationBasedCellCycleModel<span class="o">*</span> p_model <span class="o">=</span> <span class="k">new</span> FixedDurationGenerationBasedCellCycleModel<span class="p">();</span>

            CellPropertyCollection collection<span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span>RandomNumberGenerator<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>ranf<span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.2</span><span class="p">)</span>
            <span class="p">{</span>
                collection<span class="p">.</span>AddProperty<span class="p">(</span>p_motile<span class="p">);</span>
                collection<span class="p">.</span>AddProperty<span class="p">(</span>p_label<span class="p">);</span>
            <span class="p">}</span>

            CellPtr p_cell<span class="p">(</span><span class="k">new</span> Cell<span class="p">(</span>p_state<span class="p">,</span> p_model<span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> collection<span class="p">));</span>
            p_cell<span class="o">-&gt;</span>SetCellProliferativeType<span class="p">(</span>p_diff_type<span class="p">);</span>

            <span class="kt">double</span> birth_time <span class="o">=</span> <span class="o">-</span> RandomNumberGenerator<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>ranf<span class="p">()</span> <span class="o">*</span>
                                    <span class="p">(</span>p_model<span class="o">-&gt;</span>GetStemCellG1Duration<span class="p">()</span>
                                        <span class="o">+</span> p_model<span class="o">-&gt;</span>GetSG2MDuration<span class="p">());</span>

            p_cell<span class="o">-&gt;</span>SetBirthTime<span class="p">(</span>birth_time<span class="p">);</span>
            cells<span class="p">.</span>push_back<span class="p">(</span>p_cell<span class="p">);</span>
        <span class="p">}</span>

        NodeBasedCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span>mesh<span class="p">,</span> cells<span class="p">);</span>

        cell_population<span class="p">.</span>AddCellPopulationCountWriter<span class="o">&lt;</span>CellMutationStatesCountWriter<span class="o">&gt;</span><span class="p">();</span>

        OffLatticeSimulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> simulator<span class="p">(</span>cell_population<span class="p">);</span>
        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"TestOffLatticeSimulationWithMotileCellProperty"</span><span class="p">);</span>
        simulator<span class="p">.</span>SetSamplingTimestepMultiple<span class="p">(</span><span class="mi">12</span><span class="p">);</span>
        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mf">10.0</span><span class="p">);</span>

        MAKE_PTR<span class="p">(</span>GeneralisedLinearSpringForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_linear_force<span class="p">);</span>
        p_linear_force<span class="o">-&gt;</span>SetCutOffLength<span class="p">(</span><span class="mf">1.5</span><span class="p">);</span>
        simulator<span class="p">.</span>AddForce<span class="p">(</span>p_linear_force<span class="p">);</span>

        MAKE_PTR<span class="p">(</span>MyMotiveForce<span class="p">,</span> p_motive_force<span class="p">);</span>
        simulator<span class="p">.</span>AddForce<span class="p">(</span>p_motive_force<span class="p">);</span>

        simulator<span class="p">.</span>Solve<span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div></div>
          

    </div>
  </body>
</html>
