<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>UserTutorials/SolvingLinearPdes - Chaste</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="https://chaste.github.io/old_releases/trac.css" type="text/css" />
    <link rel="stylesheet" href="https://chaste.github.io/old_releases/wiki.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="https://chaste.github.io/old_releases/site.css" />
  </head>
  <body>
    <div id="banner">
      <div id="header">
        <p>
          <a id="logo" href="https://chaste.github.io/"><img src="https://chaste.github.io/chaste_0256.png" alt="Chaste logo" height="60" /></a>
          <em>Documentation for <a href="https://chaste.github.io/old_releases/release_3.4/">Release 3.4</a>.</em>
        </p>
      </div>
    </div>
    <p>&nbsp;</p>
    <div id="content" class="wiki">
      <div class="wikipage searchable">
        
          <div id="wikipage" class="trac-content"><p>
This tutorial is automatically generated from the file trunk/pde/test/tutorials/TestSolvingLinearPdesTutorial.hpp at revision <a class="missing changeset" title="No permission to view changeset 25790 on (default)">r25790</a>.
Note that the code is given in full at the bottom of the page.
</p>
<h1 id="ExamplesshowinghowtosolvelinearellipticandparabolicPDEs">Examples showing how to solve linear elliptic and parabolic PDEs</h1>
<p>
In this tutorial we show how Chaste can be used to solve linear PDEs. The first test
uses the <tt>SimpleLinearEllipticSolver</tt> to solve a linear elliptic PDE, and the
second test uses the <tt>SimpleLinearParabolicSolver</tt> to solve a parabolic time-dependent
linear PDE.
</p>
<p>
The following header files need to be included.
First we include the header needed to define this class as a test suite
</p>
<div class="code"><pre><span class="cp">#include &lt;cxxtest/TestSuite.h&gt;
</span></pre></div><p>
On some systems (with Boost 1.33.1 and PETSc 2.2) there is a clash between Boost Ublas includes and PETSc.  This can be
resolved by making sure that Chaste's interface to the Ublas library is included as early as possible.
</p>
<div class="code"><pre><span class="cp">#include "UblasIncludes.hpp"
</span></pre></div><p>
This is the class that is needed to solve a linear elliptic PDE.
</p>
<div class="code"><pre><span class="cp">#include "SimpleLinearEllipticSolver.hpp"
</span></pre></div><p>
This is the class that is needed to solve a linear parabolic PDE.
</p>
<div class="code"><pre><span class="cp">#include "SimpleLinearParabolicSolver.hpp"
</span></pre></div><p>
This is a parabolic PDE, one of the PDEs we will solve.
</p>
<div class="code"><pre><span class="cp">#include "HeatEquationWithSourceTerm.hpp"
</span></pre></div><p>
We will also solve this PDE.
</p>
<div class="code"><pre><span class="cp">#include "SimplePoissonEquation.hpp"
</span></pre></div><p>
This is needed to read mesh datafiles of the 'Triangles' format.
</p>
<div class="code"><pre><span class="cp">#include "TrianglesMeshReader.hpp"
</span></pre></div><p>
This class represents the mesh internally.
</p>
<div class="code"><pre><span class="cp">#include "TetrahedralMesh.hpp"
</span></pre></div><p>
These are used to specify boundary conditions for the PDEs.
</p>
<div class="code"><pre><span class="cp">#include "BoundaryConditionsContainer.hpp"
#include "ConstBoundaryCondition.hpp"
</span></pre></div><p>
This class helps us deal with output files.
</p>
<div class="code"><pre><span class="cp">#include "OutputFileHandler.hpp"
</span></pre></div><p>
The following header must be included in every test that uses PETSc. Note that it
cannot be included in the source code.
</p>
<div class="code"><pre><span class="cp">#include "PetscSetupAndFinalize.hpp"
</span>
</pre></div><h2 id="Test1:SolvingalinearellipticPDE">Test 1: Solving a linear elliptic PDE</h2>
<p>
Here, we solve the PDE: div(D grad u) + u + x<sup>2</sup>+y<sup>2</sup> = 0, in 2D, where
D is the diffusion tensor (2 0; 0 1) (ie D11=2, D12=D21=0, D22=1), on a square
domain, with boundary conditions u=0 on x=0 or y=0, and (D grad u).n = 0 on x=1 and y=1,
where n is the surface normal.
</p>
<p>
We need to create a class representing the PDE we want to solve, which will be
passed into the solver. The PDE we are solving is of the type
<tt>AbstractLinearEllipticPde</tt>, which is an abstract class with 3 pure methods
which have to be implemented. The template variables in the following line are both the dimension
of the space.
</p>
<div class="code"><pre><span class="k">class</span> <span class="nc">MyPde</span> <span class="o">:</span> <span class="k">public</span> AbstractLinearEllipticPde<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="nl">private:</span>
</pre></div><p>
For efficiency, we will save the diffusion tensor that will be returned by one of the
class' methods as a member variable. The diffusion tensor which has to be returned
by the <tt>GetDiffusionTensor</tt> method in PDE classes is of the type
<tt>c_matrix&lt;double,SIZE,SIZE&gt;</tt>, which is a u-blas matrix. We use ublas vectors
and matrices where small vectors and matrices are needed. Note that ublas objects
are only particularly efficient if optimisation is on (<tt>scons build=GccOpt ...</tt>).
</p>
<div class="code"><pre>    c_matrix<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> mDiffusionTensor<span class="p">;</span>

<span class="nl">public:</span>
</pre></div><p>
The constructor just sets up the diffusion tensor. We choose a diffusion tensor which
corresponds to twice as much diffusion in the x-direction compared to the y-direction
</p>
<div class="code"><pre>    MyPde<span class="p">()</span>
    <span class="p">{</span>
        mDiffusionTensor<span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">;</span>
        mDiffusionTensor<span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
        mDiffusionTensor<span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
        mDiffusionTensor<span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
    <span class="p">}</span>

</pre></div><p>
The first method which has to be implemented returns the constant
(not dependent on u) part of the source term, which for our PDE is
x<sup>2</sup> + y<sup>2</sup>.
</p>
<div class="code"><pre>    <span class="kt">double</span> <span class="nf">ComputeConstantInUSourceTerm</span><span class="p">(</span><span class="k">const</span> ChastePoint<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;&amp;</span> rX<span class="p">,</span> Element<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> pElement<span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> rX<span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span>rX<span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> rX<span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span>rX<span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>

</pre></div><p>
The second method which has to be implemented returns the coefficient in the linear-in-u
part of the source term, which for our PDE is just 1.0.
</p>
<div class="code"><pre>    <span class="kt">double</span> <span class="nf">ComputeLinearInUCoeffInSourceTerm</span><span class="p">(</span><span class="k">const</span> ChastePoint<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;&amp;</span> rX<span class="p">,</span> Element<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> pElement<span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mf">1.0</span><span class="p">;</span>
    <span class="p">}</span>

</pre></div><p>
The third method returns the diffusion tensor D. Note that the diffusion tensor should
be symmetric and positive definite for a physical, well-posed problem.
</p>
<div class="code"><pre>    c_matrix<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> ComputeDiffusionTerm<span class="p">(</span><span class="k">const</span> ChastePoint<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;&amp;</span> rX<span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> mDiffusionTensor<span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

</pre></div><p>
Next, we define the test suite (a class). It is sensible to name it the same
as the filename. The class should inherit from <tt>CxxTest::TestSuite</tt>.
</p>
<div class="code"><pre><span class="k">class</span> <span class="nc">TestSolvingLinearPdesTutorial</span> <span class="o">:</span> <span class="k">public</span> CxxTest<span class="o">::</span>TestSuite
<span class="p">{</span>
</pre></div><p>
All individual test defined in this test suite <strong>must</strong> be declared as public.
</p>
<div class="code"><pre><span class="nl">public:</span>
    <span class="kt">void</span> <span class="nf">TestSolvingEllipticPde</span><span class="p">()</span> <span class="k">throw</span><span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
</pre></div><p>
First we declare a mesh reader which reads mesh data files of the 'Triangle'
format. The path given is relative to the main Chaste directory. As we are in 2d,
the reader will look for three datafiles, [name].nodes, [name].ele and [name].edge.
Note that the first template argument here is the spatial dimension of the
elements in the mesh (<tt>ELEMENT_DIM</tt>), and the second is the dimension of the nodes,
i.e. the dimension of the space the mesh lives in (<tt>SPACE_DIM</tt>). Usually
<tt>ELEMENT_DIM</tt> and <tt>SPACE_DIM</tt> will be equal.
</p>
<div class="code"><pre>        TrianglesMeshReader<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> mesh_reader<span class="p">(</span><span class="s">"mesh/test/data/square_128_elements"</span><span class="p">);</span>
</pre></div><p>
Now declare a tetrahedral mesh with the same dimensions...
</p>
<div class="code"><pre>        TetrahedralMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> mesh<span class="p">;</span>
</pre></div><p>
... and construct the mesh using the mesh reader.
</p>
<div class="code"><pre>        mesh<span class="p">.</span>ConstructFromMeshReader<span class="p">(</span>mesh_reader<span class="p">);</span>

</pre></div><p>
Next we instantiate an instance of our PDE we wish to solve.
</p>
<div class="code"><pre>        MyPde pde<span class="p">;</span>

</pre></div><p>
A set of boundary conditions are stored in a <tt>BoundaryConditionsContainer</tt>. The
three template arguments are ELEMENT_DIM, SPACE_DIM and PROBLEM_DIM, the latter being
the number of unknowns we are solving for. We have one unknown (ie u is a scalar, not
a vector), so in this case <tt>PROBLEM_DIM</tt>=1.
</p>
<div class="code"><pre>        BoundaryConditionsContainer<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span> bcc<span class="p">;</span>

</pre></div><p>
Defining the boundary conditions is the only particularly fiddly part of solving PDEs,
unless they are very simple, such as u=0 on the boundary, which could be done
as follows:
</p>
<div class="code"><pre>        <span class="c1">//bcc.DefineZeroDirichletOnMeshBoundary(&amp;mesh);
</span>
</pre></div><p>
We want to specify u=0 on x=0 and y=0.  To do this, we first create the boundary condition
object saying what the value of the condition is at any particular point in space.  Here
we use the class <tt>ConstBoundaryCondition</tt>, a subclass of <tt>AbstractBoundaryCondition</tt> that
yields the same constant value (0.0 here) everywhere it is used.
</p>
<p>
Note that the object is allocated with <tt>new</tt>.  The <tt>BoundaryConditionsContainer</tt> object deals
with deleting its associated boundary condition objects.  Note too that we could allocate a
separate condition object for each boundary node, but using the same object where possible is
more memory efficient.
</p>
<div class="code"><pre>        ConstBoundaryCondition<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;*</span> p_zero_boundary_condition <span class="o">=</span> <span class="k">new</span> ConstBoundaryCondition<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
</pre></div><p>
We then get a boundary node iterator from the mesh...
</p>
<div class="code"><pre>        TetrahedralMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;::</span>BoundaryNodeIterator iter <span class="o">=</span> mesh<span class="p">.</span>GetBoundaryNodeIteratorBegin<span class="p">();</span>
</pre></div><p>
...and loop over the boundary nodes, getting the x and y values.
</p>
<div class="code"><pre>        <span class="k">while</span> <span class="p">(</span>iter <span class="o">&lt;</span> mesh<span class="p">.</span>GetBoundaryNodeIteratorEnd<span class="p">())</span>
        <span class="p">{</span>
            <span class="kt">double</span> x <span class="o">=</span> <span class="p">(</span><span class="o">*</span>iter<span class="p">)</span><span class="o">-&gt;</span>GetPoint<span class="p">()[</span><span class="mi">0</span><span class="p">];</span>
            <span class="kt">double</span> y <span class="o">=</span> <span class="p">(</span><span class="o">*</span>iter<span class="p">)</span><span class="o">-&gt;</span>GetPoint<span class="p">()[</span><span class="mi">1</span><span class="p">];</span>
</pre></div><p>
If x=0 or y=0...
</p>
<div class="code"><pre>            <span class="k">if</span> <span class="p">((</span>x<span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span>y<span class="o">==</span><span class="mi">0</span><span class="p">))</span>
            <span class="p">{</span>
</pre></div><p>
...associate the zero boundary condition created above with this boundary node
(<tt>*iter</tt> being a pointer to a <tt>Node&lt;2&gt;</tt>).
</p>
<div class="code"><pre>                bcc<span class="p">.</span>AddDirichletBoundaryCondition<span class="p">(</span><span class="o">*</span>iter<span class="p">,</span> p_zero_boundary_condition<span class="p">);</span>
            <span class="p">}</span>
            iter<span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>

</pre></div><p>
Now we create Neumann boundary conditions for the <em>surface elements</em> on x=1 and y=1. Note that
Dirichlet boundary conditions are defined on nodes, whereas Neumann boundary conditions are
defined on surface elements. Note also that the natural boundary condition statement for this
PDE is (D grad u).n = g(x) (where n is the outward-facing surface normal), and g(x) is a prescribed
function, <em>not</em> something like du/dn=g(x). Hence the boundary condition we are specifying is
(D grad u).n = 0.
</p>
<p>
<strong>Important note for 1D:</strong> This means that if we were solving 2u<sub>xx</sub>=f(x) in 1D, and
wanted to specify du/dx=1 on the LHS boundary, the Neumann boundary value we have to specify is
-2, as n=-1 (outward facing normal) so (D gradu).n = -2 when du/dx=1.
</p>
<p>
To define Neumann bcs, we reuse the zero boundary condition object defined above, but apply it
at surface elements.  We loop over these using another iterator provided by the mesh class.
</p>
<div class="code"><pre>        TetrahedralMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;::</span>BoundaryElementIterator surf_iter
            <span class="o">=</span> mesh<span class="p">.</span>GetBoundaryElementIteratorBegin<span class="p">();</span>
        <span class="k">while</span> <span class="p">(</span>surf_iter <span class="o">!=</span> mesh<span class="p">.</span>GetBoundaryElementIteratorEnd<span class="p">())</span>
        <span class="p">{</span>
</pre></div><p>
Get the x and y values of any node (here, the 0th) in the element.
</p>
<div class="code"><pre>            <span class="kt">unsigned</span> node_index <span class="o">=</span> <span class="p">(</span><span class="o">*</span>surf_iter<span class="p">)</span><span class="o">-&gt;</span>GetNodeGlobalIndex<span class="p">(</span><span class="mi">0</span><span class="p">);</span>
            <span class="kt">double</span> x <span class="o">=</span> mesh<span class="p">.</span>GetNode<span class="p">(</span>node_index<span class="p">)</span><span class="o">-&gt;</span>GetPoint<span class="p">()[</span><span class="mi">0</span><span class="p">];</span>
            <span class="kt">double</span> y <span class="o">=</span> mesh<span class="p">.</span>GetNode<span class="p">(</span>node_index<span class="p">)</span><span class="o">-&gt;</span>GetPoint<span class="p">()[</span><span class="mi">1</span><span class="p">];</span>

</pre></div><p>
If x=1 or y=1...
</p>
<div class="code"><pre>            <span class="k">if</span> <span class="p">(</span> <span class="p">(</span>fabs<span class="p">(</span>x<span class="o">-</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span>fabs<span class="p">(</span>y<span class="o">-</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="p">)</span>
            <span class="p">{</span>
</pre></div><p>
...associate the boundary condition with the surface element.
</p>
<div class="code"><pre>                bcc<span class="p">.</span>AddNeumannBoundaryCondition<span class="p">(</span><span class="o">*</span>surf_iter<span class="p">,</span> p_zero_boundary_condition<span class="p">);</span>
            <span class="p">}</span>

</pre></div><p>
Finally increment the iterator.
</p>
<div class="code"><pre>            surf_iter<span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>

</pre></div><p>
Next we define the solver of the PDE.
To solve an <tt>AbstractLinearEllipticPde</tt> (which is the type of PDE <tt>MyPde</tt> is),
we use a <tt>SimpleLinearEllipticSolver</tt>. The solver, again templated over
<tt>ELEMENT_DIM</tt> and <tt>SPACE_DIM</tt>, needs to be given (pointers to) the mesh,
pde and boundary conditions.
</p>
<div class="code"><pre>        SimpleLinearEllipticSolver<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> solver<span class="p">(</span><span class="o">&amp;</span>mesh<span class="p">,</span> <span class="o">&amp;</span>pde<span class="p">,</span> <span class="o">&amp;</span>bcc<span class="p">);</span>

</pre></div><p>
To solve, just call <tt>Solve()</tt>. A PETSc vector is returned.
</p>
<div class="code"><pre>        Vec result <span class="o">=</span> solver<span class="p">.</span>Solve<span class="p">();</span>

</pre></div><p>
It is a pain to access the individual components of a PETSc vector, even when running only on
one process. A helper class called <tt>ReplicatableVector</tt> has been created. Create
an instance of one of these, using the PETSc <tt>Vec</tt> as the data. The <em>i</em>th
component of <tt>result</tt> can now be obtained by simply doing <tt>result_repl[i]</tt>.
</p>
<div class="code"><pre>        ReplicatableVector <span class="nf">result_repl</span><span class="p">(</span>result<span class="p">);</span>

</pre></div><p>
Let us write out the solution to a file. To do this, create an
<tt>OutputFileHandler</tt>, passing in the directory we want files written to.
This is relative to the directory defined by the CHASTE_TEST_OUTPUT environment
variable - usually <tt>/tmp/$USER/testoutput</tt>. Note by default the output directory
passed in is emptied by this command. To avoid this, <tt>false</tt> can be passed in as a second
parameter.
</p>
<div class="code"><pre>        OutputFileHandler <span class="nf">output_file_handler</span><span class="p">(</span><span class="s">"TestSolvingLinearPdeTutorial"</span><span class="p">);</span>

</pre></div><p>
Create an <tt>out_stream</tt>, which is a stream to a particular file. An <tt>out_stream</tt>
is a smart pointer to a <tt>std::ofstream</tt>.
</p>
<div class="code"><pre>        out_stream p_file <span class="o">=</span> output_file_handler<span class="p">.</span>OpenOutputFile<span class="p">(</span><span class="s">"linear_solution.txt"</span><span class="p">);</span>

</pre></div><p>
Loop over the entries of the solution.
</p>
<div class="code"><pre>        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> i<span class="o">=</span><span class="mi">0</span><span class="p">;</span> i<span class="o">&lt;</span>result_repl<span class="p">.</span>GetSize<span class="p">();</span> i<span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
</pre></div><p>
Get the x and y-values of the node corresponding to this entry. The method
<tt>GetNode</tt> on the mesh class returns a pointer to a <tt>Node</tt>.
</p>
<div class="code"><pre>            <span class="kt">double</span> x <span class="o">=</span> mesh<span class="p">.</span>GetNode<span class="p">(</span>i<span class="p">)</span><span class="o">-&gt;</span>rGetLocation<span class="p">()[</span><span class="mi">0</span><span class="p">];</span>
            <span class="kt">double</span> y <span class="o">=</span> mesh<span class="p">.</span>GetNode<span class="p">(</span>i<span class="p">)</span><span class="o">-&gt;</span>rGetLocation<span class="p">()[</span><span class="mi">1</span><span class="p">];</span>

</pre></div><p>
Get the computed solution at this node from the <tt>ReplicatableVector</tt>.
</p>
<div class="code"><pre>            <span class="kt">double</span> u <span class="o">=</span> result_repl<span class="p">[</span>i<span class="p">];</span>

</pre></div><p>
Finally, write x, y and u to the output file. The solution could then be
visualised in (eg) matlab, using the commands:
<tt>sol=load('linear_solution.txt'); plot3(sol(:,1),sol(:,2),sol(:,3),'.');</tt>
</p>
<div class="code"><pre>            <span class="p">(</span><span class="o">*</span>p_file<span class="p">)</span> <span class="o">&lt;&lt;</span> x <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> y <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> u <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="p">}</span>

</pre></div><p>
All PETSc <tt>Vec</tt>s should be destroyed when they are no longer needed, or you will have a memory leak.
</p>
<div class="code"><pre>        PetscTools<span class="o">::</span>Destroy<span class="p">(</span>result<span class="p">);</span>
    <span class="p">}</span>

</pre></div><h2 id="Test2:SolvingalinearparabolicPDE">Test 2: Solving a linear parabolic PDE</h2>
<p>
Now we solve a parabolic PDE. We choose a simple problem so that the code changes
needed from the elliptic case are clearer. We will solve
du/dt = div(grad u) + u, in 3d, with boundary conditions u=1 on the boundary, and initial
conditions u=1.
</p>
<div class="code"><pre>    <span class="kt">void</span> <span class="nf">TestSolvingParabolicPde</span><span class="p">()</span> <span class="k">throw</span><span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
</pre></div><p>
Create a 10 by 10 by 10 mesh in 3D, this time using the <tt>ConstructRegularSlabMesh</tt> method
on the mesh. The first parameter is the cartesian space-step and the other three parameters are the width, height and depth of the mesh.
</p>
<div class="code"><pre>        TetrahedralMesh<span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> mesh<span class="p">;</span>
        mesh<span class="p">.</span>ConstructRegularSlabMesh<span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>

</pre></div><p>
Our PDE object should be a class that is derived from the <tt>AbstractLinearParabolicPde</tt>.
We could write it ourselves as in the previous test, but since the PDE we want to solve is
so simple, it has already been defined (look it up! - it is located in pde/test/pdes).
</p>
<div class="code"><pre>        HeatEquationWithSourceTerm<span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span> pde<span class="p">;</span>

</pre></div><p>
Create a new boundary conditions container and specify u=1.0 on the boundary.
</p>
<div class="code"><pre>        BoundaryConditionsContainer<span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span> bcc<span class="p">;</span>
        bcc<span class="p">.</span>DefineConstantDirichletOnMeshBoundary<span class="p">(</span><span class="o">&amp;</span>mesh<span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>

</pre></div><p>
Create an instance of the solver, passing in the mesh, pde and boundary conditions.
</p>
<div class="code"><pre>        SimpleLinearParabolicSolver<span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> solver<span class="p">(</span><span class="o">&amp;</span>mesh<span class="p">,</span><span class="o">&amp;</span>pde<span class="p">,</span><span class="o">&amp;</span>bcc<span class="p">);</span>

</pre></div><p>
For parabolic problems, initial conditions are also needed. The solver will expect
a PETSc vector, where the i-th entry is the initial solution at node i, to be passed
in. To create this PETSc <tt>Vec</tt>, we will use a helper function in the <tt>PetscTools</tt>
class to create a <tt>Vec</tt> of size num_nodes, with each entry set to 1.0. Then we
set the initial condition on the solver.
</p>
<div class="code"><pre>        Vec initial_condition <span class="o">=</span> PetscTools<span class="o">::</span>CreateAndSetVec<span class="p">(</span>mesh<span class="p">.</span>GetNumNodes<span class="p">(),</span> <span class="mf">1.0</span><span class="p">);</span>
        solver<span class="p">.</span>SetInitialCondition<span class="p">(</span>initial_condition<span class="p">);</span>

</pre></div><p>
Next define the start time, end time, and timestep, and set them.
</p>
<div class="code"><pre>        <span class="kt">double</span> t_start <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">double</span> t_end <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kt">double</span> dt <span class="o">=</span> <span class="mf">0.01</span><span class="p">;</span>
        solver<span class="p">.</span>SetTimes<span class="p">(</span>t_start<span class="p">,</span> t_end<span class="p">);</span>
        solver<span class="p">.</span>SetTimeStep<span class="p">(</span>dt<span class="p">);</span>

</pre></div><p>
When we call Solve() below we will just get the solution at the final time. If we want
to have intermediate solutions written to file, we do the following. We start by
specifying an output directory and filename prefix for our results file:
</p>
<div class="code"><pre>        solver<span class="p">.</span>SetOutputDirectoryAndPrefix<span class="p">(</span><span class="s">"ParabolicSolverTutorial"</span><span class="p">,</span><span class="s">"results"</span><span class="p">);</span>
</pre></div><p>
When an output directory has been specified, the solver writes output in HDF5 format. To
convert this to another output format, we call the relevant method. Here, we convert
the output to plain text files (VTK or cmgui formats are also possible). We also say how
often to write the data, telling the solver to output results to file every tenth timestep.
The solver will create one file for each variable (in this case there is only one variable)
and for each time, so for example, the file
<tt>results_Variable_0_10</tt> is the results for u, over all nodes, at the 11th printed time.
Have a look in the output directory after running the test. (For comments on visualising the data in
matlab or octave, see the end of the tutorial <a class="wiki" href="https://chaste.github.io/old_releases/release_3.4/UserTutorials/WritingPdeSolvers.html">UserTutorials/WritingPdeSolvers</a>.)
</p>
<div class="code"><pre>        solver<span class="p">.</span>SetOutputToTxt<span class="p">(</span><span class="nb">true</span><span class="p">);</span>
        solver<span class="p">.</span>SetPrintingTimestepMultiple<span class="p">(</span><span class="mi">10</span><span class="p">);</span>

</pre></div><p>
Now we can solve the problem. The <tt>Vec</tt> that is returned can be passed into a
<tt>ReplicatableVector</tt> as before.
</p>
<div class="code"><pre>        Vec solution <span class="o">=</span> solver<span class="p">.</span>Solve<span class="p">();</span>
        ReplicatableVector <span class="nf">solution_repl</span><span class="p">(</span>solution<span class="p">);</span>

</pre></div><p>
Let's also solve the equivalent static PDE, i.e. set du/dt=0, so 0=div(gradu) + u. This
is easy, as the PDE class has already been defined.
</p>
<div class="code"><pre>        SimplePoissonEquation<span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> static_pde<span class="p">;</span>
        SimpleLinearEllipticSolver<span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> static_solver<span class="p">(</span><span class="o">&amp;</span>mesh<span class="p">,</span> <span class="o">&amp;</span>static_pde<span class="p">,</span> <span class="o">&amp;</span>bcc<span class="p">);</span>
        Vec static_solution <span class="o">=</span> static_solver<span class="p">.</span>Solve<span class="p">();</span>
        ReplicatableVector <span class="nf">static_solution_repl</span><span class="p">(</span>static_solution<span class="p">);</span>

</pre></div><p>
We can now compare the solution of the parabolic PDE at t=1 with the static solution,
to see if the static equilibrium solution was reached in the former. (Ideally we should
compute some relative error, but we just compute an absolute error for simplicity.)
</p>
<div class="code"><pre>        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> i<span class="o">=</span><span class="mi">0</span><span class="p">;</span> i<span class="o">&lt;</span>static_solution_repl<span class="p">.</span>GetSize<span class="p">();</span> i<span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            TS_ASSERT_DELTA<span class="p">(</span> solution_repl<span class="p">[</span>i<span class="p">],</span> static_solution_repl<span class="p">[</span>i<span class="p">],</span> <span class="mf">1e-3</span><span class="p">);</span>
        <span class="p">}</span>

</pre></div><p>
All PETSc vectors should be destroyed when they are no longer needed.
</p>
<div class="code"><pre>        PetscTools<span class="o">::</span>Destroy<span class="p">(</span>initial_condition<span class="p">);</span>
        PetscTools<span class="o">::</span>Destroy<span class="p">(</span>solution<span class="p">);</span>
        PetscTools<span class="o">::</span>Destroy<span class="p">(</span>static_solution<span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

</pre></div><h1 id="Code">Code</h1>
<p>
The full code is given below
</p>
<h2 id="FilenameTestSolvingLinearPdesTutorial.hpp">File name <tt>TestSolvingLinearPdesTutorial.hpp</tt></h2>
<div class="code"><pre><span class="cp">#include &lt;cxxtest/TestSuite.h&gt;
#include "UblasIncludes.hpp"
#include "SimpleLinearEllipticSolver.hpp"
#include "SimpleLinearParabolicSolver.hpp"
#include "HeatEquationWithSourceTerm.hpp"
#include "SimplePoissonEquation.hpp"
#include "TrianglesMeshReader.hpp"
#include "TetrahedralMesh.hpp"
#include "BoundaryConditionsContainer.hpp"
#include "ConstBoundaryCondition.hpp"
#include "OutputFileHandler.hpp"
#include "PetscSetupAndFinalize.hpp"
</span>
<span class="k">class</span> <span class="nc">MyPde</span> <span class="o">:</span> <span class="k">public</span> AbstractLinearEllipticPde<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="nl">private:</span>
    c_matrix<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> mDiffusionTensor<span class="p">;</span>

<span class="nl">public:</span>
    MyPde<span class="p">()</span>
    <span class="p">{</span>
        mDiffusionTensor<span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">;</span>
        mDiffusionTensor<span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
        mDiffusionTensor<span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
        mDiffusionTensor<span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">double</span> ComputeConstantInUSourceTerm<span class="p">(</span><span class="k">const</span> ChastePoint<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;&amp;</span> rX<span class="p">,</span> Element<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> pElement<span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> rX<span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span>rX<span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> rX<span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span>rX<span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="kt">double</span> ComputeLinearInUCoeffInSourceTerm<span class="p">(</span><span class="k">const</span> ChastePoint<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;&amp;</span> rX<span class="p">,</span> Element<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> pElement<span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mf">1.0</span><span class="p">;</span>
    <span class="p">}</span>

    c_matrix<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> ComputeDiffusionTerm<span class="p">(</span><span class="k">const</span> ChastePoint<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;&amp;</span> rX<span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> mDiffusionTensor<span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">TestSolvingLinearPdesTutorial</span> <span class="o">:</span> <span class="k">public</span> CxxTest<span class="o">::</span>TestSuite
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> TestSolvingEllipticPde<span class="p">()</span> <span class="k">throw</span><span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
        TrianglesMeshReader<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> mesh_reader<span class="p">(</span><span class="s">"mesh/test/data/square_128_elements"</span><span class="p">);</span>
        TetrahedralMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> mesh<span class="p">;</span>
        mesh<span class="p">.</span>ConstructFromMeshReader<span class="p">(</span>mesh_reader<span class="p">);</span>

        MyPde pde<span class="p">;</span>

        BoundaryConditionsContainer<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span> bcc<span class="p">;</span>

        <span class="c1">//bcc.DefineZeroDirichletOnMeshBoundary(&amp;mesh);
</span>
        ConstBoundaryCondition<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;*</span> p_zero_boundary_condition <span class="o">=</span> <span class="k">new</span> ConstBoundaryCondition<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
        TetrahedralMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;::</span>BoundaryNodeIterator iter <span class="o">=</span> mesh<span class="p">.</span>GetBoundaryNodeIteratorBegin<span class="p">();</span>
        <span class="k">while</span> <span class="p">(</span>iter <span class="o">&lt;</span> mesh<span class="p">.</span>GetBoundaryNodeIteratorEnd<span class="p">())</span>
        <span class="p">{</span>
            <span class="kt">double</span> x <span class="o">=</span> <span class="p">(</span><span class="o">*</span>iter<span class="p">)</span><span class="o">-&gt;</span>GetPoint<span class="p">()[</span><span class="mi">0</span><span class="p">];</span>
            <span class="kt">double</span> y <span class="o">=</span> <span class="p">(</span><span class="o">*</span>iter<span class="p">)</span><span class="o">-&gt;</span>GetPoint<span class="p">()[</span><span class="mi">1</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">((</span>x<span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span>y<span class="o">==</span><span class="mi">0</span><span class="p">))</span>
            <span class="p">{</span>
                bcc<span class="p">.</span>AddDirichletBoundaryCondition<span class="p">(</span><span class="o">*</span>iter<span class="p">,</span> p_zero_boundary_condition<span class="p">);</span>
            <span class="p">}</span>
            iter<span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>

        TetrahedralMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;::</span>BoundaryElementIterator surf_iter
            <span class="o">=</span> mesh<span class="p">.</span>GetBoundaryElementIteratorBegin<span class="p">();</span>
        <span class="k">while</span> <span class="p">(</span>surf_iter <span class="o">!=</span> mesh<span class="p">.</span>GetBoundaryElementIteratorEnd<span class="p">())</span>
        <span class="p">{</span>
            <span class="kt">unsigned</span> node_index <span class="o">=</span> <span class="p">(</span><span class="o">*</span>surf_iter<span class="p">)</span><span class="o">-&gt;</span>GetNodeGlobalIndex<span class="p">(</span><span class="mi">0</span><span class="p">);</span>
            <span class="kt">double</span> x <span class="o">=</span> mesh<span class="p">.</span>GetNode<span class="p">(</span>node_index<span class="p">)</span><span class="o">-&gt;</span>GetPoint<span class="p">()[</span><span class="mi">0</span><span class="p">];</span>
            <span class="kt">double</span> y <span class="o">=</span> mesh<span class="p">.</span>GetNode<span class="p">(</span>node_index<span class="p">)</span><span class="o">-&gt;</span>GetPoint<span class="p">()[</span><span class="mi">1</span><span class="p">];</span>

            <span class="k">if</span> <span class="p">(</span> <span class="p">(</span>fabs<span class="p">(</span>x<span class="o">-</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span>fabs<span class="p">(</span>y<span class="o">-</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="p">)</span>
            <span class="p">{</span>
                bcc<span class="p">.</span>AddNeumannBoundaryCondition<span class="p">(</span><span class="o">*</span>surf_iter<span class="p">,</span> p_zero_boundary_condition<span class="p">);</span>
            <span class="p">}</span>

            surf_iter<span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>

        SimpleLinearEllipticSolver<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> solver<span class="p">(</span><span class="o">&amp;</span>mesh<span class="p">,</span> <span class="o">&amp;</span>pde<span class="p">,</span> <span class="o">&amp;</span>bcc<span class="p">);</span>

        Vec result <span class="o">=</span> solver<span class="p">.</span>Solve<span class="p">();</span>

        ReplicatableVector <span class="nf">result_repl</span><span class="p">(</span>result<span class="p">);</span>

        OutputFileHandler <span class="nf">output_file_handler</span><span class="p">(</span><span class="s">"TestSolvingLinearPdeTutorial"</span><span class="p">);</span>

        out_stream p_file <span class="o">=</span> output_file_handler<span class="p">.</span>OpenOutputFile<span class="p">(</span><span class="s">"linear_solution.txt"</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> i<span class="o">=</span><span class="mi">0</span><span class="p">;</span> i<span class="o">&lt;</span>result_repl<span class="p">.</span>GetSize<span class="p">();</span> i<span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">double</span> x <span class="o">=</span> mesh<span class="p">.</span>GetNode<span class="p">(</span>i<span class="p">)</span><span class="o">-&gt;</span>rGetLocation<span class="p">()[</span><span class="mi">0</span><span class="p">];</span>
            <span class="kt">double</span> y <span class="o">=</span> mesh<span class="p">.</span>GetNode<span class="p">(</span>i<span class="p">)</span><span class="o">-&gt;</span>rGetLocation<span class="p">()[</span><span class="mi">1</span><span class="p">];</span>

            <span class="kt">double</span> u <span class="o">=</span> result_repl<span class="p">[</span>i<span class="p">];</span>

            <span class="p">(</span><span class="o">*</span>p_file<span class="p">)</span> <span class="o">&lt;&lt;</span> x <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> y <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> u <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="p">}</span>

        PetscTools<span class="o">::</span>Destroy<span class="p">(</span>result<span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> TestSolvingParabolicPde<span class="p">()</span> <span class="k">throw</span><span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
        TetrahedralMesh<span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> mesh<span class="p">;</span>
        mesh<span class="p">.</span>ConstructRegularSlabMesh<span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>

        HeatEquationWithSourceTerm<span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span> pde<span class="p">;</span>

        BoundaryConditionsContainer<span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span> bcc<span class="p">;</span>
        bcc<span class="p">.</span>DefineConstantDirichletOnMeshBoundary<span class="p">(</span><span class="o">&amp;</span>mesh<span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>

        SimpleLinearParabolicSolver<span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> solver<span class="p">(</span><span class="o">&amp;</span>mesh<span class="p">,</span><span class="o">&amp;</span>pde<span class="p">,</span><span class="o">&amp;</span>bcc<span class="p">);</span>

        Vec initial_condition <span class="o">=</span> PetscTools<span class="o">::</span>CreateAndSetVec<span class="p">(</span>mesh<span class="p">.</span>GetNumNodes<span class="p">(),</span> <span class="mf">1.0</span><span class="p">);</span>
        solver<span class="p">.</span>SetInitialCondition<span class="p">(</span>initial_condition<span class="p">);</span>

        <span class="kt">double</span> t_start <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">double</span> t_end <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kt">double</span> dt <span class="o">=</span> <span class="mf">0.01</span><span class="p">;</span>
        solver<span class="p">.</span>SetTimes<span class="p">(</span>t_start<span class="p">,</span> t_end<span class="p">);</span>
        solver<span class="p">.</span>SetTimeStep<span class="p">(</span>dt<span class="p">);</span>

        solver<span class="p">.</span>SetOutputDirectoryAndPrefix<span class="p">(</span><span class="s">"ParabolicSolverTutorial"</span><span class="p">,</span><span class="s">"results"</span><span class="p">);</span>
        solver<span class="p">.</span>SetOutputToTxt<span class="p">(</span><span class="nb">true</span><span class="p">);</span>
        solver<span class="p">.</span>SetPrintingTimestepMultiple<span class="p">(</span><span class="mi">10</span><span class="p">);</span>

        Vec solution <span class="o">=</span> solver<span class="p">.</span>Solve<span class="p">();</span>
        ReplicatableVector <span class="nf">solution_repl</span><span class="p">(</span>solution<span class="p">);</span>

        SimplePoissonEquation<span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> static_pde<span class="p">;</span>
        SimpleLinearEllipticSolver<span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> static_solver<span class="p">(</span><span class="o">&amp;</span>mesh<span class="p">,</span> <span class="o">&amp;</span>static_pde<span class="p">,</span> <span class="o">&amp;</span>bcc<span class="p">);</span>
        Vec static_solution <span class="o">=</span> static_solver<span class="p">.</span>Solve<span class="p">();</span>
        ReplicatableVector <span class="nf">static_solution_repl</span><span class="p">(</span>static_solution<span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> i<span class="o">=</span><span class="mi">0</span><span class="p">;</span> i<span class="o">&lt;</span>static_solution_repl<span class="p">.</span>GetSize<span class="p">();</span> i<span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            TS_ASSERT_DELTA<span class="p">(</span> solution_repl<span class="p">[</span>i<span class="p">],</span> static_solution_repl<span class="p">[</span>i<span class="p">],</span> <span class="mf">1e-3</span><span class="p">);</span>
        <span class="p">}</span>

        PetscTools<span class="o">::</span>Destroy<span class="p">(</span>initial_condition<span class="p">);</span>
        PetscTools<span class="o">::</span>Destroy<span class="p">(</span>solution<span class="p">);</span>
        PetscTools<span class="o">::</span>Destroy<span class="p">(</span>static_solution<span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

</pre></div></div>
          

    </div>
  </body>
</html>
