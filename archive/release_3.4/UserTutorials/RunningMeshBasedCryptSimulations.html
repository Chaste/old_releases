<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>UserTutorials/RunningMeshBasedCryptSimulations - Chaste</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="/trac-static/css/trac.css" type="text/css" />
    <link rel="stylesheet" href="/trac-static/css/wiki.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="/trac-static/css/site.css" />
  </head>
  <body>
    <div id="banner">
      <div id="header">
        <p>
          <a id="logo" href="http://www.cs.ox.ac.uk/chaste"><img src="/logos/chaste-266x60.jpg" alt="Chaste logo" height="60" width="266" /></a>
          <em>Documentation for <a href="/chaste/tutorials/release_3.4/">Release 3.4</a>.</em>
        </p>
      </div>
    </div>
    <p>&nbsp;</p>
    <div id="content" class="wiki">
      <div class="wikipage searchable">
        
          <div id="wikipage" class="trac-content"><p>
This tutorial is automatically generated from the file trunk/crypt/test/tutorial/TestRunningMeshBasedCryptSimulationsTutorial.hpp at revision <a class="missing changeset" title="No permission to view changeset 25790 on (default)">r25790</a>.
Note that the code is given in full at the bottom of the page.
</p>
<h1 id="Examplesshowinghowtoruncryptsimulationsonperiodicmesheswithdifferentcell-cyclemodels">Examples showing how to run crypt simulations on periodic meshes with different cell-cycle models</h1>
<h2 id="Introduction">Introduction</h2>
<p>
In this tutorial we show how Chaste can be used to simulate a cylindrical model of an
intestinal crypt. Full details of the computational model can be found in the paper by
van Leeuwen <em>et al.</em> (2009) [doi:10.1111/j.1365-2184.2009.00627.x].
</p>
<p>
As in previous cell-based Chaste tutorials, we begin by including the necessary header files.
</p>
<div class="code"><pre><span class="cp">#include &lt;cxxtest/TestSuite.h&gt;
#include "CheckpointArchiveTypes.hpp"
#include "SmartPointers.hpp"
#include "AbstractCellBasedTestSuite.hpp"
</span>
</pre></div><p>
The next header file defines a helper class for generating cells for crypt simulations.
</p>
<div class="code"><pre><span class="cp">#include "CryptCellsGenerator.hpp"
</span></pre></div><p>
The next two header files define two different types of cell-cycle model.
In a <tt>FixedDurationGenerationBasedCellCycleModel</tt>, the duration of each phase
of the cell cycle is fixed. In a <tt>WntCellCycleModel</tt>, the duration of a cell's G1 phase
is determined by a system of nonlinear ODEs describing a cell's response to the local
concentration of Wnt,
a secreted cellâ€“cell signalling molecule that is known to play a key role in cell
proliferation in the crypt. In our crypt simulations, we impose a fixed gradient of
Wnt up the axis of the crypt.
</p>
<div class="code"><pre><span class="cp">#include "FixedDurationGenerationBasedCellCycleModel.hpp"
#include "WntCellCycleModel.hpp"
</span></pre></div><p>
The next header file defines a helper class for generating a suitable triangular mesh
for the crypt simulation, such that the cell corresponding to each node is initially
in mechanical equilibrium with its neighours and periodic boundary conditions are applied
at the left- and right-hand sides of the mesh (hence the "cylindrical").
</p>
<div class="code"><pre><span class="cp">#include "CylindricalHoneycombMeshGenerator.hpp"
</span></pre></div><p>
The next two header files were encountered in <a class="wiki" href="/chaste/tutorials/release_3.4/UserTutorials/RunningMeshBasedSimulations.html">UserTutorials/RunningMeshBasedSimulations</a>.
The first header
defines a <tt>CellPopulation</tt> class that uses a triangular mesh, and allows
for the inclusion of 'ghost nodes': these are nodes in the mesh that do not correspond
to cells, but help ensure that a sensible Delaunay triangulation is generated
at each timestep; this is because the triangulation algorithm requires a convex hull.
The next header file defines a force law, based on a linear spring, for describing
the mechanical interactions between neighbouring cells in the crypt.
</p>
<div class="code"><pre><span class="cp">#include "MeshBasedCellPopulationWithGhostNodes.hpp"
#include "GeneralisedLinearSpringForce.hpp"
</span></pre></div><p>
The next header file defines the class that simulates the evolution of a <tt>CellPopulation</tt>,
specialized to deal with the cylindrical crypt geometry.
</p>
<div class="code"><pre><span class="cp">#include "CryptSimulation2d.hpp"
</span></pre></div><p>
The next header file defines a Wnt singleton class, which (if used) deals with the
imposed Wnt gradient in our crypt model. This affects cell proliferation in the case
where we construct each cell with a <tt>WntCellCycleModel</tt>.
</p>
<div class="code"><pre><span class="cp">#include "WntConcentration.hpp"
</span></pre></div><p>
The final header file defines a cell killer class, which implements sloughing of cells
into the lumen once they reach the top of the crypt.
</p>
<div class="code"><pre><span class="cp">#include "SloughingCellKiller.hpp"
</span>
</pre></div><p>
This header ensures that this test is only run on one process, since it doesn't support parallel execution.
</p>
<div class="code"><pre><span class="cp">#include "FakePetscSetup.hpp"
</span>
</pre></div><p>
Next, we define the test class.
</p>
<div class="code"><pre><span class="k">class</span> <span class="nc">TestRunningMeshBasedCryptSimulationsTutorial</span> <span class="o">:</span> <span class="k">public</span> AbstractCellBasedTestSuite
<span class="p">{</span>
<span class="nl">public:</span>
</pre></div><h2 id="Test1:abasiccryptsimulation">Test 1: a basic crypt simulation</h2>
<p>
In the first test, we demonstrate how to create a crypt simulation using a
cylindrical mesh, with each cell progressing through a fixed cell-cycle model,
and sloughing enforced at the top of the crypt.
</p>
<div class="code"><pre>    <span class="kt">void</span> <span class="nf">TestCryptWithFixedCellCycle</span><span class="p">()</span> <span class="k">throw</span><span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
</pre></div><p>
First, we generate a mesh. The basic Chaste mesh is a <tt>TetrahedralMesh</tt>.
To enforce periodicity at the left- and right-hand sides of the mesh, we
use a subclass called <tt>Cylindrical2dMesh</tt>, which has extra methods for
maintaining periodicity. To create a <tt>Cylindrical2dMesh</tt>, we can use a helper class called
<tt>CylindricalHoneycombMeshGenerator</tt>. This generates a periodic honeycomb-shaped mesh,
in which all nodes are equidistant to their neighbours. Here the first and second arguments
define the size of the mesh - we have chosen a mesh that is 6 nodes (i.e.
cells) wide, and 9 nodes high. The third argument indicates that we require
a double layer of ghost nodes around the mesh (technically, just above
and below the mesh, since it is periodic). We call <tt>GetCylindricalMesh()</tt> on the <tt>CylindricalHoneycombMeshGenerator</tt> to
return our <tt>Cylindrical2dMesh</tt>, and call <tt> GetCellLocationIndices()</tt>
to return a <tt>std::vector</tt> of indices of nodes in the mesh that correspond to real cells (as opposed
to ghost nodes).
</p>
<div class="code"><pre>        CylindricalHoneycombMeshGenerator <span class="nf">generator</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
        Cylindrical2dMesh<span class="o">*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetCylindricalMesh<span class="p">();</span>
        std<span class="o">::</span>vector<span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> location_indices <span class="o">=</span> generator<span class="p">.</span>GetCellLocationIndices<span class="p">();</span>

</pre></div><p>
Having created a mesh, we now create a <tt>std::vector</tt> of <tt>CellPtr</tt>s.
To do this, we use the <tt>CryptCellsGenerator</tt> helper class, which is templated over the type
of cell-cycle model required (here <tt>FixedDurationGenerationBasedCellCycleModel</tt>)
and the dimension. We create an empty vector of cells and pass this into the
method <tt>Generate()</tt> along with the mesh. The fourth argument 'true' indicates that the cells
should be assigned random birth times, to avoid synchronous division. The
<tt>cells</tt> vector is populated once the method <tt>Generate()</tt> is
called. Note that we only ever deal with shared pointers to cells, named <tt>CellPtr</tt>s.
</p>
<div class="code"><pre>        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        CryptCellsGenerator<span class="o">&lt;</span>FixedDurationGenerationBasedCellCycleModel<span class="o">&gt;</span> cells_generator<span class="p">;</span>
        cells_generator<span class="p">.</span>Generate<span class="p">(</span>cells<span class="p">,</span> p_mesh<span class="p">,</span> location_indices<span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

</pre></div><p>
Now we have a mesh, a set of cells to go with it, and a vector of node indices
corresponding to real cells, we can create a <tt>CellPopulation</tt> object. In general,
this class associates a collection of cells with a set of nodes or a mesh.
For this test, because we have a mesh and ghost nodes, we use a particular type of
cell population called a <tt>MeshBasedCellPopulationWithGhostNodes</tt>.
</p>
<div class="code"><pre>        MeshBasedCellPopulationWithGhostNodes<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">,</span> location_indices<span class="p">);</span>

</pre></div><p>
Next we use the <tt>CellPopulation</tt> object to construct a <tt>CryptSimulation2d</tt> object,
which will be used to simulate the crypt model.
</p>
<div class="code"><pre>        CryptSimulation2d <span class="nf">simulator</span><span class="p">(</span>cell_population<span class="p">);</span>
</pre></div><p>
We must set the output directory on the simulator (relative to
"/tmp/&lt;USER_NAME&gt;/testoutput") and the end time (in hours).
</p>
<div class="code"><pre>        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"CryptTutorialFixedCellCycle"</span><span class="p">);</span>
        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</pre></div><p>
For longer simulations, we may not want to output the results
every time step. In this case we can use the following method,
to print results every 12 time steps instead. As the time step
used by the simulator, is 30 seconds, this method will cause the
simulator to print results every 6 minutes.
</p>
<div class="code"><pre>        simulator<span class="p">.</span>SetSamplingTimestepMultiple<span class="p">(</span><span class="mi">12</span><span class="p">);</span>

</pre></div><p>
Before running the simulation, we must add one or more force laws, which determine the mechanical
behaviour of the cell population. For this test, we use a <tt>GeneralisedLinearSpringForce</tt>, which assumes
that every cell experiences a force from each of its neighbours that can be represented as a linear overdamped
spring.
</p>
<div class="code"><pre>        MAKE_PTR<span class="p">(</span>GeneralisedLinearSpringForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_linear_force<span class="p">);</span>
        simulator<span class="p">.</span>AddForce<span class="p">(</span>p_linear_force<span class="p">);</span>

</pre></div><p>
We also add a cell killer to the simulator. This object
dictates under what conditions cells die. For this test, we use
a <tt>SloughingCellKiller</tt>, which kills cells above a certain
height (passed as an argument to the constructor).
</p>
<div class="code"><pre>        <span class="kt">double</span> crypt_height <span class="o">=</span> <span class="mf">8.0</span><span class="p">;</span>
        MAKE_PTR_ARGS<span class="p">(</span>SloughingCellKiller<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_killer<span class="p">,</span> <span class="p">(</span><span class="o">&amp;</span>cell_population<span class="p">,</span> crypt_height<span class="p">));</span>
        simulator<span class="p">.</span>AddCellKiller<span class="p">(</span>p_killer<span class="p">);</span>

</pre></div><p>
To run the simulation, we call <tt>Solve()</tt>.
</p>
<div class="code"><pre>        simulator<span class="p">.</span>Solve<span class="p">();</span>
    <span class="p">}</span>

</pre></div><p>
Finally, to visualize the results, we open a new terminal, <tt>cd</tt> to the Chaste directory,
then <tt>cd</tt> to <tt>anim</tt>. Then we do: <tt>java Visualize2dCentreCells /tmp/$USER/testoutput/CryptTutorialFixedCellCycle/results_from_time_0</tt>.
It may be necessary to do: <tt>javac Visualize2dCentreCells.java</tt> beforehand to create the
java executable. Further details on visualization can be found on the Chaste wiki page
For further details on visualization, see <a class="wiki" href="/chaste/tutorials/release_3.4/ChasteGuides/RunningCellBasedVisualization.html">ChasteGuides/RunningCellBasedVisualization</a>.
</p>
<h2 id="Test2:aWnt-dependentcryptsimulation">Test 2: a Wnt-dependent crypt simulation</h2>
<p>
The next test is very similar to Test 1, except that instead of
using a fixed cell-cycle model, we use a Wnt-dependent cell-cycle model,
with the Wnt concentration varying within the crypt in a predefined manner.
</p>
<div class="code"><pre>    <span class="kt">void</span> <span class="nf">TestCryptWithWntCellCycle</span><span class="p">()</span> <span class="k">throw</span><span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
</pre></div><p>
First we create a cylindrical mesh, and get the cell location indices, exactly as before.
Note that time is re-initialized to zero and random number generator is re-seeded to zero in the <tt>AbstractCellBasedTestSuite</tt>.
</p>
<div class="code"><pre>        CylindricalHoneycombMeshGenerator <span class="nf">generator</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
        Cylindrical2dMesh<span class="o">*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetCylindricalMesh<span class="p">();</span>

        std<span class="o">::</span>vector<span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> location_indices <span class="o">=</span> generator<span class="p">.</span>GetCellLocationIndices<span class="p">();</span>

</pre></div><p>
We create the cells, using the same method as before. Here, though, we use a <tt>WntCellCycleModel</tt>.
</p>
<div class="code"><pre>        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        CryptCellsGenerator<span class="o">&lt;</span>WntCellCycleModel<span class="o">&gt;</span> cells_generator<span class="p">;</span>
        cells_generator<span class="p">.</span>Generate<span class="p">(</span>cells<span class="p">,</span> p_mesh<span class="p">,</span> location_indices<span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

</pre></div><p>
We create the cell population, as before.
</p>
<div class="code"><pre>        MeshBasedCellPopulationWithGhostNodes<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">,</span> location_indices<span class="p">);</span>

</pre></div><p>
We set the height of the crypt. As well as passing this variable into the <tt>sloughingCellKiller</tt>,
we will pass it to the <tt>WntConcentration</tt> object (see below).
</p>
<div class="code"><pre>        <span class="kt">double</span> crypt_height <span class="o">=</span> <span class="mf">8.0</span><span class="p">;</span>

</pre></div><p>
When using a <tt>WntCellCycleModel</tt>, we need a way of telling each cell what the Wnt concentration
is at its location. To do this, we set up a <tt>WntConcentration</tt> object. Like <tt>SimulationTime</tt>,
<tt>WntConcentration</tt> is a singleton class, so when instantiated it is accessible from anywhere in
the code (and in particular, all cells and cell-cycle models can access it). We need to say what
the profile of the Wnt concentation should be up the crypt: here, we say it is <tt>LINEAR</tt> (linear
decreasing from 1 to 0 from the bottom of the crypt to the top). We also need to inform the
<tt>WntConcentration</tt> of the cell population and the height of the crypt.
</p>
<div class="code"><pre>        WntConcentration<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>SetType<span class="p">(</span>LINEAR<span class="p">);</span>
        WntConcentration<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>SetCellPopulation<span class="p">(</span>cell_population<span class="p">);</span>
        WntConcentration<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>SetCryptLength<span class="p">(</span>crypt_height<span class="p">);</span>

</pre></div><p>
Create a simulator as before (except setting a different output directory).
</p>
<div class="code"><pre>        CryptSimulation2d <span class="nf">simulator</span><span class="p">(</span>cell_population<span class="p">);</span>
        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"CryptTutorialWntCellCycle"</span><span class="p">);</span>
        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mi">1</span><span class="p">);</span>

</pre></div><p>
As before, we create a force law and cell killer and pass these objects to the simulator, then call
Solve().
</p>
<div class="code"><pre>        MAKE_PTR<span class="p">(</span>GeneralisedLinearSpringForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_linear_force<span class="p">);</span>
        simulator<span class="p">.</span>AddForce<span class="p">(</span>p_linear_force<span class="p">);</span>
        MAKE_PTR_ARGS<span class="p">(</span>SloughingCellKiller<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_killer<span class="p">,</span> <span class="p">(</span><span class="o">&amp;</span>cell_population<span class="p">,</span> crypt_height<span class="p">));</span>
        simulator<span class="p">.</span>AddCellKiller<span class="p">(</span>p_killer<span class="p">);</span>

        simulator<span class="p">.</span>Solve<span class="p">();</span>

</pre></div><p>
Finally, we must tidy up by destroying the <tt>WntConcentration</tt>
singleton object. This avoids memory leaks occurring.
</p>
<div class="code"><pre>        WntConcentration<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>Destroy<span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div><p>
The results of this test can be visualized as in Test 1, with the correct output directory.
</p>
<h1 id="Code">Code</h1>
<p>
The full code is given below
</p>
<h2 id="FilenameTestRunningMeshBasedCryptSimulationsTutorial.hpp">File name <tt>TestRunningMeshBasedCryptSimulationsTutorial.hpp</tt></h2>
<div class="code"><pre><span class="cp">#include &lt;cxxtest/TestSuite.h&gt;
#include "CheckpointArchiveTypes.hpp"
#include "SmartPointers.hpp"
#include "AbstractCellBasedTestSuite.hpp"
</span>
<span class="cp">#include "CryptCellsGenerator.hpp"
#include "FixedDurationGenerationBasedCellCycleModel.hpp"
#include "WntCellCycleModel.hpp"
#include "CylindricalHoneycombMeshGenerator.hpp"
#include "MeshBasedCellPopulationWithGhostNodes.hpp"
#include "GeneralisedLinearSpringForce.hpp"
#include "CryptSimulation2d.hpp"
#include "WntConcentration.hpp"
#include "SloughingCellKiller.hpp"
</span>
<span class="cp">#include "FakePetscSetup.hpp"
</span>
<span class="k">class</span> <span class="nc">TestRunningMeshBasedCryptSimulationsTutorial</span> <span class="o">:</span> <span class="k">public</span> AbstractCellBasedTestSuite
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> TestCryptWithFixedCellCycle<span class="p">()</span> <span class="k">throw</span><span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
        CylindricalHoneycombMeshGenerator generator<span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
        Cylindrical2dMesh<span class="o">*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetCylindricalMesh<span class="p">();</span>
        std<span class="o">::</span>vector<span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> location_indices <span class="o">=</span> generator<span class="p">.</span>GetCellLocationIndices<span class="p">();</span>

        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        CryptCellsGenerator<span class="o">&lt;</span>FixedDurationGenerationBasedCellCycleModel<span class="o">&gt;</span> cells_generator<span class="p">;</span>
        cells_generator<span class="p">.</span>Generate<span class="p">(</span>cells<span class="p">,</span> p_mesh<span class="p">,</span> location_indices<span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

        MeshBasedCellPopulationWithGhostNodes<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">,</span> location_indices<span class="p">);</span>

        CryptSimulation2d <span class="nf">simulator</span><span class="p">(</span>cell_population<span class="p">);</span>
        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"CryptTutorialFixedCellCycle"</span><span class="p">);</span>
        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        simulator<span class="p">.</span>SetSamplingTimestepMultiple<span class="p">(</span><span class="mi">12</span><span class="p">);</span>

        MAKE_PTR<span class="p">(</span>GeneralisedLinearSpringForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_linear_force<span class="p">);</span>
        simulator<span class="p">.</span>AddForce<span class="p">(</span>p_linear_force<span class="p">);</span>

        <span class="kt">double</span> crypt_height <span class="o">=</span> <span class="mf">8.0</span><span class="p">;</span>
        MAKE_PTR_ARGS<span class="p">(</span>SloughingCellKiller<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_killer<span class="p">,</span> <span class="p">(</span><span class="o">&amp;</span>cell_population<span class="p">,</span> crypt_height<span class="p">));</span>
        simulator<span class="p">.</span>AddCellKiller<span class="p">(</span>p_killer<span class="p">);</span>

        simulator<span class="p">.</span>Solve<span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> TestCryptWithWntCellCycle<span class="p">()</span> <span class="k">throw</span><span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
        CylindricalHoneycombMeshGenerator generator<span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
        Cylindrical2dMesh<span class="o">*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetCylindricalMesh<span class="p">();</span>

        std<span class="o">::</span>vector<span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> location_indices <span class="o">=</span> generator<span class="p">.</span>GetCellLocationIndices<span class="p">();</span>

        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        CryptCellsGenerator<span class="o">&lt;</span>WntCellCycleModel<span class="o">&gt;</span> cells_generator<span class="p">;</span>
        cells_generator<span class="p">.</span>Generate<span class="p">(</span>cells<span class="p">,</span> p_mesh<span class="p">,</span> location_indices<span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

        MeshBasedCellPopulationWithGhostNodes<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">,</span> location_indices<span class="p">);</span>

        <span class="kt">double</span> crypt_height <span class="o">=</span> <span class="mf">8.0</span><span class="p">;</span>

        WntConcentration<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>SetType<span class="p">(</span>LINEAR<span class="p">);</span>
        WntConcentration<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>SetCellPopulation<span class="p">(</span>cell_population<span class="p">);</span>
        WntConcentration<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>SetCryptLength<span class="p">(</span>crypt_height<span class="p">);</span>

        CryptSimulation2d <span class="nf">simulator</span><span class="p">(</span>cell_population<span class="p">);</span>
        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"CryptTutorialWntCellCycle"</span><span class="p">);</span>
        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mi">1</span><span class="p">);</span>

        MAKE_PTR<span class="p">(</span>GeneralisedLinearSpringForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_linear_force<span class="p">);</span>
        simulator<span class="p">.</span>AddForce<span class="p">(</span>p_linear_force<span class="p">);</span>
        MAKE_PTR_ARGS<span class="p">(</span>SloughingCellKiller<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_killer<span class="p">,</span> <span class="p">(</span><span class="o">&amp;</span>cell_population<span class="p">,</span> crypt_height<span class="p">));</span>
        simulator<span class="p">.</span>AddCellKiller<span class="p">(</span>p_killer<span class="p">);</span>

        simulator<span class="p">.</span>Solve<span class="p">();</span>

        WntConcentration<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>Destroy<span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div></div>
          

    </div>
  </body>
</html>
