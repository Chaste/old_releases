<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>UserTutorials/CreatingAndUsingANewCellProperty - Chaste</title>
    <link rel="stylesheet" href="https://chaste.github.io/old_releases/trac.css" type="text/css" />
    <link rel="stylesheet" href="https://chaste.github.io/old_releases/wiki.css" type="text/css" />
    <link rel="stylesheet" href="/trac/css/site.css" type="text/css" />
    <style type="text/css">
/* Link styles */
:link, :visited, a em {
 text-decoration: none;
 color: #283f6b;
 border-bottom: 1px dotted #bbb;
}
/*
:link:hover, :visited:hover {
 background-color: #eee;
 color: #555;
}
*/
    </style>

  </head>
  <body>
    <div id="banner">
      <div id="header">
        <p>
          <a id="logo" href="https://chaste.github.io/"><img src="https://chaste.github.io/chaste_0256.png" alt="Chaste logo" height="60" /></a>
          <em>Documentation for <a href="https://chaste.github.io/old_releases/release_2.1/">Release 2.1</a>.</em>
        </p>
      </div>
    </div>
    <p>&nbsp;</p>
    <div id="content" class="wiki">
      <p class="path noprint">
        <a class="pathentry" title="View UserTutorials" href="https://chaste.github.io/old_releases/release_2.1/UserTutorials.html">UserTutorials</a><span class="pathentry sep">/</span><a class="pathentry" title="View UserTutorials/CreatingAndUsingANewCellProperty" href="https://chaste.github.io/old_releases/release_2.1/UserTutorials/CreatingAndUsingANewCellProperty.html">CreatingAndUsingANewCellProperty</a>
        <br style="clear: both" />
      </p>
      <div class="wikipage searchable">
        
          <p>
This tutorial is automatically generated from the file trunk/cell_based/test/tutorial/TestCreatingAndUsingANewCellPropertyTutorial.hpp at revision <a class="changeset" href="/cgi-bin/trac.cgi/changeset/10757" title="#1605 - fix tutorials for newer versions of Boost.

I've implemented code ...">r10757</a>.
Note that the code is given in full at the bottom of the page.
</p>
<h1 id="Anexampleshowinghowtocreateanewcellpropertyanduseitinacell-basedsimulation">An example showing how to create a new cell property and use it in a cell-based simulation</h1>
<h2 id="Introduction">Introduction</h2>
<p>
In this tutorial we show how to create a new cell property class and how this
can be used in a cell-based simulation.
</p>
<h2 id="a1.Includingheaderfiles">1. Including header files</h2>
<p>
The first thing to do is include the following header, which allows us
to use certain methods in our test (this header file should be included
in any Chaste test):
</p>
<div class="code"><pre><span class="cp">#include &lt;cxxtest/TestSuite.h&gt;
</span></pre></div><p>
The next two headers are used in archiving, and only need to be included
if you intend to archive (save or load) a cell-based simulation in this test
suite. In this case, these headers must be included before any other
serialisation headers.
</p>
<div class="code"><pre><span class="cp">#include &lt;boost/archive/text_oarchive.hpp&gt;
#include &lt;boost/archive/text_iarchive.hpp&gt;
</span></pre></div><p>
The next header defines a base class for cell properties. Our new
cell property will inherit from this abstract class.
</p>
<div class="code"><pre><span class="cp">#include "AbstractCellProperty.hpp"
</span></pre></div><p>
The remaining header files define classes that will be used in the cell population
simulation test: <tt>HoneycombMeshGenerator</tt> defines a helper class for
generating a suitable mesh; <tt>WildTypeCellMutationState</tt> defines a
wild-type or 'healthy' cell mutation state; <tt>FixedDurationGenerationBasedCellCycleModel</tt>
defines a simple cell-cycle model class, in which cells undergo a fixed number
of divisions before becoming senescent; <tt>GeneralisedLinearSpringForce</tt>
defines a force law for describing the mechanical interactions between neighbouring
cells in the cell population; and <tt>CellBasedSimulation</tt> defines the class that
simulates the evolution of the cell population.
</p>
<div class="code"><pre><span class="cp">#include "HoneycombMeshGenerator.hpp"
#include "WildTypeCellMutationState.hpp"
#include "FixedDurationGenerationBasedCellCycleModel.hpp"
#include "GeneralisedLinearSpringForce.hpp"
#include "CellBasedSimulation.hpp"
</span></pre></div><h2 id="Definingthecellpropertyclass">Defining the cell property class</h2>
<p>
As an example, let us consider a cell property class that is used to label
those cells that are "motile". This cell property could then be used when
implementing some form of chemotaxis down an imposed chemoattractant gradient,
as occurs for example when macrophages migrate within a tumour towards high
concentrations of the vascular endothelial growth factor VEGF; for further
details, see for example Owen et al, J. Theor. Biol.
226: 377-391 (2004).
</p>
<p>
Note that usually this code would be separated out into a separate declaration
in a .hpp file and definition in a .cpp file.
</p>
<div class="code"><pre><span class="k">class</span> <span class="nc">MotileCellProperty</span> <span class="o">:</span> <span class="k">public</span> AbstractCellProperty
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
</pre></div><p>
We define a member variable <tt>mColour</tt>, which can be used by visualization tools
to paint cells with this mutation state a distinct colour if required.
</p>
<div class="code"><pre>    <span class="kt">unsigned</span> mColour<span class="p">;</span>
</pre></div><p>
The next block of code allows us to archive (save or load) the cell property object
in a cell-based simulation. The code consists of a serialize() method, in which we first
archive the cell property using the serialization code defined in the base class
<tt>AbstractCellProperty</tt>, then archive the member variable <tt>mColour</tt>.
</p>
<div class="code"><pre>    <span class="k">friend</span> <span class="k">class</span> <span class="nc">boost</span><span class="o">::</span>serialization<span class="o">::</span>access<span class="p">;</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Archive</span><span class="o">&gt;</span>
    <span class="kt">void</span> serialize<span class="p">(</span>Archive <span class="o">&amp;</span> archive<span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> version<span class="p">)</span>
    <span class="p">{</span>
        archive <span class="o">&amp;</span> boost<span class="o">::</span>serialization<span class="o">::</span>base_object<span class="o">&lt;</span>AbstractCellProperty<span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
        archive <span class="o">&amp;</span> mColour<span class="p">;</span>
    <span class="p">}</span>
<span class="k">public</span><span class="o">:</span>
</pre></div><p>
The default constructor allows us to specify a value for the member variable <tt>mColour</tt>,
or leave it with a default value.
</p>
<div class="code"><pre>    MotileCellProperty<span class="p">(</span><span class="kt">unsigned</span> colour<span class="o">=</span><span class="mi">5</span><span class="p">)</span>
        <span class="o">:</span> AbstractCellProperty<span class="p">(),</span>
          mColour<span class="p">(</span>colour<span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>
</pre></div><p>
We then define a destructor and a get method for the member variable <tt>mColour</tt>.
</p>
<div class="code"><pre>    <span class="o">~</span>MotileCellProperty<span class="p">()</span>
    <span class="p">{}</span>
    <span class="kt">unsigned</span> GetColour<span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> mColour<span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div><p>
Together with the serialize() method defined within the class above, the next
block of code allows you to archive (save or load) the cell property object
in a cell-based simulation.  It is also required for writing out
the parameters file describing the settings for a simulation - it provides the unique
identifier for our new cell property.  Thus every cell property class must provide this,
or you'll get errors when running simulations.
</p>
<div class="code"><pre><span class="cp">#include "SerializationExportWrapper.hpp"
</span>CHASTE_CLASS_EXPORT<span class="p">(</span>MotileCellProperty<span class="p">)</span>
</pre></div><p>
Since we're defining the new cell property within the test file, we need to include the
following stanza as well, to make the code work with newer versions of the Boost libraries.
Normally the above export declaration would occur in the cell property's .hpp file, and
the following lines would appear in the .cpp file.  See <a class="wiki" href="https://chaste.github.io/old_releases/release_2.1/ChasteGuides/BoostSerialization.html">ChasteGuides/BoostSerialization</a> for
more information.
</p>
<div class="code"><pre><span class="cp">#include "SerializationExportWrapperForCpp.hpp"
</span>CHASTE_CLASS_EXPORT<span class="p">(</span>MotileCellProperty<span class="p">)</span>
</pre></div><p>
This completes the code for <tt>MotileCellProperty</tt>.  Note that usually this code would
be separated out into a separate declaration in a .hpp file and definition in a .cpp file.
</p>
<h3 id="TheTests">The Tests</h3>
<p>
We now define the test class, which inherits from <tt>CxxTest::TestSuite</tt>.
</p>
<div class="code"><pre><span class="k">class</span> <span class="nc">TestCreatingAndUsingANewCellPropertyTutorial</span> <span class="o">:</span> <span class="k">public</span> CxxTest<span class="o">::</span>TestSuite
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
</pre></div><h2 id="Testingthecellproperty">Testing the cell property</h2>
<p>
We begin by testing that our new cell property is implemented correctly.
</p>
<div class="code"><pre>    <span class="kt">void</span> TestMotileCellProperty<span class="p">()</span> <span class="k">throw</span><span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
</pre></div><p>
We begin by testing that some of the base class methods work correctly.
We typically use shared pointers to create and access a cell property
like <tt>MotileCellProperty</tt>, for which it makes sense for all cells
that have the same mutation to share a pointer to the same cell property
object (although strictly speaking, they are not required to). Observe that
in this case we have provided a value for the member variable <tt>mColour</tt>
in the <tt>MotileCellProperty</tt> constructor.
</p>
<div class="code"><pre>        boost<span class="o">::</span>shared_ptr<span class="o">&lt;</span>AbstractCellProperty<span class="o">&gt;</span> p_property<span class="p">(</span><span class="k">new</span> MotileCellProperty<span class="p">(</span><span class="mi">8</span><span class="p">));</span>
</pre></div><p>
Each cell property has a member variable, <tt>mCellCount</tt>, which
stores the number of cells with this cell property. We can test whether
<tt>mCellCount</tt> is being updated correctly by our cell property, as follows.
</p>
<div class="code"><pre>        TS_ASSERT_EQUALS<span class="p">(</span>p_property<span class="o">-&gt;</span>GetCellCount<span class="p">(),</span> <span class="mi">0</span>u<span class="p">);</span>
        p_property<span class="o">-&gt;</span>IncrementCellCount<span class="p">();</span>
        TS_ASSERT_EQUALS<span class="p">(</span>p_property<span class="o">-&gt;</span>GetCellCount<span class="p">(),</span> <span class="mi">1</span>u<span class="p">);</span>
        p_property<span class="o">-&gt;</span>DecrementCellCount<span class="p">();</span>
        TS_ASSERT_EQUALS<span class="p">(</span>p_property<span class="o">-&gt;</span>GetCellCount<span class="p">(),</span> <span class="mi">0</span>u<span class="p">);</span>
        TS_ASSERT_THROWS_THIS<span class="p">(</span>p_property<span class="o">-&gt;</span>DecrementCellCount<span class="p">(),</span>
                <span class="s">"Cannot decrement cell count: no cells have this cell property"</span><span class="p">);</span>
</pre></div><p>
We can also test whether our cell property is of a given type, as follows.
</p>
<div class="code"><pre>        TS_ASSERT_EQUALS<span class="p">(</span>p_property<span class="o">-&gt;</span>IsType<span class="o">&lt;</span>WildTypeCellMutationState<span class="o">&gt;</span><span class="p">(),</span> <span class="kc">false</span><span class="p">);</span>
        TS_ASSERT_EQUALS<span class="p">(</span>p_property<span class="o">-&gt;</span>IsType<span class="o">&lt;</span>MotileCellProperty<span class="o">&gt;</span><span class="p">(),</span> <span class="kc">true</span><span class="p">);</span>
</pre></div><p>
We can also test that archiving is implemented correctly for our cell
property, as follows (further details on how to implement and
test archiving can be found on the <a class="missing wiki" href="/cgi-bin/trac.cgi/wiki/BoostSerialization" rel="nofollow">BoostSerialization?</a> page).
</p>
<div class="code"><pre>        OutputFileHandler handler<span class="p">(</span><span class="s">"archive"</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
        std<span class="o">::</span>string archive_filename <span class="o">=</span> handler<span class="p">.</span>GetOutputDirectoryFullPath<span class="p">()</span> <span class="o">+</span> <span class="s">"property.arch"</span><span class="p">;</span>
        <span class="p">{</span>
            MotileCellProperty<span class="o">*</span> p_property <span class="o">=</span> <span class="k">new</span> MotileCellProperty<span class="p">(</span><span class="mi">7</span><span class="p">);</span>
            p_property<span class="o">-&gt;</span>IncrementCellCount<span class="p">();</span>
            TS_ASSERT_EQUALS<span class="p">(</span>p_property<span class="o">-&gt;</span>GetCellCount<span class="p">(),</span> <span class="mi">1</span>u<span class="p">);</span>
            TS_ASSERT_EQUALS<span class="p">(</span>p_property<span class="o">-&gt;</span>GetColour<span class="p">(),</span> <span class="mi">7</span>u<span class="p">);</span>
            std<span class="o">::</span>ofstream ofs<span class="p">(</span>archive_filename<span class="p">.</span>c_str<span class="p">());</span>
            boost<span class="o">::</span>archive<span class="o">::</span>text_oarchive output_arch<span class="p">(</span>ofs<span class="p">);</span>
            <span class="k">const</span> AbstractCellProperty<span class="o">*</span> <span class="k">const</span> p_const_property <span class="o">=</span> p_property<span class="p">;</span>
            output_arch <span class="o">&lt;&lt;</span> p_const_property<span class="p">;</span>
            <span class="k">delete</span> p_property<span class="p">;</span>
        <span class="p">}</span>
        <span class="p">{</span>
            AbstractCellProperty<span class="o">*</span> p_property<span class="p">;</span>
            std<span class="o">::</span>ifstream ifs<span class="p">(</span>archive_filename<span class="p">.</span>c_str<span class="p">());</span>
            boost<span class="o">::</span>archive<span class="o">::</span>text_iarchive input_arch<span class="p">(</span>ifs<span class="p">);</span>
            input_arch <span class="o">&gt;&gt;</span> p_property<span class="p">;</span>
            TS_ASSERT_EQUALS<span class="p">(</span>p_property<span class="o">-&gt;</span>GetCellCount<span class="p">(),</span> <span class="mi">1</span>u<span class="p">);</span>
            MotileCellProperty<span class="o">*</span> p_real_property <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span>MotileCellProperty<span class="o">*&gt;</span><span class="p">(</span>p_property<span class="p">);</span>
            TS_ASSERT<span class="p">(</span>p_real_property <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
            TS_ASSERT_EQUALS<span class="p">(</span>p_real_property<span class="o">-&gt;</span>GetColour<span class="p">(),</span> <span class="mi">7</span>u<span class="p">);</span>
            <span class="k">delete</span> p_property<span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div><h2 id="Usingthecellpropertyinacell-basedsimulation">Using the cell property in a cell-based simulation</h2>
<p>
We conclude with a brief test demonstrating how <tt>MotileCellProperty</tt> can be used
in a cell-based simulation.
</p>
<div class="code"><pre>    <span class="kt">void</span> TestCellBasedSimulationWithP53GainOfFunctionCellMutationState<span class="p">()</span> <span class="k">throw</span><span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
</pre></div><p>
We begin by setting up the start time, as follows.
</p>
<div class="code"><pre>        SimulationTime<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>SetStartTime<span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
</pre></div><p>
We use the <tt>HoneycombMeshGenerator</tt> to create a honeycomb mesh covering a
circular domain of given radius, as follows.
</p>
<div class="code"><pre>        HoneycombMeshGenerator generator<span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
        MutableMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetCircularMesh<span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</pre></div><p>
We now create a shared pointer to our new property, as follows.
</p>
<div class="code"><pre>        boost<span class="o">::</span>shared_ptr<span class="o">&lt;</span>AbstractCellProperty<span class="o">&gt;</span> p_motile<span class="p">(</span><span class="k">new</span> MotileCellProperty<span class="p">);</span>
</pre></div><p>
Next, we create some cells, as follows.
</p>
<div class="code"><pre>        boost<span class="o">::</span>shared_ptr<span class="o">&lt;</span>AbstractCellMutationState<span class="o">&gt;</span> p_state<span class="p">(</span><span class="k">new</span> WildTypeCellMutationState<span class="p">);</span>
        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> i<span class="o">=</span><span class="mi">0</span><span class="p">;</span> i<span class="o">&lt;</span>p_mesh<span class="o">-&gt;</span>GetNumNodes<span class="p">();</span> i<span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
</pre></div><p>
For each node we create a cell with our cell cycle model and the wild-type cell mutation state.
We then add the property <tt>MotileCellProperty</tt> to a random selection of the cells, as follows.
</p>
<div class="code"><pre>            FixedDurationGenerationBasedCellCycleModel<span class="o">*</span> p_model <span class="o">=</span> <span class="k">new</span> FixedDurationGenerationBasedCellCycleModel<span class="p">();</span>
            p_model<span class="o">-&gt;</span>SetCellProliferativeType<span class="p">(</span>STEM<span class="p">);</span>
            CellPropertyCollection collection<span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span>RandomNumberGenerator<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>ranf<span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">)</span>
            <span class="p">{</span>
                collection<span class="p">.</span>AddProperty<span class="p">(</span>p_motile<span class="p">);</span>
            <span class="p">}</span>
            CellPtr p_cell<span class="p">(</span><span class="k">new</span> Cell<span class="p">(</span>p_state<span class="p">,</span> p_model<span class="p">,</span> <span class="kc">false</span><span class="p">,</span> collection<span class="p">));</span>
</pre></div><p>
Now, we define a random birth time, chosen from [-T,0], where
T = t<sub>1</sub> + t<sub>2</sub>, where t<sub>1</sub> is a parameter representing the G<sub>1</sub> duration
of a stem cell, and t<sub>2</sub> is the basic S+G<sub>2</sub>+M phases duration.
</p>
<div class="code"><pre>            <span class="kt">double</span> birth_time <span class="o">=</span> <span class="o">-</span> RandomNumberGenerator<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>ranf<span class="p">()</span> <span class="o">*</span>
                                    <span class="p">(</span>p_model<span class="o">-&gt;</span>GetStemCellG1Duration<span class="p">()</span>
                                        <span class="o">+</span> p_model<span class="o">-&gt;</span>GetSG2MDuration<span class="p">());</span>
</pre></div><p>
Finally, we set the birth time and push the cell back into the vector of cells.
</p>
<div class="code"><pre>            p_cell<span class="o">-&gt;</span>SetBirthTime<span class="p">(</span>birth_time<span class="p">);</span>
            cells<span class="p">.</span>push_back<span class="p">(</span>p_cell<span class="p">);</span>
        <span class="p">}</span>
</pre></div><p>
Now that we have defined the mesh and cells, we can define the cell population. The constructor
takes in the mesh and the cells vector.
</p>
<div class="code"><pre>        MeshBasedCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">);</span>
</pre></div><p>
We pass in the cell population into a <tt>CellBasedSimulation</tt>.
</p>
<div class="code"><pre>        CellBasedSimulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> simulator<span class="p">(</span>cell_population<span class="p">);</span>
</pre></div><p>
We set the output directory and end time.
</p>
<div class="code"><pre>        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"TestCellBasedSimulationWithMotileCellProperty"</span><span class="p">);</span>
        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mf">10.0</span><span class="p">);</span>
</pre></div><p>
We must now create one or more force laws, which determine the mechanics of
the cell population. For this test, we assume that a cell experiences a force from each
neighbour that can be represented as a linear overdamped spring, and so use
a <tt>GeneralisedLinearSpringForce</tt> object. We pass a pointer to this force
into a vector. Note that we have called the method <tt>SetCutOffLength</tt> on the
<tt>GeneralisedLinearSpringForce</tt> before passing it into the collection of force
laws - this modifies the force law so that two neighbouring cells do not impose
a force on each other if they are located more than 3 units (=3 cell widths)
away from each other. This modification is necessary when no ghost nodes are used,
for example to avoid artificially large forces between cells that lie close together
on the cell population boundary.
We create a force law and pass it to the <tt>CellBasedSimulation</tt>.
</p>
<div class="code"><pre>        GeneralisedLinearSpringForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> linear_force<span class="p">;</span>
        linear_force<span class="p">.</span>SetCutOffLength<span class="p">(</span><span class="mi">3</span><span class="p">);</span>
        simulator<span class="p">.</span>AddForce<span class="p">(</span><span class="o">&amp;</span>linear_force<span class="p">);</span>
</pre></div><p>
Test that the Solve() method does not throw any exceptions.
</p>
<div class="code"><pre>        TS_ASSERT_THROWS_NOTHING<span class="p">(</span>simulator<span class="p">.</span>Solve<span class="p">());</span>
</pre></div><p>
Finally, call <tt>Destroy()</tt> on the singleton classes.
</p>
<div class="code"><pre>        SimulationTime<span class="o">::</span>Destroy<span class="p">();</span>
        RandomNumberGenerator<span class="o">::</span>Destroy<span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div><h1 id="Code">Code</h1>
<p>
The full code is given below
</p>
<h2 id="FilenameTestCreatingAndUsingANewCellPropertyTutorial.hpp">File name TestCreatingAndUsingANewCellPropertyTutorial.hpp</h2>
<div class="code"><pre><span class="cp">#include &lt;cxxtest/TestSuite.h&gt;

#include &lt;boost/archive/text_oarchive.hpp&gt;
#include &lt;boost/archive/text_iarchive.hpp&gt;

#include "AbstractCellProperty.hpp"
#include "HoneycombMeshGenerator.hpp"
#include "WildTypeCellMutationState.hpp"
#include "FixedDurationGenerationBasedCellCycleModel.hpp"
#include "GeneralisedLinearSpringForce.hpp"
#include "CellBasedSimulation.hpp"
</span>
<span class="k">class</span> <span class="nc">MotileCellProperty</span> <span class="o">:</span> <span class="k">public</span> AbstractCellProperty
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>

    <span class="kt">unsigned</span> mColour<span class="p">;</span>

    <span class="k">friend</span> <span class="k">class</span> <span class="nc">boost</span><span class="o">::</span>serialization<span class="o">::</span>access<span class="p">;</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Archive</span><span class="o">&gt;</span>
    <span class="kt">void</span> serialize<span class="p">(</span>Archive <span class="o">&amp;</span> archive<span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> version<span class="p">)</span>
    <span class="p">{</span>
        archive <span class="o">&amp;</span> boost<span class="o">::</span>serialization<span class="o">::</span>base_object<span class="o">&lt;</span>AbstractCellProperty<span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
        archive <span class="o">&amp;</span> mColour<span class="p">;</span>
    <span class="p">}</span>

<span class="k">public</span><span class="o">:</span>

    MotileCellProperty<span class="p">(</span><span class="kt">unsigned</span> colour<span class="o">=</span><span class="mi">5</span><span class="p">)</span>
        <span class="o">:</span> AbstractCellProperty<span class="p">(),</span>
          mColour<span class="p">(</span>colour<span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="o">~</span>MotileCellProperty<span class="p">()</span>
    <span class="p">{}</span>

    <span class="kt">unsigned</span> GetColour<span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> mColour<span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="cp">
#include "SerializationExportWrapper.hpp"
</span>CHASTE_CLASS_EXPORT<span class="p">(</span>MotileCellProperty<span class="p">)</span>
<span class="cp">
#include "SerializationExportWrapperForCpp.hpp"
</span>CHASTE_CLASS_EXPORT<span class="p">(</span>MotileCellProperty<span class="p">)</span>

<span class="k">class</span> <span class="nc">TestCreatingAndUsingANewCellPropertyTutorial</span> <span class="o">:</span> <span class="k">public</span> CxxTest<span class="o">::</span>TestSuite
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

    <span class="kt">void</span> TestMotileCellProperty<span class="p">()</span> <span class="k">throw</span><span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
        boost<span class="o">::</span>shared_ptr<span class="o">&lt;</span>AbstractCellProperty<span class="o">&gt;</span> p_property<span class="p">(</span><span class="k">new</span> MotileCellProperty<span class="p">(</span><span class="mi">8</span><span class="p">));</span>

        TS_ASSERT_EQUALS<span class="p">(</span>p_property<span class="o">-&gt;</span>GetCellCount<span class="p">(),</span> <span class="mi">0</span>u<span class="p">);</span>
        p_property<span class="o">-&gt;</span>IncrementCellCount<span class="p">();</span>
        TS_ASSERT_EQUALS<span class="p">(</span>p_property<span class="o">-&gt;</span>GetCellCount<span class="p">(),</span> <span class="mi">1</span>u<span class="p">);</span>
        p_property<span class="o">-&gt;</span>DecrementCellCount<span class="p">();</span>
        TS_ASSERT_EQUALS<span class="p">(</span>p_property<span class="o">-&gt;</span>GetCellCount<span class="p">(),</span> <span class="mi">0</span>u<span class="p">);</span>
        TS_ASSERT_THROWS_THIS<span class="p">(</span>p_property<span class="o">-&gt;</span>DecrementCellCount<span class="p">(),</span>
                <span class="s">"Cannot decrement cell count: no cells have this cell property"</span><span class="p">);</span>

        TS_ASSERT_EQUALS<span class="p">(</span>p_property<span class="o">-&gt;</span>IsType<span class="o">&lt;</span>WildTypeCellMutationState<span class="o">&gt;</span><span class="p">(),</span> <span class="kc">false</span><span class="p">);</span>
        TS_ASSERT_EQUALS<span class="p">(</span>p_property<span class="o">-&gt;</span>IsType<span class="o">&lt;</span>MotileCellProperty<span class="o">&gt;</span><span class="p">(),</span> <span class="kc">true</span><span class="p">);</span>

        OutputFileHandler handler<span class="p">(</span><span class="s">"archive"</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
        std<span class="o">::</span>string archive_filename <span class="o">=</span> handler<span class="p">.</span>GetOutputDirectoryFullPath<span class="p">()</span> <span class="o">+</span> <span class="s">"property.arch"</span><span class="p">;</span>

        <span class="p">{</span>
            MotileCellProperty<span class="o">*</span> p_property <span class="o">=</span> <span class="k">new</span> MotileCellProperty<span class="p">(</span><span class="mi">7</span><span class="p">);</span>
            p_property<span class="o">-&gt;</span>IncrementCellCount<span class="p">();</span>

            TS_ASSERT_EQUALS<span class="p">(</span>p_property<span class="o">-&gt;</span>GetCellCount<span class="p">(),</span> <span class="mi">1</span>u<span class="p">);</span>
            TS_ASSERT_EQUALS<span class="p">(</span>p_property<span class="o">-&gt;</span>GetColour<span class="p">(),</span> <span class="mi">7</span>u<span class="p">);</span>

            std<span class="o">::</span>ofstream ofs<span class="p">(</span>archive_filename<span class="p">.</span>c_str<span class="p">());</span>
            boost<span class="o">::</span>archive<span class="o">::</span>text_oarchive output_arch<span class="p">(</span>ofs<span class="p">);</span>

            <span class="k">const</span> AbstractCellProperty<span class="o">*</span> <span class="k">const</span> p_const_property <span class="o">=</span> p_property<span class="p">;</span>
            output_arch <span class="o">&lt;&lt;</span> p_const_property<span class="p">;</span>

            <span class="k">delete</span> p_property<span class="p">;</span>
        <span class="p">}</span>

        <span class="p">{</span>
            AbstractCellProperty<span class="o">*</span> p_property<span class="p">;</span>

            std<span class="o">::</span>ifstream ifs<span class="p">(</span>archive_filename<span class="p">.</span>c_str<span class="p">());</span>
            boost<span class="o">::</span>archive<span class="o">::</span>text_iarchive input_arch<span class="p">(</span>ifs<span class="p">);</span>

            input_arch <span class="o">&gt;&gt;</span> p_property<span class="p">;</span>

            TS_ASSERT_EQUALS<span class="p">(</span>p_property<span class="o">-&gt;</span>GetCellCount<span class="p">(),</span> <span class="mi">1</span>u<span class="p">);</span>

            MotileCellProperty<span class="o">*</span> p_real_property <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span>MotileCellProperty<span class="o">*&gt;</span><span class="p">(</span>p_property<span class="p">);</span>
            TS_ASSERT<span class="p">(</span>p_real_property <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
            TS_ASSERT_EQUALS<span class="p">(</span>p_real_property<span class="o">-&gt;</span>GetColour<span class="p">(),</span> <span class="mi">7</span>u<span class="p">);</span>

            <span class="k">delete</span> p_property<span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> TestCellBasedSimulationWithP53GainOfFunctionCellMutationState<span class="p">()</span> <span class="k">throw</span><span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
        SimulationTime<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>SetStartTime<span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>

        HoneycombMeshGenerator generator<span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
        MutableMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetCircularMesh<span class="p">(</span><span class="mi">5</span><span class="p">);</span>

        boost<span class="o">::</span>shared_ptr<span class="o">&lt;</span>AbstractCellProperty<span class="o">&gt;</span> p_motile<span class="p">(</span><span class="k">new</span> MotileCellProperty<span class="p">);</span>

        boost<span class="o">::</span>shared_ptr<span class="o">&lt;</span>AbstractCellMutationState<span class="o">&gt;</span> p_state<span class="p">(</span><span class="k">new</span> WildTypeCellMutationState<span class="p">);</span>
        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> i<span class="o">=</span><span class="mi">0</span><span class="p">;</span> i<span class="o">&lt;</span>p_mesh<span class="o">-&gt;</span>GetNumNodes<span class="p">();</span> i<span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            FixedDurationGenerationBasedCellCycleModel<span class="o">*</span> p_model <span class="o">=</span> <span class="k">new</span> FixedDurationGenerationBasedCellCycleModel<span class="p">();</span>
            p_model<span class="o">-&gt;</span>SetCellProliferativeType<span class="p">(</span>STEM<span class="p">);</span>

            CellPropertyCollection collection<span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span>RandomNumberGenerator<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>ranf<span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">)</span>
            <span class="p">{</span>
                collection<span class="p">.</span>AddProperty<span class="p">(</span>p_motile<span class="p">);</span>
            <span class="p">}</span>

            CellPtr p_cell<span class="p">(</span><span class="k">new</span> Cell<span class="p">(</span>p_state<span class="p">,</span> p_model<span class="p">,</span> <span class="kc">false</span><span class="p">,</span> collection<span class="p">));</span>

            <span class="kt">double</span> birth_time <span class="o">=</span> <span class="o">-</span> RandomNumberGenerator<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>ranf<span class="p">()</span> <span class="o">*</span>
                                    <span class="p">(</span>p_model<span class="o">-&gt;</span>GetStemCellG1Duration<span class="p">()</span>
                                        <span class="o">+</span> p_model<span class="o">-&gt;</span>GetSG2MDuration<span class="p">());</span>

            p_cell<span class="o">-&gt;</span>SetBirthTime<span class="p">(</span>birth_time<span class="p">);</span>
            cells<span class="p">.</span>push_back<span class="p">(</span>p_cell<span class="p">);</span>
        <span class="p">}</span>

        MeshBasedCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">);</span>

        CellBasedSimulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> simulator<span class="p">(</span>cell_population<span class="p">);</span>

        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"TestCellBasedSimulationWithMotileCellProperty"</span><span class="p">);</span>
        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mf">10.0</span><span class="p">);</span>

        GeneralisedLinearSpringForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> linear_force<span class="p">;</span>
        linear_force<span class="p">.</span>SetCutOffLength<span class="p">(</span><span class="mi">3</span><span class="p">);</span>
        simulator<span class="p">.</span>AddForce<span class="p">(</span><span class="o">&amp;</span>linear_force<span class="p">);</span>

        TS_ASSERT_THROWS_NOTHING<span class="p">(</span>simulator<span class="p">.</span>Solve<span class="p">());</span>

        SimulationTime<span class="o">::</span>Destroy<span class="p">();</span>
        RandomNumberGenerator<span class="o">::</span>Destroy<span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
        
        
      </div>

    </div>
  </body>
</html>
