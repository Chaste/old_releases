<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
 <title>Chaste User Tutorial</title>
 <link rel="stylesheet" href="https://chaste.github.io/old_releases/trac.css" type="text/css" />
 <link rel="stylesheet" href="https://chaste.github.io/old_releases/wiki.css" type="text/css" />


 <style type="text/css">
/* Link styles */
:link, :visited, a em {
 text-decoration: none;
 color: #283f6b;
 border-bottom: 1px dotted #bbb;
}
/*
:link:hover, :visited:hover {
 background-color: #eee;
 color: #555;
}
*/
</style>

</head>
<body>
<a id="logo" href="https://chaste.github.io/">
  <img src="https://chaste.github.io/chaste_0256.png" alt="Chaste logo" height="60" />
</a>
<h1> SolvingLinearPdes tutorial file </h1></div>

<div id="content" class="wiki">

 
  
  
   <div class="wikipage">
    <div id="searchable"><p>
This tutorial is automatically generated from the file trunk/pde/test/TestSolvingLinearPdesTutorial.hpp at revision <a class="changeset" title="Updated ode and linear PDEs tutorials" href="/cgi-bin/trac.cgi/changeset/5474">r5474</a>.
Note that the code is given in full at the bottom of the page.
</p>
<h1 id="ExamplesshowinghowtosolvelinearellipticandparabolicPDEs">Examples showing how to solve linear elliptic and parabolic PDEs</h1>
<p>
In this tutorial we show how Chaste can be used to solve linear PDEs. The first test
uses the <tt>SimpleLinearEllipticAssembler</tt> to solve a linear elliptic PDE, and the
second test uses the <tt>SimpleDg0ParabolicAssembler</tt> to solve a parabolic time-dependent
linear PDE
</p>
<p>
The following header files need to be included.
First we include the header needed to define this class as a test suite 
</p>
<div class="code"><pre>#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&lt;cxxtest/TestSuite.h&gt;</span></B>
</pre></div><p>
On some systems there is a clash between Boost Ublas includes and PETSc.  This can be
resolved by making sure that Chaste's interface to the Boost libraries are included
as early as possible.
</p>
<div class="code"><pre>#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;UblasCustomFunctions.hpp&quot;</span></B>
</pre></div><p>
This is the class that is needed to solve a linear elliptic pde 
</p>
<div class="code"><pre>#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;SimpleLinearEllipticAssembler.hpp&quot;</span></B>
</pre></div><p>
This is the class that is needed to solve a linear parabolic PDE 
</p>
<div class="code"><pre>#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;SimpleDg0ParabolicAssembler.hpp&quot;</span></B>
</pre></div><p>
This is a parabolic PDE, one of the PDEs we will solve 
</p>
<div class="code"><pre>#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;HeatEquationWithSourceTerm.hpp&quot;</span></B>
</pre></div><p>
We will also solve this PDE 
</p>
<div class="code"><pre>#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;SimplePoissonEquation.hpp&quot;</span></B>
</pre></div><p>
This is needed to read mesh datafiles of the 'Triangles' format 
</p>
<div class="code"><pre>#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;TrianglesMeshReader.hpp&quot;</span></B>
</pre></div><p>
This class represents the mesh internally 
</p>
<div class="code"><pre>#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;TetrahedralMesh.hpp&quot;</span></B>
</pre></div><p>
These are used to specify boundary conditions for the PDEs 
</p>
<div class="code"><pre>#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;BoundaryConditionsContainer.hpp&quot;</span></B>
#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;ConstBoundaryCondition.hpp&quot;</span></B>
</pre></div><p>
This class helps us deal with output files 
</p>
<div class="code"><pre>#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;OutputFileHandler.hpp&quot;</span></B>
</pre></div><p>
PetscSetupAndFinalize.hpp must be included in every test that uses PETSc. Note that it
cannot be included in the source code. 
</p>
<div class="code"><pre>#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;PetscSetupAndFinalize.hpp&quot;</span></B>
</pre></div><h2 id="Test1:SolvingalinearellipticPDE">Test 1: Solving a linear elliptic PDE</h2>
<p>
Here, we solve the PDE: div(D grad u) + u = x<sup>2</sup>+y<sup>2</sup>, in 2D, where
D is the diffusion tensor (1 1; 0 1) (ie D11=D12=D22=1, D21=0), on a square
domain, with boundary conditions u=0 on x=0 or y=0, and (D grad u).n = 0 on x=1 and y=1,
where n is the surface normal.
</p>
<p>
We need to create a class representing the PDE we want to solve, which will be
passed into the solver. The PDE we are solving is of the type
<tt>AbstractLinearEllipticPde</tt>, which is an abstract class with 3 pure methods
which have to implemented. The template variables in the following line are both the dimension
of the space.
</p>
<div class="code"><pre>class MyPde : public AbstractLinearEllipticPde&lt;2,2&gt;
{
<B><span class="code-keyword">private</span></B>:
</pre></div><p>
For efficiency, we will save the diffusion tensor that will be returned by one of the
class' methods as a member variable. The diffusion tensor which has to be returned
by the <tt>GetDiffusionTensor</tt> method in PDE classes is of the type
<tt>c_matrix&lt;double,SIZE,SIZE&gt;</tt>, which is a u-blas matrix. We use ublas vectors
and matrices where small vectors and matrices are needed. Note that ublas objects
are only particularly efficient if optimisation is on (<tt>scons build=GccOpt ..</tt>).
</p>
<div class="code"><pre>    c_matrix&lt;<span class="code-type"><B>double</span></B>,2,2&gt; mDiffusionTensor;
<B><span class="code-keyword">public</span></B>:
</pre></div><p>
The constructor just sets up the diffusion tensor. 
</p>
<div class="code"><pre>    MyPde()
    {
        mDiffusionTensor(0,0) = 1.0;
        mDiffusionTensor(0,1) = 1.0;
        mDiffusionTensor(1,0) = 0.0;
        mDiffusionTensor(1,1) = 1.0;
    }
</pre></div><p>
The first method which has to be implemented returns the constant
(not dependent on u) part of the source term, which for our PDE is
x<sup>2</sup> + y<sup>2</sup> 
</p>
<div class="code"><pre>    <span class="code-type"><B>double</span></B> ComputeConstantInUSourceTerm(<span class="code-type"><B>const</span></B> ChastePoint&lt;2&gt;&amp; rX)
    {
        <B><span class="code-lang">return</span></B> rX[0]*rX[0] + rX[1]*rX[1];
    }
</pre></div><p>
The second method which has to be implemented returns the coefficient in the linear-in-u
part of the source term, which for our PDE is just 1.0 
</p>
<div class="code"><pre>    <span class="code-type"><B>double</span></B> ComputeLinearInUCoeffInSourceTerm(<span class="code-type"><B>const</span></B> ChastePoint&lt;2&gt;&amp; rX, Element&lt;2,2&gt;* pElement)
    {
        <B><span class="code-lang">return</span></B> 1.0;
    }
</pre></div><p>
The third method returns the diffusion tensor D 
</p>
<div class="code"><pre>    c_matrix&lt;<span class="code-type"><B>double</span></B>,2,2&gt; ComputeDiffusionTerm(<span class="code-type"><B>const</span></B> ChastePoint&lt;2&gt;&amp; rX)
    {
        <B><span class="code-lang">return</span></B> mDiffusionTensor;
    }
};
</pre></div><p>
Next, we define the test suite (a class). It is sensible to name it the same
as the filename. The class should inherit from <tt>CxxTest::TestSuite</tt> 
</p>
<div class="code"><pre>class TestSolvingLinearPdesTutorial : public <B><span class="code-keyword">CxxTest</span></B>::TestSuite
{
</pre></div><p>
All individual test defined in this test suite <strong>must</strong> be declared as public 
</p>
<div class="code"><pre><B><span class="code-keyword">public</span></B>:
</pre></div><p>
Define a particular test 
</p>
<div class="code"><pre>    <span class="code-type"><B>void</span></B> TestSolvingEllipticPde()
    {
</pre></div><p>
First we declare a mesh reader which reads mesh data files of the 'Triangle'
format. The path given is the relative to the main Chaste directory. The reader
will look for three datafiles, [name].nodes, [name].ele and (in 2d or 3d)
[name].edge. Note that the first template argument here is the dimension of the
elements in the mesh (<tt>ELEM_DIM</tt>), and the second is the dimension of the nodes,
i.e. the dimension of the space the mesh lives in (<tt>SPACE_DIM</tt>). Usually
<tt>ELEM_DIM</tt> and <tt>SPACE_DIM</tt> will be equal. 
</p>
<div class="code"><pre>        TrianglesMeshReader&lt;2,2&gt; mesh_reader(<span class="code-string"><B>&quot;mesh/test/data/square_128_elements&quot;</span></B>);
</pre></div><p>
Now declare a tetrahedral mesh with the same dimensions 
</p>
<div class="code"><pre>        TetrahedralMesh&lt;2,2&gt; mesh;
</pre></div><p>
Construct the mesh using the mesh reader 
</p>
<div class="code"><pre>        mesh.ConstructFromMeshReader(mesh_reader);
</pre></div><p>
Next we instantiate an instance of our PDE we which to solve 
</p>
<div class="code"><pre>        MyPde pde;
</pre></div><p>
A set of boundary conditions are stored in a <tt>BoundaryConditionsContainer</tt>. The
three template arguments are ELEM_DIM, SPACE_DIM and PROBLEM_DIM, the latter being
the number of unknowns we are solving for. We have one unknown (ie u is a scalar, not
a vector), so in this case <tt>PROBLEM_DIM</tt>=1. 
</p>
<div class="code"><pre>        BoundaryConditionsContainer&lt;2,2,1&gt; bcc;
</pre></div><p>
Defining the boundary conditions is the only particularly fiddly part of solving PDEs,
unless they are very simple, such as u=0 on the boundary, which could be done
as follows 
</p>
<div class="code"><pre>        <I><span class="code-comment">//bcc.DefineZeroDirichletOnMeshBoundary(&amp;mesh);
</span></I>
</pre></div><p>
We want to specify u=0 on x=0 and y=0. To do this, get a boundary node iterator
from the mesh 
</p>
<div class="code"><pre>        TetrahedralMesh&lt;2,2&gt;::BoundaryNodeIterator iter
           = mesh.GetBoundaryNodeIteratorBegin();
</pre></div><p>
Then loop over the boundary nodes, getting the x and y value 
</p>
<div class="code"><pre>        <B><span class="code-lang">while</span></B> (iter &lt; mesh.GetBoundaryNodeIteratorEnd())
        {
            <span class="code-type"><B>double</span></B> x = (*iter)-&gt;GetPoint()[0];
            <span class="code-type"><B>double</span></B> y = (*iter)-&gt;GetPoint()[1];
</pre></div><p>
if x=0 or y=0.. 
</p>
<div class="code"><pre>            <B><span class="code-lang">if</span></B>((x==0) || (y==0))
            {
</pre></div><p>
..create a new <tt>ConstBoundaryConditions</tt> object. This is a subclass of
<tt>AbstractBoundaryCondition</tt>, and tells the caller what value to return
given a particular point in space. In the first line below we say that value
should be 0.0. The second line tells the <tt>BoundaryConditionsContainer</tt>
object that it should associate this boundary condition with this node
(<tt>*iter</tt> being a pointer to a <tt>Node&lt;2&gt;</tt>).
</p>
<div class="code"><pre>                ConstBoundaryCondition&lt;2&gt;* p_dirichlet_boundary_condition = new ConstBoundaryCondition&lt;2&gt;(0.0);
                bcc.AddDirichletBoundaryCondition(*iter, p_dirichlet_boundary_condition);
            }
            iter++;
        }
</pre></div><p>
Now we create Neumann boundary conditions for the <i>surface elements</i> on x=1 and y=1. Note that
Dirichlet boundary conditions are defined on nodes, whereas Neumann boundary conditions are
defined on surface elements. Note also that the natural boundary condition statement for this
PDE is (D grad u).n = g(x) (where n is the outward-facing surface normal), and g(x) is a prescribed
function, <i>not</i> something like du/dn=g(x). Hence the boundary condition we are specifying is
(D grad u).n = 0.
</p>
<p>
<strong>Important note for 1D:</strong> This means that if we were solving 2u<sub>xx</sub>=f(x) in 1D, and
wanted to specify du/dx=1 on the LHS boundary, the Neumann boundary value we have to specify is
-2, as n=-1 (outward facing normal) so (D gradu).n = -2 when du/dx=1.
</p>
<p>
To define Neumann bcs, we define another constant boundary condition object (created using
<tt>new</tt> - note that the <tt>BoundaryConditionsContainer</tt> object deals with deleting
its <tt>AbstractBoundaryCondition</tt> objects), and then loop over surface elements, using the
iterator provided by the mesh class.
</p>
<div class="code"><pre>        ConstBoundaryCondition&lt;2&gt;* p_neumann_boundary_condition = new ConstBoundaryCondition&lt;2&gt;(0.0);
        TetrahedralMesh&lt;2,2&gt;::BoundaryElementIterator surf_iter
          = mesh.GetBoundaryElementIteratorBegin();
        <B><span class="code-lang">while</span></B> (surf_iter &lt; mesh.GetBoundaryElementIteratorEnd())
        {
</pre></div><p>
Get the x and y values of any node (here, the 0th) in the element 
</p>
<div class="code"><pre>            <span class="code-type"><B>unsigned</span></B> node_index = (*surf_iter)-&gt;GetNodeGlobalIndex(0);
            <span class="code-type"><B>double</span></B> x = mesh.GetNode(node_index)-&gt;GetPoint()[0];
            <span class="code-type"><B>double</span></B> y = mesh.GetNode(node_index)-&gt;GetPoint()[1];
</pre></div><p>
if x=1 or y=1.. 
</p>
<div class="code"><pre>            <B><span class="code-lang">if</span></B>( (fabs(x-1.0) &lt; 1e-6) || (fabs(y-1.0) &lt; 1e-6) )
            {
</pre></div><p>
associate the boundary condition with the surface element 
</p>
<div class="code"><pre>                bcc.AddNeumannBoundaryCondition(*surf_iter, p_neumann_boundary_condition);
            }
</pre></div><p>
and increment the iterator 
</p>
<div class="code"><pre>            surf_iter++;
        }
</pre></div><p>
Next we define the assembler - the solver of the PDE. (Assembler is a bit of a
misnomer - assemblers both assemble the finite element equations, and solve them.
To solve <tt>AbstractLinearEllipticPde</tt> (which is the type of pde <tt>MyPde</tt> is),
we use a <tt>SimpleLinearEllipticAssembler</tt>. The assembler, again templated over
<tt>ELEM_DIM</tt> and <tt>SPACE_DIM</tt>, needs to be given (pointers to) the mesh,
pde and boundary conditions.
</p>
<div class="code"><pre>        SimpleLinearEllipticAssembler&lt;2,2&gt; assembler(&amp;mesh,&amp;pde,&amp;bcc);
</pre></div><p>
To solve, just call <tt>Solve()</tt>. A Petsc vector is returned. 
</p>
<div class="code"><pre>        Vec result = assembler.Solve();
</pre></div><p>
It is a pain to access the individual components of a Petsc vector, even in
sequential. A helper class called <tt>ReplicatableVector</tt> has been created. Create
an instance of one of these, using the Petsc <tt>Vec</tt> as the data. The ith
component of <tt>result</tt> can now be obtained by simply doing <tt>result_repl[i]</tt>.
</p>
<div class="code"><pre>        ReplicatableVector result_repl(result);
</pre></div><p>
Let us write out the solution to a file. To do this, create an
<tt>OutputFileHandler</tt>, passing in the directory we want files written to.
This is relative to the directory defined by the CHASTE_TEST_OUTPUT environment
variable - usually /tmp/chaste/testoutput. Note by default the output directory
passed in is cleaned. To avoid this, <tt>false</tt> can be passed in as a second
parameter
</p>
<div class="code"><pre>        OutputFileHandler output_file_handler(<span class="code-string"><B>&quot;TestSolvingLinearPdeTutorial&quot;</span></B>);
</pre></div><p>
Create an <tt>out_stream</tt>, which is a stream to a particular file. An <tt>out_stream</tt>
is a pointer to a ofstream 
</p>
<div class="code"><pre>        out_stream p_file = output_file_handler.OpenOutputFile(<span class="code-string"><B>&quot;linear_solution.txt&quot;</span></B>);
</pre></div><p>
Loop over the entries of the solution 
</p>
<div class="code"><pre>        <B><span class="code-lang">for</span></B> (<span class="code-type"><B>unsigned</span></B> i=0; i&lt;result_repl.size(); i++)
        {
</pre></div><p>
Get the x and y-values of the node corresponding to this entry. The method
<tt>GetNode</tt> on the mesh class returns a pointer to a <tt>Node</tt> 
</p>
<div class="code"><pre>            <span class="code-type"><B>double</span></B> x = mesh.GetNode(i)-&gt;rGetLocation()[0];
            <span class="code-type"><B>double</span></B> y = mesh.GetNode(i)-&gt;rGetLocation()[1];
</pre></div><p>
Get the computed solution at this node from the <tt>ReplicatableVector</tt> 
</p>
<div class="code"><pre>            <span class="code-type"><B>double</span></B> u = result_repl[i];
</pre></div><p>
Finally, write x, y and u to the output file. The solution could then be
visualised in (eg) matlab, using the commands:
<tt>sol=load('linear_solution.txt'); plot3(sol(:,1),sol(:,2),sol(:,3),'.');</tt>
</p>
<div class="code"><pre>            (*p_file) &lt;&lt; x &lt;&lt; <span class="code-string"><B>&quot; &quot;</span></B> &lt;&lt; y &lt;&lt; <span class="code-string"><B>&quot; &quot;</span></B> &lt;&lt; u &lt;&lt; <span class="code-string"><B>&quot;\n&quot;</span></B>;
        }
</pre></div><p>
All Petsc <tt>Vec</tt>s should be destroyed when they are no longer needed 
</p>
<div class="code"><pre>        VecDestroy(result);
    }
</pre></div><h2 id="Test2:SolvingalinearparabolicPDE">Test 2: Solving a linear parabolic PDE</h2>
<p>
Now we solve a parabolic PDE. We choose a simple problem so that the code changes
needed from the elliptic case are clearer. We will solve
du/dt = div(grad u) + u, in 3d, with boundary conditions u=1 on the boundary, and initial
conditions u=1
</p>
<div class="code"><pre>    <span class="code-type"><B>void</span></B> TestSolvingParabolicPde( <span class="code-type"><B>void</span></B> )
    {
</pre></div><p>
Create a 10 by 10 by 10 mesh in 3D, this time using the <tt>ConstructCuboid</tt> method
on the mesh. 
</p>
<div class="code"><pre>        TetrahedralMesh&lt;3,3&gt; mesh;
        mesh.ConstructCuboid(10,10,10);
</pre></div><p>
This returns a mesh over the region [0,10]<sup>3</sup> with 10 elements in each direction, so
we have to scale it down to [0,1]<sup>3</sup> 
</p>
<div class="code"><pre>        mesh.Scale(1.0/10, 1.0/10, 1.0/10);
</pre></div><p>
Our PDE object should be a class that is derived from the <tt>AbstractLinearParabolicPde</tt>.
We could write it ourselves as in the previous test, but since the PDE we want to solve is
so simple, it has already been defined (look it up! - it is located in pde/test/pdes)
</p>
<div class="code"><pre>        HeatEquationWithSourceTerm&lt;3&gt; pde;
</pre></div><p>
Create a new boundary conditions container and specify u=1.0 on the boundary 
</p>
<div class="code"><pre>        BoundaryConditionsContainer&lt;3,3,1&gt; bcc;
        bcc.DefineConstantDirichletOnMeshBoundary(&amp;mesh, 1.0);
</pre></div><p>
Create an instance of the assembler, passing in the mesh, pde and boundary conditions.
The '<tt>true</tt>' template parameter says this is a NON_HEART problem (so the certain
optimisations for cardiac problems are not used). 
</p>
<div class="code"><pre>        SimpleDg0ParabolicAssembler&lt;3,3,true&gt; assembler(&amp;mesh,&amp;pde,&amp;bcc);
</pre></div><p>
For parabolic problems, initial conditions are also needed. The assembler will expect
a Petsc vector, where the i-th entry is the initial solution at node i, to be passed
in. To create this Petsc <tt>Vec</tt>, we will use a helper function in the <tt>PetscTools</tt>
class to create a <tt>Vec</tt> of size num_nodes, with each entry set to 1.0. Then we
set the initial condition on the assembler 
</p>
<div class="code"><pre>        Vec initial_condition = <B><span class="code-keyword">PetscTools</span></B>::CreateVec(mesh.GetNumNodes(), 1.0);
        assembler.SetInitialCondition(initial_condition);
</pre></div><p>
Next define the start time, end time, and timestep, and set them. 
</p>
<div class="code"><pre>        <span class="code-type"><B>double</span></B> t_start = 0;
        <span class="code-type"><B>double</span></B> t_end = 1;
        <span class="code-type"><B>double</span></B> dt = 0.01;
        assembler.SetTimes(t_start, t_end, dt);
</pre></div><p>
Now we can solve the problem. The <tt>Vec</tt> that is returned can be passed into a
<tt>ReplicatableVector</tt> as before
</p>
<div class="code"><pre>        Vec solution = assembler.Solve();
        ReplicatableVector solution_repl(solution);
</pre></div><p>
<strong>Important note</strong>: for efficiency reasons, we assume the matrix that is set up when
solving parabolic equations with the finite element method is constant and only thus
needs to be assembled in the first timestep. If you end up solving a more complicated
PDE with (for example) time-dependent diffusion tensors where the matrix is not constant
in time, you must do: <tt>assembler.SetMatrixIsConstant(false)</tt> before calling <tt>Solve</tt>.
Let's also solve the equivalent static PDE, ie set du/dt=0, so 0=div(gradu) + u. This
is easy, as the PDE class has already been defined 
</p>
<div class="code"><pre>        SimplePoissonEquation&lt;3,3&gt; static_pde;
        SimpleLinearEllipticAssembler&lt;3,3&gt; static_assembler(&amp;mesh, &amp;static_pde, &amp;bcc);
        Vec static_solution = static_assembler.Solve();
        ReplicatableVector static_solution_repl(static_solution);
</pre></div><p>
We can now compare the solution of the parabolic PDE at t=1 with the static solution,
to see if the static equilibrium solution was reached in the former. (Ideally we should
compute some relative error, but we just compute an absolute error for simplicity). 
</p>
<div class="code"><pre>        <B><span class="code-lang">for</span></B>(<span class="code-type"><B>unsigned</span></B> i=0; i&lt;static_solution_repl.size(); i++)
        {
            TS_ASSERT_DELTA( solution_repl[i], static_solution_repl[i], 1e-3);
        }
</pre></div><p>
All Petsc vectors should be destroyed when they are no longer needed 
</p>
<div class="code"><pre>        VecDestroy(initial_condition);
        VecDestroy(solution);
        VecDestroy(static_solution);
    }
};
</pre></div><h1 id="Code">Code</h1>
<p>
The full code is given below
</p>
<div class="code"><pre>#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&lt;cxxtest/TestSuite.h&gt;</span></B>
#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;UblasCustomFunctions.hpp&quot;</span></B>
#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;SimpleLinearEllipticAssembler.hpp&quot;</span></B>
#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;SimpleDg0ParabolicAssembler.hpp&quot;</span></B>
#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;HeatEquationWithSourceTerm.hpp&quot;</span></B>
#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;SimplePoissonEquation.hpp&quot;</span></B>
#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;TrianglesMeshReader.hpp&quot;</span></B>
#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;TetrahedralMesh.hpp&quot;</span></B>
#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;BoundaryConditionsContainer.hpp&quot;</span></B>
#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;ConstBoundaryCondition.hpp&quot;</span></B>
#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;OutputFileHandler.hpp&quot;</span></B>
#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;PetscSetupAndFinalize.hpp&quot;</span></B>

class MyPde : public AbstractLinearEllipticPde&lt;2,2&gt;
{
<B><span class="code-keyword">private</span></B>:
    c_matrix&lt;<span class="code-type"><B>double</span></B>,2,2&gt; mDiffusionTensor;

<B><span class="code-keyword">public</span></B>:
    MyPde()
    {
        mDiffusionTensor(0,0) = 1.0;
        mDiffusionTensor(0,1) = 1.0;
        mDiffusionTensor(1,0) = 0.0;
        mDiffusionTensor(1,1) = 1.0;
    }

    <span class="code-type"><B>double</span></B> ComputeConstantInUSourceTerm(<span class="code-type"><B>const</span></B> ChastePoint&lt;2&gt;&amp; rX)
    {
        <B><span class="code-lang">return</span></B> rX[0]*rX[0] + rX[1]*rX[1];
    }

    <span class="code-type"><B>double</span></B> ComputeLinearInUCoeffInSourceTerm(<span class="code-type"><B>const</span></B> ChastePoint&lt;2&gt;&amp; rX, Element&lt;2,2&gt;* pElement)
    {
        <B><span class="code-lang">return</span></B> 1.0;
    }

    c_matrix&lt;<span class="code-type"><B>double</span></B>,2,2&gt; ComputeDiffusionTerm(<span class="code-type"><B>const</span></B> ChastePoint&lt;2&gt;&amp; rX)
    {
        <B><span class="code-lang">return</span></B> mDiffusionTensor;
    }
};

class TestSolvingLinearPdesTutorial : public <B><span class="code-keyword">CxxTest</span></B>::TestSuite
{
<B><span class="code-keyword">public</span></B>:
    <span class="code-type"><B>void</span></B> TestSolvingEllipticPde()
    {
        TrianglesMeshReader&lt;2,2&gt; mesh_reader(<span class="code-string"><B>&quot;mesh/test/data/square_128_elements&quot;</span></B>);
        TetrahedralMesh&lt;2,2&gt; mesh;
        mesh.ConstructFromMeshReader(mesh_reader);

        MyPde pde;

        BoundaryConditionsContainer&lt;2,2,1&gt; bcc;

        <I><span class="code-comment">//bcc.DefineZeroDirichletOnMeshBoundary(&amp;mesh);
</span></I>
        TetrahedralMesh&lt;2,2&gt;::BoundaryNodeIterator iter
           = mesh.GetBoundaryNodeIteratorBegin();
        <B><span class="code-lang">while</span></B> (iter &lt; mesh.GetBoundaryNodeIteratorEnd())
        {
            <span class="code-type"><B>double</span></B> x = (*iter)-&gt;GetPoint()[0];
            <span class="code-type"><B>double</span></B> y = (*iter)-&gt;GetPoint()[1];
            <B><span class="code-lang">if</span></B>((x==0) || (y==0))
            {
                ConstBoundaryCondition&lt;2&gt;* p_dirichlet_boundary_condition = new ConstBoundaryCondition&lt;2&gt;(0.0);
                bcc.AddDirichletBoundaryCondition(*iter, p_dirichlet_boundary_condition);
            }
            iter++;
        }

        ConstBoundaryCondition&lt;2&gt;* p_neumann_boundary_condition = new ConstBoundaryCondition&lt;2&gt;(0.0);

        TetrahedralMesh&lt;2,2&gt;::BoundaryElementIterator surf_iter
          = mesh.GetBoundaryElementIteratorBegin();
        <B><span class="code-lang">while</span></B> (surf_iter &lt; mesh.GetBoundaryElementIteratorEnd())
        {
            <span class="code-type"><B>unsigned</span></B> node_index = (*surf_iter)-&gt;GetNodeGlobalIndex(0);
            <span class="code-type"><B>double</span></B> x = mesh.GetNode(node_index)-&gt;GetPoint()[0];
            <span class="code-type"><B>double</span></B> y = mesh.GetNode(node_index)-&gt;GetPoint()[1];

            <B><span class="code-lang">if</span></B>( (fabs(x-1.0) &lt; 1e-6) || (fabs(y-1.0) &lt; 1e-6) )
            {
                bcc.AddNeumannBoundaryCondition(*surf_iter, p_neumann_boundary_condition);
            }

            surf_iter++;
        }

        SimpleLinearEllipticAssembler&lt;2,2&gt; assembler(&amp;mesh,&amp;pde,&amp;bcc);

        Vec result = assembler.Solve();

        ReplicatableVector result_repl(result);

        OutputFileHandler output_file_handler(<span class="code-string"><B>&quot;TestSolvingLinearPdeTutorial&quot;</span></B>);

        out_stream p_file = output_file_handler.OpenOutputFile(<span class="code-string"><B>&quot;linear_solution.txt&quot;</span></B>);

        <B><span class="code-lang">for</span></B> (<span class="code-type"><B>unsigned</span></B> i=0; i&lt;result_repl.size(); i++)
        {
            <span class="code-type"><B>double</span></B> x = mesh.GetNode(i)-&gt;rGetLocation()[0];
            <span class="code-type"><B>double</span></B> y = mesh.GetNode(i)-&gt;rGetLocation()[1];

            <span class="code-type"><B>double</span></B> u = result_repl[i];

            (*p_file) &lt;&lt; x &lt;&lt; <span class="code-string"><B>&quot; &quot;</span></B> &lt;&lt; y &lt;&lt; <span class="code-string"><B>&quot; &quot;</span></B> &lt;&lt; u &lt;&lt; <span class="code-string"><B>&quot;\n&quot;</span></B>;
        }

        VecDestroy(result);
    }

    <span class="code-type"><B>void</span></B> TestSolvingParabolicPde( <span class="code-type"><B>void</span></B> )
    {
        TetrahedralMesh&lt;3,3&gt; mesh;
        mesh.ConstructCuboid(10,10,10);
        mesh.Scale(1.0/10, 1.0/10, 1.0/10);

        HeatEquationWithSourceTerm&lt;3&gt; pde;

        BoundaryConditionsContainer&lt;3,3,1&gt; bcc;
        bcc.DefineConstantDirichletOnMeshBoundary(&amp;mesh, 1.0);

        SimpleDg0ParabolicAssembler&lt;3,3,true&gt; assembler(&amp;mesh,&amp;pde,&amp;bcc);

        Vec initial_condition = <B><span class="code-keyword">PetscTools</span></B>::CreateVec(mesh.GetNumNodes(), 1.0);
        assembler.SetInitialCondition(initial_condition);

        <span class="code-type"><B>double</span></B> t_start = 0;
        <span class="code-type"><B>double</span></B> t_end = 1;
        <span class="code-type"><B>double</span></B> dt = 0.01;
        assembler.SetTimes(t_start, t_end, dt);

        Vec solution = assembler.Solve();
        ReplicatableVector solution_repl(solution);

        SimplePoissonEquation&lt;3,3&gt; static_pde;
        SimpleLinearEllipticAssembler&lt;3,3&gt; static_assembler(&amp;mesh, &amp;static_pde, &amp;bcc);
        Vec static_solution = static_assembler.Solve();
        ReplicatableVector static_solution_repl(static_solution);

        <B><span class="code-lang">for</span></B>(<span class="code-type"><B>unsigned</span></B> i=0; i&lt;static_solution_repl.size(); i++)
        {
            TS_ASSERT_DELTA( solution_repl[i], static_solution_repl[i], 1e-3);
        }

        VecDestroy(initial_condition);
        VecDestroy(solution);
        VecDestroy(static_solution);
    }
};

</pre></div></div>
   </div>
   
  
