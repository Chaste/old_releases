<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
 <title>Chaste User Tutorial</title>
 <link rel="stylesheet" href="/trac/css/trac.css" type="text/css" />
 <link rel="stylesheet" href="/trac/css/wiki.css" type="text/css" />


 <style type="text/css">
/* Link styles */
:link, :visited, a em {
 text-decoration: none;
 color: #283f6b;
 border-bottom: 1px dotted #bbb;
}
/*
:link:hover, :visited:hover {
 background-color: #eee;
 color: #555;
}
*/
</style>

</head>
<body>
<a id="logo" href="http://www.comlab.ox.ac.uk/chaste">
  <img src="/logos/chaste-266x60.jpg" alt="Chaste logo" />
</a>
<h1> RunningBidomainSimulations tutorial file </h1></div>

<div id="content" class="wiki">

 
  
  
   <div class="wikipage">
    <div id="searchable"><p>
This tutorial is automatically generated from the file trunk/heart/test/TestRunningBidomainSimulationsTutorial.hpp at revision <a class="changeset" title="#921" href="/cgi-bin/trac.cgi/changeset/5109">r5109</a>.
Note that the code is given in full at the bottom of the page.
</p>
<h1 id="Anexampleshowinghowtorunbidomainsimulationsformonodomainitisessentiallythesame">An example showing how to run bidomain simulations (for monodomain, it is essentially the same)</h1>
<h2 id="Introduction">Introduction</h2>
<p>
In this tutorial we show how Chaste is used to run a standard bidomain simulation.
Note that monodomain simulations are run very similarly.
The first thing that needs to be done, when writing any Chaste test,
is to include the following header.
</p>
<div class="code"><pre>#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&lt;cxxtest/TestSuite.h&gt;</span></B>
</pre></div><p>
The main class to be used for running bidomain simulations is <tt>BidomainProblem</tt>. 
</p>
<div class="code"><pre>#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;BidomainProblem.hpp&quot;</span></B>
</pre></div><p>
The <tt>PlaneStimulusCellFactory</tt> is a useful class to include (see later). 
</p>
<div class="code"><pre>#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;PlaneStimulusCellFactory.hpp&quot;</span></B>
</pre></div><p>
<tt>LuoRudyIModel1991OdeSystem</tt> is the cell model which will be used in this simulation.
</p>
<div class="code"><pre>#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;LuoRudyIModel1991OdeSystem.hpp&quot;</span></B>
</pre></div><p>
All tests which run cardiac simulations (which use Petsc) should include
<tt>PetscSetupAndFinalize.hpp</tt>.  This class ensures that <tt>PetscInitialise()</tt>
is called with the appropriate arguments before any tests in the suite are run. 
</p>
<div class="code"><pre>#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;PetscSetupAndFinalize.hpp&quot;</span></B>
</pre></div><h2 id="Definingacellfactory">Defining a cell factory</h2>
<p>
All mono/bidomain simulations need a <i>cell factory</i> as input. This is a class
which tells the problem class what type of cardiac cells to create. The cell-factory
class has to inherit from <tt>AbstractCardiacCellFactory&lt;DIM&gt;</tt>, which means it must
implement the method <tt>CreateCardiacCellForTissueNode(unsigned nodeNum)</tt>, which returns
a pointer to an <tt>AbstractCardiacCell</tt>. Note, some concrete cell factories have
been defined, such as the <tt>PlaneStimulusCellFactory</tt>, which could be used in the
simulation, but for completeness we create our own cell factory in this test. For
complicated problems with, say, heterogeneous cell types or particular stimuli, a
new cell factory will have to be defined by the user for their particular problem.
</p>
<p>
This cell factory is a simple cell factory where every cell is a Luo-Rudy 91 cell,
and only the cell at position (0,0) is given a non-zero stimulus.
</p>
<div class="code"><pre>class PointStimulus2dCellFactory : public AbstractCardiacCellFactory&lt;2&gt;
{
</pre></div><p>
Declare pointer to an <tt>SimpleStimulus</tt> for the cell which is stimulated.
Note that <tt>AbstractCardiacCellFactory</tt> also has as protected members: <tt>mpZeroStimulus</tt>
of type <tt>ZeroStimulus</tt>; <tt>mpMesh</tt>, a pointer to the mesh used (the problem
class will set this before it calls <tt>CreateCardiacCellForTissueNode</tt>, so it can be used
in that method); <tt>mTimestep</tt>, a double (see below); and <tt>mpSolver</tt> a forward
euler ode solver (see below). 
</p>
<div class="code"><pre><B><span class="code-keyword">private</span></B>:
    SimpleStimulus *mpStimulus;
<B><span class="code-keyword">public</span></B>:
</pre></div><p>
Our contructor takes in nothing. It calls the constructor of <tt>AbstractCardiacCellFactory</tt>
and we also initialise the stimulus to have magnitude -6000 (uA/cm<sup>3) and duration 0.5 (ms).
</sup></p>
<div class="code"><pre>    PointStimulus2dCellFactory() : AbstractCardiacCellFactory&lt;2&gt;()
    {
        mpStimulus = new SimpleStimulus(-6000.0, 0.5);
    }
</pre></div><p>
Now we implement the pure method which needs to be implemented. We return
a LR91 cell for each node, with the node at (0,0) given the non-zero stimulus,
and all other nodes given the zero stimulus. Note that we use <tt>mpMesh</tt>,
<tt>mTimestep</tt>, <tt>mpZeroStimulus</tt> and <tt>mpSolver</tt> which are all
members of the base class. The timestep and solver are defined in the base
class just so that the user doesn't have to create them here. 
</p>
<div class="code"><pre>    AbstractCardiacCell* CreateCardiacCellForTissueNode(<span class="code-type"><B>unsigned</span></B> nodeIndex)
    {
        <span class="code-type"><B>double</span></B> x = this-&gt;mpMesh-&gt;GetNode(nodeIndex)-&gt;rGetLocation()[0];
        <span class="code-type"><B>double</span></B> y = this-&gt;mpMesh-&gt;GetNode(nodeIndex)-&gt;rGetLocation()[1];
        <B><span class="code-lang">if</span></B> (fabs(x)+fabs(y)&lt;1e-6) <I><span class="code-comment">// ie if (x,y)==(0,0). An alternative would be if(norm_2(this-&gt;mpMesh-&gt;GetNode(nodeIndex)-&gt;rGetLocation())&lt;1e-6)
</span></I>        {
</pre></div><p>
Even if running a bidomain simulation, only the intra-cellular stimulus
should be given here.  There is a separate Electrodes class for applying
extra-cellular stimuli.
</p>
<div class="code"><pre>            <B><span class="code-lang">return</span></B> new LuoRudyIModel1991OdeSystem(mpSolver, mpStimulus);
        }
        <B><span class="code-lang">else</span></B>
        {
</pre></div><p>
The other cells have zero stimuli. 
</p>
<div class="code"><pre>            <B><span class="code-lang">return</span></B> new LuoRudyIModel1991OdeSystem(mpSolver, mpZeroStimulus);
        }
    }
</pre></div><p>
The destructor just deletes the memory for the stimulus. Note the the problem
class deals with deleting the cells. 
</p>
<div class="code"><pre>    ~PointStimulus2dCellFactory()
    {
        delete mpStimulus;
    }
};
</pre></div><h2 id="Runningabidomainsimulation">Running a bidomain simulation</h2>
<p>
Now we can define the test class, which must inherit from <tt>CxxTest::TestSuite</tt>
as usual. 
</p>
<div class="code"><pre>class TestRunningBidomainSimulationsTutorial : public <B><span class="code-keyword">CxxTest</span></B>::TestSuite
{
</pre></div><p>
Tests should be public... 
</p>
<div class="code"><pre><B><span class="code-keyword">public</span></B>:
</pre></div><p>
Define the test. Note the <tt>throw(Exception)</tt> - without this exception messages
might not get printed out. 
</p>
<div class="code"><pre>    <span class="code-type"><B>void</span></B> TestSimpleSimulation() throw(Exception)
    {
</pre></div><p>
The <tt>HeartConfig</tt> class is used to set various parameters. It gets the default values
from ChasteDefaults.xml (in the base Chaste directory) (except the values in the 'Simulation' block of the XML file,
which is only used by the Chaste executable). Parameters in this file can be re-set
with <tt>HeartConfig</tt> if the user wishes, and other paramters such as end time must be set
using <tt>HeartConfig</tt>. Let us begin by setting the end time (in ms), the mesh to use, and the
output directory and filename-prefix.
</p>
<div class="code"><pre>        <B><span class="code-keyword">HeartConfig</span></B>::Instance()-&gt;SetSimulationDuration(1.0); <I><span class="code-comment">//ms
</span></I>        <B><span class="code-keyword">HeartConfig</span></B>::Instance()-&gt;SetMeshFileName(<span class="code-string"><B>&quot;mesh/test/data/square_128_elements&quot;</span></B>);
        <B><span class="code-keyword">HeartConfig</span></B>::Instance()-&gt;SetOutputDirectory(<span class="code-string"><B>&quot;BidomainTutorial&quot;</span></B>);
        <B><span class="code-keyword">HeartConfig</span></B>::Instance()-&gt;SetOutputFilenamePrefix(<span class="code-string"><B>&quot;results&quot;</span></B>);
</pre></div><p>
Next, we have to create a cell factory of the type we defined above. 
</p>
<div class="code"><pre>        PointStimulus2dCellFactory cell_factory;
</pre></div><p>
Now we create a problem class using (a pointer to) the cell factory. 
</p>
<div class="code"><pre>        BidomainProblem&lt;2&gt; bidomain_problem( &amp;cell_factory );
</pre></div><p>
This is enough setup to run a simulation: we could now call <tt>Initialise()</tt>
and <tt>Solve()</tt> to run... 
</p>
<div class="code"><pre>        <I><span class="code-comment">// bidomain_problem.Initialise();
</span></I>        <I><span class="code-comment">// bidomain_problem.Solve();
</span></I>
</pre></div><p>
..However, instead we show how to set a few more parameters. To set the conductivity values
in the principal fibre, sheet and normal directions do the following.
Note that <tt>Create_c_vector</tt> is just a helper method for creating a <tt>c_vector&lt;double,DIM&gt;</tt>
of the correct size (2, in this case). Make sure these methods are called before
<tt>Initialise()</tt>.
</p>
<div class="code"><pre>        <B><span class="code-keyword">HeartConfig</span></B>::Instance()-&gt;SetIntracellularConductivities(Create_c_vector(1.75, 0.19));
        <B><span class="code-keyword">HeartConfig</span></B>::Instance()-&gt;SetExtracellularConductivities(Create_c_vector(6.2, 2.4));
</pre></div><p>
Let us also reset the surface-area-to-volume ratio and the capacitance 
</p>
<div class="code"><pre>        <B><span class="code-keyword">HeartConfig</span></B>::Instance()-&gt;SetSurfaceAreaToVolumeRatio(1.0); <I><span class="code-comment">// 1/cm
</span></I>        <B><span class="code-keyword">HeartConfig</span></B>::Instance()-&gt;SetCapacitance(1.0); <I><span class="code-comment">// uF/cm^2
</span></I>
</pre></div><p>
Now we call <tt>Initialise()</tt>... 
</p>
<div class="code"><pre>        bidomain_problem.Initialise();
</pre></div><p>
The output will be written to /tmp/USER_NAME/testoutput/BidomainTutorial
in hdf5 format. If you want visualise the results afterwards, call the
following method now, and the mesh and output will be converted to meshalyzer
format at the end of the simulation.
</p>
<div class="code"><pre>        bidomain_problem.ConvertOutputToMeshalyzerFormat();
</pre></div><p>
Now we call Solve() to run the simulation.
Note that if you want to view the progress of longer simulations
go to the the output directory and look at the file
<tt>progress_status.txt</tt>, which will say the percentage of the
simulation run. A useful linux command is therefore <tt>watch tail progress_status.txt</tt>
which will repeatedly display the last few lines of this file. 
</p>
<div class="code"><pre>        bidomain_problem.Solve();
</pre></div><p>
To now visualise the results, go to /tmp/USER_NAME/testoutput/BidomainTutorial/output,
where you should find the mesh and output, and run meshalyzer.
</p>
<p>
The easiest way to look at the resultant voltage values (for the last timestep -
the data for the previous timesteps is written to file but not retained) is to
use a <tt>ReplicatableVector</tt>. <tt>bidomain_problem.GetSolution())</tt> returns a PetSc vector
of the form (V_0, phi_0, V_1, phi_e_1, ... V_n, phi_e_n), and we can create a
<tt>ReplicatableVector</tt> for easy access to this PetSc vector's data. (This won't be very
efficient with huge problems in parallel).
</p>
<div class="code"><pre>        ReplicatableVector res_repl(bidomain_problem.GetSolution());
        <B><span class="code-lang">for</span></B>(<span class="code-type"><B>unsigned</span></B> i=0; i&lt;res_repl.size(); i++)
        {
        <I><span class="code-comment">//    std::cout &lt;&lt; res_repl[i] &lt;&lt; &quot;\n&quot;;
</span></I>        }
</pre></div><p>
Alternatively, we show how to access the voltage values using the <tt>DistributedVector</tt>
class, which can be used to only iterate over the values of the voltage owned
by that process.
</p>
<div class="code"><pre>        DistributedVector dist_bidomain_voltage(bidomain_problem.GetSolution());
        <B><span class="code-keyword">DistributedVector</span></B>::Stripe bidomain_voltage(dist_bidomain_voltage, 0);
        <B><span class="code-keyword">DistributedVector</span></B>::Stripe extracellular_potential(dist_bidomain_voltage, 1);
</pre></div><p>
A loop over all the components owned by this process.. 
</p>
<div class="code"><pre>        <B><span class="code-lang">for</span></B> (<B><span class="code-keyword">DistributedVector</span></B>::Iterator index = <B><span class="code-keyword">DistributedVector</span></B>::Begin();
             index != <B><span class="code-keyword">DistributedVector</span></B>::End();
             ++index)
        {
</pre></div><p>
.. and a simple test, that the 'last' node was stimulated: 
</p>
<div class="code"><pre>            <B><span class="code-lang">if</span></B> (index.Global==bidomain_problem.rGetMesh().GetNumNodes()-1) <I><span class="code-comment">// ie if the last node
</span></I>            {
                TS_ASSERT_LESS_THAN(0, bidomain_voltage[index]);
            }
        }
    }
</pre></div><h2 id="Runningabidomainsimulationwithanexternalbathandelectrodes">Running a bidomain simulation with an external bath, and electrodes</h2>
<p>
Now, we illustrate how to run a simulation with an external bath
and electrodes applying a boundary extracellular stimulus. Note that
currently, bath problems can only be solved on rectangular/cuboid
domains.
</p>
<div class="code"><pre>    <span class="code-type"><B>void</span></B> TestWithBathAndElectrodes() throw (Exception)
    {
</pre></div><p>
<strong>Important:</strong> we need to remember to reset the <tt>HeartConfig</tt>
class, since it had reset various parameters in the previous
test.
</p>
<div class="code"><pre>        <B><span class="code-keyword">HeartConfig</span></B>::Instance()-&gt;Reset();
</pre></div><p>
First, set the end time and output info. In this simulation
we'll explicitly read the mesh, alter it, then pass it
to the problem class, so we don't set the mesh file name.
</p>
<div class="code"><pre>        <B><span class="code-keyword">HeartConfig</span></B>::Instance()-&gt;SetSimulationDuration(3.0);  <I><span class="code-comment">//ms
</span></I>        <B><span class="code-keyword">HeartConfig</span></B>::Instance()-&gt;SetOutputDirectory(<span class="code-string"><B>&quot;BidomainTutorialWithBath&quot;</span></B>);
        <B><span class="code-keyword">HeartConfig</span></B>::Instance()-&gt;SetOutputFilenamePrefix(<span class="code-string"><B>&quot;results&quot;</span></B>);
</pre></div><p>
Bath problems seem to require decreased ODE timesteps.
</p>
<div class="code"><pre>        <B><span class="code-keyword">HeartConfig</span></B>::Instance()-&gt;SetOdeTimeStep(0.001);  <I><span class="code-comment">//ms
</span></I>
</pre></div><p>
Next, use the <tt>PlaneStimulusCellFactory</tt> to define a set
of Luo-Rudy cells. This factory normally sets the X=0 cells to be
stimulated, but we don't want any intracellular stimulus in this
test, so we pass in 0.0 as the stimulus magnitude.
</p>
<div class="code"><pre>        PlaneStimulusCellFactory&lt;LuoRudyIModel1991OdeSystem,2&gt; cell_factory(0.0);
</pre></div><p>
Now, we load up a rectangular mesh (in triangle/tetgen format), done as follows,
using <tt>TrianglesMeshReader</tt>.
</p>
<div class="code"><pre>        TrianglesMeshReader&lt;2,2&gt; reader(<span class="code-string"><B>&quot;mesh/test/data/2D_0_to_1mm_400_elements&quot;</span></B>);
        TetrahedralMesh&lt;2,2&gt; mesh;
        mesh.ConstructFromMeshReader(reader);
</pre></div><p>
In bath problems, each element has an attribute which must be set
to 0 (cardiac tissue) or 1 (bath). This can be done by having an
extra column in the element file (see for example mesh/test/data/1D_0_to_1_10_elements_with_two_attributes.ele,
and note that the header in this file has 1 at the end to indicate that
the file defines an attribute for each element. We have read in a mesh
without this type of information set up, so we set it up manually,
by looping over elements and setting those more than 2mm from the centre
as bath elements (by default, the others are cardiac elements).
</p>
<div class="code"><pre>        <B><span class="code-lang">for</span></B>(<span class="code-type"><B>unsigned</span></B> i=0; i&lt;mesh.GetNumElements(); i++)
        {
            <span class="code-type"><B>double</span></B> x = mesh.GetElement(i)-&gt;CalculateCentroid()[0];
            <span class="code-type"><B>double</span></B> y = mesh.GetElement(i)-&gt;CalculateCentroid()[1];
            <B><span class="code-lang">if</span></B>( sqrt((x-0.05)*(x-0.05) + (y-0.05)*(y-0.05)) &gt; 0.02 )
            {
                mesh.GetElement(i)-&gt;SetRegion(<B><span class="code-keyword">HeartRegionCode</span></B>::BATH);
            }
        }
</pre></div><p>
Now we define the electrodes. First define the magnitude of the electrodes
(ie the magnitude of the boundary extracellular stimulus), and the duration
it lasts for. Currently, electrodes switch on at time 0 and have constant magnitude
until they are switched off. (Note that this test has a small range of
magnitudes that will work, perhaps because the electrodes are close to the tissue).
</p>
<div class="code"><pre>        <I><span class="code-comment">//-1e4 is under thershold, -1.4e4 too high - crashes the cell model
</span></I>        <span class="code-type"><B>double</span></B> magnitude = -1.1e4; <I><span class="code-comment">// uA/cm^2
</span></I>        <span class="code-type"><B>double</span></B> duration = 2; <I><span class="code-comment">//ms
</span></I>
</pre></div><p>
Electrodes work in two ways: the first electrode applies an input flux, and
the opposite electrode can either be grounded or apply an equal and opposite
flux (ie an output flux). The <tt>false</tt> here indicates the second electrode
is not grounded, ie has an equal and opposite flux. The "0, 0.0, 0.1" indicates
that the electrodes should be applied to the surfaces X=0.0 and X=0.1 (which
must match the mesh provided) (so, for example, you should use "2, 0.0, 0.1" to
apply electrodes to the surfaces Z=0.0 and Z=0.1, etc).
</p>
<div class="code"><pre>        Electrodes&lt;2&gt; electrodes(mesh, false, 0, 0.0, 0.1, magnitude, duration);
</pre></div><p>
Now create the problem class, using the cell factory and passing
in <tt>true</tt> as the second argument to indicate we are solving a bath
problem..
</p>
<div class="code"><pre>        BidomainProblem&lt;2&gt; bidomain_problem( &amp;cell_factory, true );
</pre></div><p>
..set the mesh and electrodes.. 
</p>
<div class="code"><pre>        bidomain_problem.SetMesh(&amp;mesh);
        bidomain_problem.SetElectrodes(electrodes);
</pre></div><p>
..and solve as before. 
</p>
<div class="code"><pre>        bidomain_problem.ConvertOutputToMeshalyzerFormat(true);
        bidomain_problem.Initialise();
        bidomain_problem.Solve();
</pre></div><p>
The results can be visualised as before. <strong>Note:</strong> The voltage is only
defined at cardiac nodes (a node contained in <i>any</i> cardiac element), but
for visualisation and computation a 'fake' value of ZERO is given for the
voltage at bath nodes.
</p>
<p>
Finally, we can check that an AP was induced in any of the cardiac
cells. We use a <tt>ReplicatableVector</tt> as before, and make sure we
only check the voltage at cardiac cells.
</p>
<div class="code"><pre>        Vec solution = bidomain_problem.GetSolution(); <I><span class="code-comment">// the Vs and phi_e's, as a PetSc vector
</span></I>        ReplicatableVector solution_repl(solution);
        bool ap_triggered = false;
        <B><span class="code-lang">for</span></B>(<span class="code-type"><B>unsigned</span></B> i=0; i&lt;mesh.GetNumNodes(); i++)
        {
            <B><span class="code-lang">if</span></B> (mesh.GetNode(i)-&gt;GetRegion()==<B><span class="code-keyword">HeartRegionCode</span></B>::TISSUE)
            {
                <B><span class="code-lang">if</span></B> (solution_repl[2*i] &gt; 0.0) <I><span class="code-comment">// 2*i, so the voltage for this node (2*i+1 for phi_e)
</span></I>                {
                    ap_triggered = true;
                }
            }
        }
        TS_ASSERT(ap_triggered);
    }
};
</pre></div><h1 id="Code">Code</h1>
<p>
The full code is given below
</p>
<div class="code"><pre>#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&lt;cxxtest/TestSuite.h&gt;</span></B>
#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;BidomainProblem.hpp&quot;</span></B>
#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;PlaneStimulusCellFactory.hpp&quot;</span></B>
#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;LuoRudyIModel1991OdeSystem.hpp&quot;</span></B>
#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;PetscSetupAndFinalize.hpp&quot;</span></B>

class PointStimulus2dCellFactory : public AbstractCardiacCellFactory&lt;2&gt;
{
<B><span class="code-keyword">private</span></B>:
    SimpleStimulus *mpStimulus;

<B><span class="code-keyword">public</span></B>:
    PointStimulus2dCellFactory() : AbstractCardiacCellFactory&lt;2&gt;()
    {
        mpStimulus = new SimpleStimulus(-6000.0, 0.5);
    }

    AbstractCardiacCell* CreateCardiacCellForTissueNode(<span class="code-type"><B>unsigned</span></B> nodeIndex)
    {
        <span class="code-type"><B>double</span></B> x = this-&gt;mpMesh-&gt;GetNode(nodeIndex)-&gt;rGetLocation()[0];
        <span class="code-type"><B>double</span></B> y = this-&gt;mpMesh-&gt;GetNode(nodeIndex)-&gt;rGetLocation()[1];
        <B><span class="code-lang">if</span></B> (fabs(x)+fabs(y)&lt;1e-6) <I><span class="code-comment">// ie if (x,y)==(0,0). An alternative would be if(norm_2(this-&gt;mpMesh-&gt;GetNode(nodeIndex)-&gt;rGetLocation())&lt;1e-6)
</span></I>        {
            <B><span class="code-lang">return</span></B> new LuoRudyIModel1991OdeSystem(mpSolver, mpStimulus);
        }
        <B><span class="code-lang">else</span></B>
        {
            <B><span class="code-lang">return</span></B> new LuoRudyIModel1991OdeSystem(mpSolver, mpZeroStimulus);
        }
    }

    ~PointStimulus2dCellFactory()
    {
        delete mpStimulus;
    }
};

class TestRunningBidomainSimulationsTutorial : public <B><span class="code-keyword">CxxTest</span></B>::TestSuite
{
<B><span class="code-keyword">public</span></B>:
    <span class="code-type"><B>void</span></B> TestSimpleSimulation() throw(Exception)
    {
        <B><span class="code-keyword">HeartConfig</span></B>::Instance()-&gt;SetSimulationDuration(1.0); <I><span class="code-comment">//ms
</span></I>        <B><span class="code-keyword">HeartConfig</span></B>::Instance()-&gt;SetMeshFileName(<span class="code-string"><B>&quot;mesh/test/data/square_128_elements&quot;</span></B>);
        <B><span class="code-keyword">HeartConfig</span></B>::Instance()-&gt;SetOutputDirectory(<span class="code-string"><B>&quot;BidomainTutorial&quot;</span></B>);
        <B><span class="code-keyword">HeartConfig</span></B>::Instance()-&gt;SetOutputFilenamePrefix(<span class="code-string"><B>&quot;results&quot;</span></B>);

        PointStimulus2dCellFactory cell_factory;

        BidomainProblem&lt;2&gt; bidomain_problem( &amp;cell_factory );

        <I><span class="code-comment">// bidomain_problem.Initialise();
</span></I>        <I><span class="code-comment">// bidomain_problem.Solve();
</span></I>
        <B><span class="code-keyword">HeartConfig</span></B>::Instance()-&gt;SetIntracellularConductivities(Create_c_vector(1.75, 0.19));
        <B><span class="code-keyword">HeartConfig</span></B>::Instance()-&gt;SetExtracellularConductivities(Create_c_vector(6.2, 2.4));
        <B><span class="code-keyword">HeartConfig</span></B>::Instance()-&gt;SetSurfaceAreaToVolumeRatio(1.0); <I><span class="code-comment">// 1/cm
</span></I>        <B><span class="code-keyword">HeartConfig</span></B>::Instance()-&gt;SetCapacitance(1.0); <I><span class="code-comment">// uF/cm^2
</span></I>
        bidomain_problem.Initialise();

        bidomain_problem.ConvertOutputToMeshalyzerFormat();

        bidomain_problem.Solve();

        ReplicatableVector res_repl(bidomain_problem.GetSolution());
        <B><span class="code-lang">for</span></B>(<span class="code-type"><B>unsigned</span></B> i=0; i&lt;res_repl.size(); i++)
        {
        <I><span class="code-comment">//    std::cout &lt;&lt; res_repl[i] &lt;&lt; &quot;\n&quot;;
</span></I>        }

        DistributedVector dist_bidomain_voltage(bidomain_problem.GetSolution());
        <B><span class="code-keyword">DistributedVector</span></B>::Stripe bidomain_voltage(dist_bidomain_voltage, 0);
        <B><span class="code-keyword">DistributedVector</span></B>::Stripe extracellular_potential(dist_bidomain_voltage, 1);

        <B><span class="code-lang">for</span></B> (<B><span class="code-keyword">DistributedVector</span></B>::Iterator index = <B><span class="code-keyword">DistributedVector</span></B>::Begin();
             index != <B><span class="code-keyword">DistributedVector</span></B>::End();
             ++index)
        {
            <B><span class="code-lang">if</span></B> (index.Global==bidomain_problem.rGetMesh().GetNumNodes()-1) <I><span class="code-comment">// ie if the last node
</span></I>            {
                TS_ASSERT_LESS_THAN(0, bidomain_voltage[index]);
            }
        }
    }

    <span class="code-type"><B>void</span></B> TestWithBathAndElectrodes() throw (Exception)
    {
        <B><span class="code-keyword">HeartConfig</span></B>::Instance()-&gt;Reset();

        <B><span class="code-keyword">HeartConfig</span></B>::Instance()-&gt;SetSimulationDuration(3.0);  <I><span class="code-comment">//ms
</span></I>        <B><span class="code-keyword">HeartConfig</span></B>::Instance()-&gt;SetOutputDirectory(<span class="code-string"><B>&quot;BidomainTutorialWithBath&quot;</span></B>);
        <B><span class="code-keyword">HeartConfig</span></B>::Instance()-&gt;SetOutputFilenamePrefix(<span class="code-string"><B>&quot;results&quot;</span></B>);

        <B><span class="code-keyword">HeartConfig</span></B>::Instance()-&gt;SetOdeTimeStep(0.001);  <I><span class="code-comment">//ms
</span></I>
        PlaneStimulusCellFactory&lt;LuoRudyIModel1991OdeSystem,2&gt; cell_factory(0.0);

        TrianglesMeshReader&lt;2,2&gt; reader(<span class="code-string"><B>&quot;mesh/test/data/2D_0_to_1mm_400_elements&quot;</span></B>);
        TetrahedralMesh&lt;2,2&gt; mesh;
        mesh.ConstructFromMeshReader(reader);

        <B><span class="code-lang">for</span></B>(<span class="code-type"><B>unsigned</span></B> i=0; i&lt;mesh.GetNumElements(); i++)
        {
            <span class="code-type"><B>double</span></B> x = mesh.GetElement(i)-&gt;CalculateCentroid()[0];
            <span class="code-type"><B>double</span></B> y = mesh.GetElement(i)-&gt;CalculateCentroid()[1];
            <B><span class="code-lang">if</span></B>( sqrt((x-0.05)*(x-0.05) + (y-0.05)*(y-0.05)) &gt; 0.02 )
            {
                mesh.GetElement(i)-&gt;SetRegion(<B><span class="code-keyword">HeartRegionCode</span></B>::BATH);
            }
        }

        <I><span class="code-comment">//-1e4 is under thershold, -1.4e4 too high - crashes the cell model
</span></I>        <span class="code-type"><B>double</span></B> magnitude = -1.1e4; <I><span class="code-comment">// uA/cm^2
</span></I>        <span class="code-type"><B>double</span></B> duration = 2; <I><span class="code-comment">//ms
</span></I>
        Electrodes&lt;2&gt; electrodes(mesh, false, 0, 0.0, 0.1, magnitude, duration);

        BidomainProblem&lt;2&gt; bidomain_problem( &amp;cell_factory, true );

        bidomain_problem.SetMesh(&amp;mesh);
        bidomain_problem.SetElectrodes(electrodes);

        bidomain_problem.ConvertOutputToMeshalyzerFormat(true);
        bidomain_problem.Initialise();
        bidomain_problem.Solve();

        Vec solution = bidomain_problem.GetSolution(); <I><span class="code-comment">// the Vs and phi_e's, as a PetSc vector
</span></I>        ReplicatableVector solution_repl(solution);

        bool ap_triggered = false;
        <B><span class="code-lang">for</span></B>(<span class="code-type"><B>unsigned</span></B> i=0; i&lt;mesh.GetNumNodes(); i++)
        {
            <B><span class="code-lang">if</span></B> (mesh.GetNode(i)-&gt;GetRegion()==<B><span class="code-keyword">HeartRegionCode</span></B>::TISSUE)
            {
                <B><span class="code-lang">if</span></B> (solution_repl[2*i] &gt; 0.0) <I><span class="code-comment">// 2*i, so the voltage for this node (2*i+1 for phi_e)
</span></I>                {
                    ap_triggered = true;
                }
            }
        }
        TS_ASSERT(ap_triggered);
    }
};

</pre></div></div>
   </div>
   
  
