<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
 <title>Chaste User Tutorial</title>
 <link rel="stylesheet" href="https://chaste.github.io/old_releases/trac.css" type="text/css" />
 <link rel="stylesheet" href="https://chaste.github.io/old_releases/wiki.css" type="text/css" />


 <style type="text/css">
/* Link styles */
:link, :visited, a em {
 text-decoration: none;
 color: #283f6b;
 border-bottom: 1px dotted #bbb;
}
/*
:link:hover, :visited:hover {
 background-color: #eee;
 color: #555;
}
*/
</style>

</head>
<body>
<a id="logo" href="https://chaste.github.io/">
  <img src="https://chaste.github.io/chaste_0256.png" alt="Chaste logo" height="60" />
</a>
<h1> RunningCryptSimulations tutorial file </h1></div>

<div id="content" class="wiki">

 
  
  
   <div class="wikipage">
    <div id="searchable"><p>
This tutorial is automatically generated from the file trunk/cancer/test/tutorial/TestRunningCryptSimulationsTutorial.hpp at revision <a class="changeset" title="WARNING - Renamed the simple cell cycle models to something more ..." href="/cgi-bin/trac.cgi/changeset/5390">r5390</a>.
Note that the code is given in full at the bottom of the page.
</p>
<h1 id="Examplesshowinghowtoruncryptsimulationsonperiodicmesheswithdifferentcellcyclemodels">Examples showing how to run crypt simulations on periodic meshes with different cell cycle models</h1>
<h2 id="Introduction">Introduction</h2>
<p>
In this tutorial we show how Chaste is used to run crypt simulations.
Full details of the computational model can be found in the paper by
van Leeuwen <i>et al</i> (to appear in Cell Prolif.)
The first thing to do is include the following header, which allows us
to use certain methods in our test (this header file should be included
in any Chaste test):
</p>
<div class="code"><pre>#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&lt;cxxtest/TestSuite.h&gt;</span></B>
</pre></div><p>
The next two header files define helper classes for generating a vector of
cells with fixed, and Wnt-dependent, cell cycle models: 
</p>
<div class="code"><pre>#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;FixedDurationGenerationBasedCellCycleModelCellsGenerator.hpp&quot;</span></B>
#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;WntCellCycleModelCellsGenerator.hpp&quot;</span></B>
</pre></div><p>
This header file defines a helper class for generating a suitable mesh: 
</p>
<div class="code"><pre>#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;HoneycombMeshGenerator.hpp&quot;</span></B>
</pre></div><p>
These are the classes that will be used in these tests 
</p>
<div class="code"><pre>#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;MeshBasedTissueWithGhostNodes.hpp&quot;</span></B>
#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;GeneralisedLinearSpringForce.hpp&quot;</span></B>
#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;CryptSimulation2d.hpp&quot;</span></B>
#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;WntConcentration.hpp&quot;</span></B>
#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;SloughingCellKiller.hpp&quot;</span></B>
</pre></div><p>
Next, we define the test class, which inherits from <tt>CxxTest::TestSuite</tt>
and defines some test methods.
</p>
<div class="code"><pre>class TestRunningCryptSimulationsTutorial : public <B><span class="code-keyword">CxxTest</span></B>::TestSuite
{
<B><span class="code-keyword">public</span></B>:
</pre></div><h2 id="Test1abasiccryptsimulation">Test 1 - a basic crypt simulation</h2>
<p>
In the first test, we run a simple crypt simulation, in which we use
a cylindrical mesh, give each cell a fixed cell cycle model, and enforce
sloughing at the top of the crypt.
</p>
<div class="code"><pre>    <span class="code-type"><B>void</span></B> TestCryptFixedCellCycle() throw(Exception)
    {
</pre></div><p>
As in <strong>all</strong> tissue simulations, we must first set the start time.
In addition, it is advisable to reset the values of all model parameters.
<tt>SimulationTime</tt> and <tt>CancerParameters</tt> are <i>singleton</i> classes; this
means that one and only one of each of these objects is instantiated at
any time, and that that single object is accessible from anywhere in the
code. As a result, we do not need to keep passing round the current time or
model parameter values.
</p>
<div class="code"><pre>        <B><span class="code-keyword">SimulationTime</span></B>::Instance()-&gt;SetStartTime(0.0);
        <B><span class="code-keyword">CancerParameters</span></B>::Instance()-&gt;Reset();
</pre></div><p>
Next, we generate a mesh. The basic Chaste mesh is <tt>TetrahedralMesh</tt>.
To enforce periodicity at the left and right hand sides of the mesh, we
use a sublcass called <tt>Cylindrical2dMesh</tt>, which has extra methods for
maintaining periodicity. To create a <tt>Cylindrical2dMesh</tt>, we can use
the <tt>HoneycombMeshGenerator</tt>. This generates a honeycomb-shaped mesh,
in which all nodes are equidistant. Here the first and second arguments
define the size of the mesh - we have chosen a mesh that is 6 nodes (i.e.
cells) wide, and 9 nodes high. The third argument indicates that we require
a double layer of ghost nodes around the mesh (technically, just above
and below the mesh, since it is periodic).
</p>
<div class="code"><pre>        HoneycombMeshGenerator generator(6, 9, 2, true); <I><span class="code-comment">// params are: cells across, cells up, thickness of ghost layer, whether to be cylindrical
</span></I>        Cylindrical2dMesh* p_mesh = generator.GetCylindricalMesh();
        <B><span class="code-keyword">std</span></B>::vector&lt;<span class="code-type"><B>unsigned</span></B>&gt; location_indices = generator.GetCellLocationIndices();
</pre></div><p>
Having created a mesh, we now create a <tt>std::vector</tt> of <tt>TissueCell</tt>s.
To do this, we can use a static method on the <tt>FixedDurationGenerationBasedCellCycleModelCellsGenerator</tt>
helper class. The <tt>&lt;2&gt;</tt> below denotes the dimension. We create an empty vector
of cells and pass this into the method along with the mesh. The third argument
'true' indicates that the cells should be assigned random birth times, to avoid
synchronous division. The <tt>cells</tt> vector is populated once the method
<tt>GenerateForCrypt</tt> is called. 
</p>
<div class="code"><pre>        <B><span class="code-keyword">std</span></B>::vector&lt;TissueCell&gt; cells;
        FixedDurationGenerationBasedCellCycleModelCellsGenerator&lt;2&gt; cells_generator;
        cells_generator.GenerateForCrypt(cells, *p_mesh, location_indices, true);
</pre></div><p>
Now we have a mesh, a set of cells to go with it, and ghost nodes indices,
we can create a <i>Tissue</i>. In general, this class associates a collection
of cells with a set of nodes or a mesh. For this test, because we have a
mesh and ghost nodes, we use aparticular type of tissue called a
<tt>MeshBasedTissueWithGhostNodes</tt>.
</p>
<div class="code"><pre>        MeshBasedTissueWithGhostNodes&lt;2&gt; tissue(*p_mesh, cells, location_indices);
</pre></div><p>
We must now create one or more force laws, which determine the mechanics of
the tissue. For this test, we assume that a cell experiences a force from each
neighbour that can be represented as a linear overdamped spring. We put a pointer
to this force into a vector.
</p>
<div class="code"><pre>        GeneralisedLinearSpringForce&lt;2&gt; linear_force;
        <B><span class="code-keyword">std</span></B>::vector&lt;AbstractForce&lt;2&gt;*&gt; force_collection;
        force_collection.push_back(&amp;linear_force);
</pre></div><p>
Now we define the tissue simulation object, passing in the tissue and collection
of force laws: 
</p>
<div class="code"><pre>        CryptSimulation2d simulator(tissue, force_collection);
</pre></div><p>
Set the output directory on the simulator (relative to
"/tmp/&lt;USER_NAME&gt;/testoutput") and the end time (in hours).
</p>
<div class="code"><pre>        simulator.SetOutputDirectory(<span class="code-string"><B>&quot;CryptTutorialFixedCellCycle&quot;</span></B>);
        simulator.SetEndTime(1);
</pre></div><p>
For longer simulations, you may not want to output the results
every time step. In this case you can use the following method,
to print results every 10 time steps instead. As the time step
used by the simulator, is 30 s, this method will cause the
simulator to print results every 5 min.
</p>
<div class="code"><pre>        <I><span class="code-comment">//simulator.SetSamplingTimestepMultiple(10);
</span></I>
</pre></div><p>
Before running the simulation, we add a cell killer. This object
dictates conditions under which cells die. For this test, we use
a <tt>SloughingCellKiller</tt>, which kills cells above a certain height.
</p>
<div class="code"><pre>        SloughingCellKiller killer(&amp;tissue);
        simulator.AddCellKiller(&amp;killer);
</pre></div><p>
To run the simulation, we call <tt>Solve()</tt>. 
</p>
<div class="code"><pre>        simulator.Solve();
</pre></div><p>
<tt>SimulationTime::Destroy()</tt> <strong>must</strong> be called at the end of the test.
If not, when <tt>SimulationTime::Instance()-&gt;SetStartTime(0.0);</tt> is called
at the beginning of the next test in this file, an assertion will be triggered.
</p>
<div class="code"><pre>        <B><span class="code-keyword">SimulationTime</span></B>::Destroy();
    }
</pre></div><p>
To visualize the results, open a new terminal, cd to the Chaste directory,
then cd to 'anim'. Then do: <tt>java Visualize2dCells /tmp/&lt;USER_NAME&gt;/testoutput/CryptTutorialFixedCellCycle/results_from_time_0</tt>.
You may have to do: <tt>javac Visualize2dCells.java</tt> beforehand to create the
java executable.
</p>
<h2 id="Test2usingWntbasedcellcyclemodels">Test 2 - using Wnt based cell-cycle models</h2>
<p>
The next test is very similar (almost identical in fact), except instead of
using a fixed cell cycle model, we use a Wnt (a protein) based cell cycle model,
with the Wnt concentration depending on the position of the cell within the crypt.
</p>
<div class="code"><pre>    <span class="code-type"><B>void</span></B> TestCryptWntCellCycle() throw(Exception)
    {
</pre></div><p>
First reinitialise time to 0, and reset the cancer parameters, again. 
</p>
<div class="code"><pre>        <B><span class="code-keyword">SimulationTime</span></B>::Instance()-&gt;SetStartTime(0.0);
        <B><span class="code-keyword">RandomNumberGenerator</span></B>::Instance()-&gt;Reseed(0);
        <B><span class="code-keyword">CancerParameters</span></B>::Instance()-&gt;Reset();
</pre></div><p>
Create a cylindrical mesh, and get the cell location indices, exactly as before. 
</p>
<div class="code"><pre>        HoneycombMeshGenerator generator(6, 9, 2, true);
        Cylindrical2dMesh* p_mesh = generator.GetCylindricalMesh();
        <B><span class="code-keyword">std</span></B>::vector&lt;<span class="code-type"><B>unsigned</span></B>&gt; location_indices = generator.GetCellLocationIndices();
</pre></div><p>
Create the cells, using the same method as before. Here, though, we pass
in 'WNT' as the third parameters, saying the cells should have a
Wnt based cell-cycle. This is an ODE based cell cycle. 
</p>
<div class="code"><pre>        <B><span class="code-keyword">std</span></B>::vector&lt;TissueCell&gt; cells;
        WntCellCycleModelCellsGenerator&lt;2&gt; cells_generator;
        cells_generator.GenerateForCrypt(cells, *p_mesh, location_indices, true);
</pre></div><p>
Create the tissue, as before. 
</p>
<div class="code"><pre>        MeshBasedTissueWithGhostNodes&lt;2&gt; tissue(*p_mesh, cells, location_indices);
</pre></div><p>
The other change needed: Cells with a Wnt-based cell cycle need to know
the concentration of Wnt wherever they are. To do this, we set up a <tt>WntConcentration</tt>
class. This is another singleton class (ie accessible from anywhere), so all
cells and cell cycle models can access it. We need to say what the profile of the
Wnt concentation should be - here, we say it is linear (linear decreasing from 1 to 0
from the bottom of the crypt to the top). We also need to inform the <tt>WntConcentration</tt>
of the tissue.
</p>
<div class="code"><pre>        <B><span class="code-keyword">WntConcentration</span></B>::Instance()-&gt;SetType(LINEAR);
        <B><span class="code-keyword">WntConcentration</span></B>::Instance()-&gt;SetTissue(tissue);
</pre></div><p>
Create a force collection as above. 
</p>
<div class="code"><pre>        GeneralisedLinearSpringForce&lt;2&gt; linear_force;
        <B><span class="code-keyword">std</span></B>::vector&lt;AbstractForce&lt;2&gt;*&gt; force_collection;
        force_collection.push_back(&amp;linear_force);
</pre></div><p>
Create a simulator as before (except setting a different output directory). 
</p>
<div class="code"><pre>        CryptSimulation2d simulator(tissue,force_collection);
        simulator.SetOutputDirectory(<span class="code-string"><B>&quot;CryptTutorialWntCellCycle&quot;</span></B>);
        simulator.SetEndTime(1);
</pre></div><p>
Create a killer, as before. 
</p>
<div class="code"><pre>        SloughingCellKiller killer(&amp;tissue);
        simulator.AddCellKiller(&amp;killer);
</pre></div><p>
Solve. 
</p>
<div class="code"><pre>        simulator.Solve();
</pre></div><p>
Destroy the time, and the <tt>WntConcentration</tt> object. The solution can be visualised using the
Visualizer as before, just with the different output directory. 
</p>
<div class="code"><pre>        <B><span class="code-keyword">WntConcentration</span></B>::Destroy();
        <B><span class="code-keyword">SimulationTime</span></B>::Destroy();
    }
};
</pre></div><h1 id="Code">Code</h1>
<p>
The full code is given below
</p>
<div class="code"><pre>#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&lt;cxxtest/TestSuite.h&gt;</span></B>
#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;FixedDurationGenerationBasedCellCycleModelCellsGenerator.hpp&quot;</span></B>
#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;WntCellCycleModelCellsGenerator.hpp&quot;</span></B>
#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;HoneycombMeshGenerator.hpp&quot;</span></B>
#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;MeshBasedTissueWithGhostNodes.hpp&quot;</span></B>
#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;GeneralisedLinearSpringForce.hpp&quot;</span></B>
#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;CryptSimulation2d.hpp&quot;</span></B>
#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;WntConcentration.hpp&quot;</span></B>
#<B><span class="code-keyword">include</span></B> <span class="code-string"><B>&quot;SloughingCellKiller.hpp&quot;</span></B>

class TestRunningCryptSimulationsTutorial : public <B><span class="code-keyword">CxxTest</span></B>::TestSuite
{
<B><span class="code-keyword">public</span></B>:
    <span class="code-type"><B>void</span></B> TestCryptFixedCellCycle() throw(Exception)
    {
        <B><span class="code-keyword">SimulationTime</span></B>::Instance()-&gt;SetStartTime(0.0);
        <B><span class="code-keyword">CancerParameters</span></B>::Instance()-&gt;Reset();

        HoneycombMeshGenerator generator(6, 9, 2, true); <I><span class="code-comment">// params are: cells across, cells up, thickness of ghost layer, whether to be cylindrical
</span></I>        Cylindrical2dMesh* p_mesh = generator.GetCylindricalMesh();
        <B><span class="code-keyword">std</span></B>::vector&lt;<span class="code-type"><B>unsigned</span></B>&gt; location_indices = generator.GetCellLocationIndices();

        <B><span class="code-keyword">std</span></B>::vector&lt;TissueCell&gt; cells;
        FixedDurationGenerationBasedCellCycleModelCellsGenerator&lt;2&gt; cells_generator;
        cells_generator.GenerateForCrypt(cells, *p_mesh, location_indices, true);

        MeshBasedTissueWithGhostNodes&lt;2&gt; tissue(*p_mesh, cells, location_indices);

        GeneralisedLinearSpringForce&lt;2&gt; linear_force;
        <B><span class="code-keyword">std</span></B>::vector&lt;AbstractForce&lt;2&gt;*&gt; force_collection;
        force_collection.push_back(&amp;linear_force);

        CryptSimulation2d simulator(tissue, force_collection);

        simulator.SetOutputDirectory(<span class="code-string"><B>&quot;CryptTutorialFixedCellCycle&quot;</span></B>);
        simulator.SetEndTime(1);
        <I><span class="code-comment">//simulator.SetSamplingTimestepMultiple(10);
</span></I>
        SloughingCellKiller killer(&amp;tissue);
        simulator.AddCellKiller(&amp;killer);

        simulator.Solve();

        <B><span class="code-keyword">SimulationTime</span></B>::Destroy();
    }

    <span class="code-type"><B>void</span></B> TestCryptWntCellCycle() throw(Exception)
    {
        <B><span class="code-keyword">SimulationTime</span></B>::Instance()-&gt;SetStartTime(0.0);
        <B><span class="code-keyword">RandomNumberGenerator</span></B>::Instance()-&gt;Reseed(0);
        <B><span class="code-keyword">CancerParameters</span></B>::Instance()-&gt;Reset();

        HoneycombMeshGenerator generator(6, 9, 2, true);
        Cylindrical2dMesh* p_mesh = generator.GetCylindricalMesh();
        <B><span class="code-keyword">std</span></B>::vector&lt;<span class="code-type"><B>unsigned</span></B>&gt; location_indices = generator.GetCellLocationIndices();

        <B><span class="code-keyword">std</span></B>::vector&lt;TissueCell&gt; cells;
        WntCellCycleModelCellsGenerator&lt;2&gt; cells_generator;
        cells_generator.GenerateForCrypt(cells, *p_mesh, location_indices, true);

        MeshBasedTissueWithGhostNodes&lt;2&gt; tissue(*p_mesh, cells, location_indices);

        <B><span class="code-keyword">WntConcentration</span></B>::Instance()-&gt;SetType(LINEAR);
        <B><span class="code-keyword">WntConcentration</span></B>::Instance()-&gt;SetTissue(tissue);

        GeneralisedLinearSpringForce&lt;2&gt; linear_force;
        <B><span class="code-keyword">std</span></B>::vector&lt;AbstractForce&lt;2&gt;*&gt; force_collection;
        force_collection.push_back(&amp;linear_force);

        CryptSimulation2d simulator(tissue,force_collection);
        simulator.SetOutputDirectory(<span class="code-string"><B>&quot;CryptTutorialWntCellCycle&quot;</span></B>);
        simulator.SetEndTime(1);

        SloughingCellKiller killer(&amp;tissue);
        simulator.AddCellKiller(&amp;killer);

        simulator.Solve();

        <B><span class="code-keyword">WntConcentration</span></B>::Destroy();
        <B><span class="code-keyword">SimulationTime</span></B>::Destroy();
    }
};
</pre></div></div>
   </div>
   
  
