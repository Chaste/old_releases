<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>UserTutorials/RunningCryptSimulations - Chaste</title>
    <link rel="stylesheet" href="https://chaste.github.io/old_releases/trac.css" type="text/css" />
    <link rel="stylesheet" href="https://chaste.github.io/old_releases/wiki.css" type="text/css" />
    <link rel="stylesheet" href="/trac/css/site.css" type="text/css" />
    <style type="text/css">
/* Link styles */
:link, :visited, a em {
 text-decoration: none;
 color: #283f6b;
 border-bottom: 1px dotted #bbb;
}
/*
:link:hover, :visited:hover {
 background-color: #eee;
 color: #555;
}
*/
    </style>

  </head>
  <body>
    <div id="banner">
      <div id="header">
        <p>
          <a id="logo" href="https://chaste.github.io/"><img src="https://chaste.github.io/chaste_0256.png" alt="Chaste logo" height="60" /></a>
          <em>Documentation for <a href="https://chaste.github.io/old_releases/release_2.2/">Release 2.2</a>.</em>
        </p>
      </div>
    </div>
    <p>&nbsp;</p>
    <div id="content" class="wiki">
      <p class="path noprint">
        <a class="pathentry" title="View UserTutorials" href="https://chaste.github.io/old_releases/release_2.2/UserTutorials.html">UserTutorials</a><span class="pathentry sep">/</span><a class="pathentry" title="View UserTutorials/RunningCryptSimulations" href="https://chaste.github.io/old_releases/release_2.2/UserTutorials/RunningCryptSimulations.html">RunningCryptSimulations</a>
        <br style="clear: both" />
      </p>
      <div class="wikipage searchable">
        
          <p>
This tutorial is automatically generated from the file trunk/crypt/test/tutorial/TestRunningCryptSimulationsTutorial.hpp at revision <a class="changeset" href="/cgi-bin/trac.cgi/changeset/12206" title="#1592 - minor edits">r12206</a>.
Note that the code is given in full at the bottom of the page.
</p>
<h1 id="Examplesshowinghowtoruncryptsimulationsonperiodicmesheswithdifferentcell-cyclemodels">Examples showing how to run crypt simulations on periodic meshes with different cell-cycle models</h1>
<h2 id="Introduction">Introduction</h2>
<p>
In this tutorial we show how Chaste can be used to simulate a cylindrical model of an
intestinal crypt. Full details of the computational model can be found in the paper by
van Leeuwen <i>et al.</i> (2009) [doi:10.1111/j.1365-2184.2009.00627.x].
</p>
<p>
The first thing to do is include the following header file, which allows us
to use certain methods in our test. This header file must be included
in any Chaste test.
</p>
<div class="code"><pre><span class="cp">#include &lt;cxxtest/TestSuite.h&gt;
</span></pre></div><p>
Any test in which the <tt>GetIdentifier()</tt> method is used, even via the main
<tt>cell_based</tt> code (through calls to <tt>AbstractCellPopulation</tt> output methods),
must also include <tt>CheckpointArchiveTypes.hpp</tt> or <tt>CellBasedSimulationArchiver.hpp</tt>
as the first Chaste header file.
</p>
<div class="code"><pre><span class="cp">#include "CheckpointArchiveTypes.hpp"
</span></pre></div><p>
The next header file defines a helper class for generating cells for crypt simulations.
</p>
<div class="code"><pre><span class="cp">#include "CryptCellsGenerator.hpp"
</span></pre></div><p>
The next two header files define two different types of cell-cycle model.
In a <tt>FixedDurationGenerationBasedCellCycleModel</tt>, the duration of each phase
of the cell cycle is fixed. In a <tt>WntCellCycleModel</tt>, the duration of a cell's G1 phase
is determined by a system of nonlinear ODEs describing a cell's response to the local
concentration of Wnt,
a secreted cellâ€“cell signalling molecule that is known to play a key role in cell
proliferation in the crypt. In our crypt simulations, we impose a fixed gradient of
Wnt up the axis of the crypt.
</p>
<div class="code"><pre><span class="cp">#include "FixedDurationGenerationBasedCellCycleModel.hpp"
#include "WntCellCycleModel.hpp"
</span></pre></div><p>
The next header file defines a helper class for generating a suitable triangular mesh
for the crypt simulation, such that the cell corresponding to each node is initially
in mechanical equilibrium with its neighours and periodic boundary conditions are applied
at the left- and right-hand sides of the mesh (hence the "cylindrical").
</p>
<div class="code"><pre><span class="cp">#include "CylindricalHoneycombMeshGenerator.hpp"
</span></pre></div><p>
The next header file defines a <tt>CellPopulation</tt> class that uses a triangular mesh, and allows
for the inclusion of 'ghost nodes'. These are nodes in the mesh that do not correspond
to cells; instead they help ensure that a sensible Delaunay triangulation is generated
at each timestep. This is because the triangulation algorithm requires a convex hull.
</p>
<div class="code"><pre><span class="cp">#include "MeshBasedCellPopulationWithGhostNodes.hpp"
</span></pre></div><p>
The next header file defines a force law, based on a linear spring, for describing
the mechanical interactions between neighbouring cells in the crypt.
</p>
<div class="code"><pre><span class="cp">#include "GeneralisedLinearSpringForce.hpp"
</span></pre></div><p>
The next header file defines the class that simulates the evolution of a <tt>CellPopulation</tt>,
specialized to deal with the cylindrical crypt geometry.
</p>
<div class="code"><pre><span class="cp">#include "CryptSimulation2d.hpp"
</span></pre></div><p>
The next header file defines a Wnt singleton class, which (if used) deals with the
imposed Wnt gradient in our crypt model. This affects cell proliferation in the case
where we construct each cell with a <tt>WntCellCycleModel</tt>.
</p>
<div class="code"><pre><span class="cp">#include "WntConcentration.hpp"
</span></pre></div><p>
The final header file defines a cell killer class, which implements sloughing of cells
into the lumen once they reach the top of the crypt.
</p>
<div class="code"><pre><span class="cp">#include "SloughingCellKiller.hpp"
</span></pre></div><p>
Next, we define the test class, which inherits from <tt>CxxTest::TestSuite</tt>
and defines some test methods.
</p>
<div class="code"><pre><span class="k">class</span> <span class="nc">TestRunningCryptSimulationsTutorial</span> <span class="o">:</span> <span class="k">public</span> CxxTest<span class="o">::</span>TestSuite
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
</pre></div><h2 id="Test1:abasiccryptsimulation">Test 1: a basic crypt simulation</h2>
<p>
In the first test, we demonstrate how to create a crypt simulation using a
cylindrical mesh, with each cell progressing through a fixed cell-cycle model,
and sloughing enforced at the top of the crypt.
</p>
<div class="code"><pre>    <span class="kt">void</span> TestCryptWithFixedCellCycle<span class="p">()</span> <span class="k">throw</span><span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
</pre></div><p>
As in <strong>all</strong> cell-based simulations, we must first set the start time.
</p>
<div class="code"><pre>        SimulationTime<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>SetStartTime<span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
</pre></div><p>
Next, we generate a mesh. The basic Chaste mesh is a <tt>TetrahedralMesh</tt>.
To enforce periodicity at the left- and right-hand sides of the mesh, we
use a subclass called <tt>Cylindrical2dMesh</tt>, which has extra methods for
maintaining periodicity. To create a <tt>Cylindrical2dMesh</tt>, we can use a helper class called
<tt>CylindricalHoneycombMeshGenerator</tt>. This generates a periodic honeycomb-shaped mesh,
in which all nodes are equidistant to their neighbours. Here the first and second arguments
define the size of the mesh - we have chosen a mesh that is 6 nodes (i.e.
cells) wide, and 9 nodes high. The third argument indicates that we require
a double layer of ghost nodes around the mesh (technically, just above
and below the mesh, since it is periodic). We call <tt>GetCylindricalMesh()</tt> on the <tt>CylindricalHoneycombMeshGenerator</tt> to
return our <tt>Cylindrical2dMesh</tt>, and call <tt> GetCellLocationIndices()</tt>
to return a <tt>std::vector</tt> of indices of nodes in the mesh that correspond to real cells (as opposed
to ghost nodes).
</p>
<div class="code"><pre>        CylindricalHoneycombMeshGenerator generator<span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
        Cylindrical2dMesh<span class="o">*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetCylindricalMesh<span class="p">();</span>
        std<span class="o">::</span>vector<span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> location_indices <span class="o">=</span> generator<span class="p">.</span>GetCellLocationIndices<span class="p">();</span>
</pre></div><p>
Having created a mesh, we now create a <tt>std::vector</tt> of <tt>CellPtr</tt>s.
To do this, we the <tt>CryptCellsGenerator</tt> helper class, which is templated over the type
of cell-cycle model required (here <tt>FixedDurationGenerationBasedCellCycleModel</tt>)
and the dimension. We create an empty vector of cells and pass this into the
method <tt>Generate()</tt> along with the mesh. The third argument 'true' indicates that the cells
should be assigned random birth times, to avoid synchronous division. The
<tt>cells</tt> vector is populated once the method <tt>Generate()</tt> is
called. Note that we only ever deal with shared pointers to cells, named <tt>CellPtr</tt>s.
</p>
<div class="code"><pre>        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        CryptCellsGenerator<span class="o">&lt;</span>FixedDurationGenerationBasedCellCycleModel<span class="o">&gt;</span> cells_generator<span class="p">;</span>
        cells_generator<span class="p">.</span>Generate<span class="p">(</span>cells<span class="p">,</span> p_mesh<span class="p">,</span> location_indices<span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
</pre></div><p>
Now we have a mesh, a set of cells to go with it, and a vector of node indices
corresponding to real cells, we can create a <tt>CellPopulation</tt> object. In general,
this class associates a collection of cells with a set of nodes or a mesh.
For this test, because we have a mesh and ghost nodes, we use a particular type of
cell population called a <tt>MeshBasedCellPopulationWithGhostNodes</tt>.
</p>
<div class="code"><pre>        MeshBasedCellPopulationWithGhostNodes<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">,</span> location_indices<span class="p">);</span>
</pre></div><p>
Next we use the <tt>CellPopulation</tt> object to construct a <tt>CryptSimulation2d</tt> object,
which will be used to simulate the crypt model.
</p>
<div class="code"><pre>        CryptSimulation2d simulator<span class="p">(</span>cell_population<span class="p">);</span>
</pre></div><p>
We must set the output directory on the simulator (relative to
"/tmp/&lt;USER_NAME&gt;/testoutput") and the end time (in hours).
</p>
<div class="code"><pre>        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"CryptTutorialFixedCellCycle"</span><span class="p">);</span>
        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</pre></div><p>
For longer simulations, we may not want to output the results
every time step. In this case we can use the following method,
to print results every 10 time steps instead. As the time step
used by the simulator, is 30 seconds, this method will cause the
simulator to print results every 5 minutes.
</p>
<div class="code"><pre>        simulator<span class="p">.</span>SetSamplingTimestepMultiple<span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</pre></div><p>
Before running the simulation, we must add one or more force laws, which determine the mechanical
behaviour of the cell population. For this test, we use a <tt>GeneralisedLinearSpringForce</tt>, which assumes
that every cell experiences a force from each of its neighbours that can be represented as a linear overdamped
spring.
</p>
<div class="code"><pre>        GeneralisedLinearSpringForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> linear_force<span class="p">;</span>
        simulator<span class="p">.</span>AddForce<span class="p">(</span><span class="o">&amp;</span>linear_force<span class="p">);</span>
</pre></div><p>
We also add a cell killer to the simulator. This object
dictates under what conditions cells die. For this test, we use
a <tt>SloughingCellKiller</tt>, which kills cells above a certain
height (passed as an argument to the constructor).
</p>
<div class="code"><pre>        <span class="kt">double</span> crypt_height <span class="o">=</span> <span class="mf">8.0</span><span class="p">;</span>
        SloughingCellKiller<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> killer<span class="p">(</span><span class="o">&amp;</span>cell_population<span class="p">,</span> crypt_height<span class="p">);</span>
        simulator<span class="p">.</span>AddCellKiller<span class="p">(</span><span class="o">&amp;</span>killer<span class="p">);</span>
</pre></div><p>
To run the simulation, we call <tt>Solve()</tt>.
</p>
<div class="code"><pre>        simulator<span class="p">.</span>Solve<span class="p">();</span>
</pre></div><p>
<tt>SimulationTime::Destroy()</tt> <strong>must</strong> be called at the end of the test.
If not, when <tt>SimulationTime::Instance()-&gt;SetStartTime(0.0);</tt> is called
at the beginning of the next test in this file, an assertion will be triggered.
</p>
<div class="code"><pre>        SimulationTime<span class="o">::</span>Destroy<span class="p">();</span>
    <span class="p">}</span>
</pre></div><p>
Finally, to visualize the results, we open a new terminal, <tt>cd</tt> to the Chaste directory,
then <tt>cd</tt> to <tt>anim</tt>. Then we do: <tt>java Visualize2dCentreCells /tmp/$USER/testoutput/CryptTutorialFixedCellCycle/results_from_time_0</tt>.
It may be necessary to do: <tt>javac Visualize2dCentreCells.java</tt> beforehand to create the
java executable. Further details on visualization can be found on the Chaste wiki page
For further details on visualization, see <a class="wiki" href="https://chaste.github.io/old_releases/release_2.2/ChasteGuides/RunningCellBasedVisualization.html">ChasteGuides/RunningCellBasedVisualization</a>.
</p>
<h2 id="Test2:aWnt-dependentcryptsimulation">Test 2: a Wnt-dependent crypt simulation</h2>
<p>
The next test is very similar to Test 1, except that instead of
using a fixed cell-cycle model, we use a Wnt-dependent cell-cycle model,
with the Wnt concentration varying within the crypt in a predefined manner.
</p>
<div class="code"><pre>    <span class="kt">void</span> TestCryptWithWntCellCycle<span class="p">()</span> <span class="k">throw</span><span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
</pre></div><p>
We first re-initialize time to zero and reseed the random number generator.
</p>
<div class="code"><pre>        SimulationTime<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>SetStartTime<span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
        RandomNumberGenerator<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>Reseed<span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre></div><p>
We then create a cylindrical mesh, and get the cell location indices, exactly as before.
</p>
<div class="code"><pre>        CylindricalHoneycombMeshGenerator generator<span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
        Cylindrical2dMesh<span class="o">*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetCylindricalMesh<span class="p">();</span>
        std<span class="o">::</span>vector<span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> location_indices <span class="o">=</span> generator<span class="p">.</span>GetCellLocationIndices<span class="p">();</span>
</pre></div><p>
We create the cells, using the same method as before. Here, though, we use a <tt>WntCellCycleModel</tt>.
</p>
<div class="code"><pre>        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        CryptCellsGenerator<span class="o">&lt;</span>WntCellCycleModel<span class="o">&gt;</span> cells_generator<span class="p">;</span>
        cells_generator<span class="p">.</span>Generate<span class="p">(</span>cells<span class="p">,</span> p_mesh<span class="p">,</span> location_indices<span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
</pre></div><p>
We create the cell population, as before.
</p>
<div class="code"><pre>        MeshBasedCellPopulationWithGhostNodes<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">,</span> location_indices<span class="p">);</span>
</pre></div><p>
We set the height of the crypt. As well as passing this variable into the <tt>sloughingCellKiller</tt>,
we will pass it to the <tt>WntConcentration</tt> object (see below).
</p>
<div class="code"><pre>        <span class="kt">double</span> crypt_height <span class="o">=</span> <span class="mf">8.0</span><span class="p">;</span>
</pre></div><p>
When using a <tt>WntCellCycleModel</tt>, we need a way of telling each cell what the Wnt concentration
is at its location. To do this, we set up a <tt>WntConcentration</tt> object. Like <tt>SimulationTime</tt>,
<tt>WntConcentration</tt> is a singleton class, so when instantiated it is accessible from anywhere in
the code (and in particular, all cells and cell-cycle models can access it). We need to say what
the profile of the Wnt concentation should be up the crypt: here, we say it is <tt>LINEAR</tt> (linear
decreasing from 1 to 0 from the bottom of the crypt to the top). We also need to inform the
<tt>WntConcentration</tt> of the cell population and the height of the crypt.
</p>
<div class="code"><pre>        WntConcentration<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>SetType<span class="p">(</span>LINEAR<span class="p">);</span>
        WntConcentration<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>SetCellPopulation<span class="p">(</span>cell_population<span class="p">);</span>
        WntConcentration<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>SetCryptLength<span class="p">(</span>crypt_height<span class="p">);</span>
</pre></div><p>
Create a simulator as before (except setting a different output directory).
</p>
<div class="code"><pre>        CryptSimulation2d simulator<span class="p">(</span>cell_population<span class="p">);</span>
        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"CryptTutorialWntCellCycle"</span><span class="p">);</span>
        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</pre></div><p>
As before, we create a force law and cell killer and pass these objects to the simulator, then call
Solve().
</p>
<div class="code"><pre>        GeneralisedLinearSpringForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> linear_force<span class="p">;</span>
        simulator<span class="p">.</span>AddForce<span class="p">(</span><span class="o">&amp;</span>linear_force<span class="p">);</span>
        SloughingCellKiller<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> killer<span class="p">(</span><span class="o">&amp;</span>cell_population<span class="p">,</span> crypt_height<span class="p">);</span>
        simulator<span class="p">.</span>AddCellKiller<span class="p">(</span><span class="o">&amp;</span>killer<span class="p">);</span>
        simulator<span class="p">.</span>Solve<span class="p">();</span>
</pre></div><p>
Finally, we must tidy up by destroying the <tt>SimulationTime</tt> and the <tt>WntConcentration</tt>
singleton objects. This avoids memory leaks occurring.
</p>
<div class="code"><pre>        WntConcentration<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>Destroy<span class="p">();</span>
        SimulationTime<span class="o">::</span>Destroy<span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div><p>
The results of this test can be visualized as in Test 1, with the correct output directory.
</p>
<h1 id="Code">Code</h1>
<p>
The full code is given below
</p>
<h2 id="FilenameTestRunningCryptSimulationsTutorial.hpp">File name <tt>TestRunningCryptSimulationsTutorial.hpp</tt></h2>
<div class="code"><pre><span class="cp">#include &lt;cxxtest/TestSuite.h&gt;
#include "CheckpointArchiveTypes.hpp"

#include "CryptCellsGenerator.hpp"
#include "FixedDurationGenerationBasedCellCycleModel.hpp"
#include "WntCellCycleModel.hpp"
#include "CylindricalHoneycombMeshGenerator.hpp"
#include "MeshBasedCellPopulationWithGhostNodes.hpp"
#include "GeneralisedLinearSpringForce.hpp"
#include "CryptSimulation2d.hpp"
#include "WntConcentration.hpp"
#include "SloughingCellKiller.hpp"
</span>
<span class="k">class</span> <span class="nc">TestRunningCryptSimulationsTutorial</span> <span class="o">:</span> <span class="k">public</span> CxxTest<span class="o">::</span>TestSuite
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> TestCryptWithFixedCellCycle<span class="p">()</span> <span class="k">throw</span><span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
        SimulationTime<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>SetStartTime<span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>

        CylindricalHoneycombMeshGenerator generator<span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
        Cylindrical2dMesh<span class="o">*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetCylindricalMesh<span class="p">();</span>
        std<span class="o">::</span>vector<span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> location_indices <span class="o">=</span> generator<span class="p">.</span>GetCellLocationIndices<span class="p">();</span>

        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        CryptCellsGenerator<span class="o">&lt;</span>FixedDurationGenerationBasedCellCycleModel<span class="o">&gt;</span> cells_generator<span class="p">;</span>
        cells_generator<span class="p">.</span>Generate<span class="p">(</span>cells<span class="p">,</span> p_mesh<span class="p">,</span> location_indices<span class="p">,</span> <span class="kc">true</span><span class="p">);</span>

        MeshBasedCellPopulationWithGhostNodes<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">,</span> location_indices<span class="p">);</span>

        CryptSimulation2d simulator<span class="p">(</span>cell_population<span class="p">);</span>
        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"CryptTutorialFixedCellCycle"</span><span class="p">);</span>
        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        simulator<span class="p">.</span>SetSamplingTimestepMultiple<span class="p">(</span><span class="mi">10</span><span class="p">);</span>

        GeneralisedLinearSpringForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> linear_force<span class="p">;</span>
        simulator<span class="p">.</span>AddForce<span class="p">(</span><span class="o">&amp;</span>linear_force<span class="p">);</span>

        <span class="kt">double</span> crypt_height <span class="o">=</span> <span class="mf">8.0</span><span class="p">;</span>
        SloughingCellKiller<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> killer<span class="p">(</span><span class="o">&amp;</span>cell_population<span class="p">,</span> crypt_height<span class="p">);</span>
        simulator<span class="p">.</span>AddCellKiller<span class="p">(</span><span class="o">&amp;</span>killer<span class="p">);</span>

        simulator<span class="p">.</span>Solve<span class="p">();</span>

        SimulationTime<span class="o">::</span>Destroy<span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> TestCryptWithWntCellCycle<span class="p">()</span> <span class="k">throw</span><span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
        SimulationTime<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>SetStartTime<span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
        RandomNumberGenerator<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>Reseed<span class="p">(</span><span class="mi">0</span><span class="p">);</span>

        CylindricalHoneycombMeshGenerator generator<span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
        Cylindrical2dMesh<span class="o">*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetCylindricalMesh<span class="p">();</span>

        std<span class="o">::</span>vector<span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> location_indices <span class="o">=</span> generator<span class="p">.</span>GetCellLocationIndices<span class="p">();</span>

        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        CryptCellsGenerator<span class="o">&lt;</span>WntCellCycleModel<span class="o">&gt;</span> cells_generator<span class="p">;</span>
        cells_generator<span class="p">.</span>Generate<span class="p">(</span>cells<span class="p">,</span> p_mesh<span class="p">,</span> location_indices<span class="p">,</span> <span class="kc">true</span><span class="p">);</span>

        MeshBasedCellPopulationWithGhostNodes<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">,</span> location_indices<span class="p">);</span>

        <span class="kt">double</span> crypt_height <span class="o">=</span> <span class="mf">8.0</span><span class="p">;</span>

        WntConcentration<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>SetType<span class="p">(</span>LINEAR<span class="p">);</span>
        WntConcentration<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>SetCellPopulation<span class="p">(</span>cell_population<span class="p">);</span>
        WntConcentration<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>SetCryptLength<span class="p">(</span>crypt_height<span class="p">);</span>

        CryptSimulation2d simulator<span class="p">(</span>cell_population<span class="p">);</span>
        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"CryptTutorialWntCellCycle"</span><span class="p">);</span>
        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mi">1</span><span class="p">);</span>

        GeneralisedLinearSpringForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> linear_force<span class="p">;</span>
        simulator<span class="p">.</span>AddForce<span class="p">(</span><span class="o">&amp;</span>linear_force<span class="p">);</span>
        SloughingCellKiller<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> killer<span class="p">(</span><span class="o">&amp;</span>cell_population<span class="p">,</span> crypt_height<span class="p">);</span>
        simulator<span class="p">.</span>AddCellKiller<span class="p">(</span><span class="o">&amp;</span>killer<span class="p">);</span>

        simulator<span class="p">.</span>Solve<span class="p">();</span>

        WntConcentration<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>Destroy<span class="p">();</span>
        SimulationTime<span class="o">::</span>Destroy<span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
        
        
      </div>

    </div>
  </body>
</html>
