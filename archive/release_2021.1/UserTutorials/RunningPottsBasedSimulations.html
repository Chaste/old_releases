<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>UserTutorials/RunningPottsBasedSimulations - Chaste</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="/trac-static/css/trac.css" type="text/css" />
    <link rel="stylesheet" href="/trac-static/css/wiki.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="/trac-static/css/site.css" />
  </head>
  <body>
    <div id="banner">
      <div id="header">
        <p>
          <a id="logo" href="http://www.cs.ox.ac.uk/chaste"><img src="/logos/chaste-266x60.jpg" alt="Chaste logo" height="60" width="266" /></a>
          <em>Documentation for <a href="/chaste/tutorials/release_2021.1/">Release 2021.1</a>.</em>
        </p>
      </div>
    </div>
    <p>&nbsp;</p>
    <div id="content" class="wiki">
      <div class="wikipage searchable">
        
          <div id="wikipage" class="trac-content"><p>
This tutorial is automatically generated from the file cell_based/test/tutorial/TestRunningPottsBasedSimulationsTutorial.hpp at revision <a class="changeset" href="/trac/changeset/5e8c8d7218a9/git_repo" title="Copyright mayhem!">5e8c8d7218a9/git_repo</a>.
Note that the code is given in full at the bottom of the page.
</p>
<h1 id="ExamplesshowinghowtocreaterunandvisualizePotts-basedsimulations">Examples showing how to create, run and visualize Potts-based simulations</h1>
<h2 id="Introduction">Introduction</h2>
<p>
In this tutorial we show how Chaste can be used to create, run and visualize Potts-based simulations.
Full details of the mathematical model can be found in Graner, F. and Glazier, J. A. (1992). Simulation
of biological cell sorting using a two-dimensional extended Potts model. Phys. Rev. Lett., 69(13):2015â€“2016.
</p>
<h2 id="Thetest">The test</h2>
<p>
As in previous cell-based Chaste tutorials, we begin by including the necessary header files.
</p>
<div class="code"><pre><span class="cp">#include &lt;cxxtest/TestSuite.h&gt;
#include "CheckpointArchiveTypes.hpp"
#include "AbstractCellBasedWithTimingsTestSuite.hpp"
#include "PetscSetupAndFinalize.hpp"
</span>
</pre></div><p>
The remaining header files define classes that will be used in the cell population
simulation test. We have encountered some of these header files in previous cell-based
Chaste tutorials.
</p>
<div class="code"><pre><span class="cp">#include "CellsGenerator.hpp"
#include "DifferentiatedCellProliferativeType.hpp"
#include "SmartPointers.hpp"
#include "UniformCellCycleModel.hpp"
</span></pre></div><p>
The next header file defines a helper class for generating a suitable mesh.
</p>
<div class="code"><pre><span class="cp">#include "PottsMeshGenerator.hpp"
</span></pre></div><p>
The next header file defines the class that simulates the evolution of an on lattice <tt>CellPopulation</tt>.
</p>
<div class="code"><pre><span class="cp">#include "OnLatticeSimulation.hpp"
</span></pre></div><p>
The next header file defines a<tt>CellPopulation</tt> class for implementing a cellular Potts model.
</p>
<div class="code"><pre><span class="cp">#include "PottsBasedCellPopulation.hpp"
</span></pre></div><p>
The next header files define some update rules for describing the Hamiltonian used to define the Potts simulations.
</p>
<div class="code"><pre><span class="cp">#include "VolumeConstraintPottsUpdateRule.hpp"
#include "AdhesionPottsUpdateRule.hpp"
#include "DifferentialAdhesionPottsUpdateRule.hpp"
#include "TransitCellProliferativeType.hpp"
</span></pre></div><p>
Finally these headers allow us to output cell labels.
</p>
<div class="code"><pre><span class="cp">#include "CellLabel.hpp"
#include "CellLabelWriter.hpp"
</span>
</pre></div><p>
Next, we define the test class, which inherits from <tt>AbstractCellBasedTestSuite</tt>
and defines some test methods.
</p>
<div class="code"><pre><span class="k">class</span> <span class="nc">TestRunningPottsBasedSimulationsTutorial</span> <span class="o">:</span> <span class="k">public</span> AbstractCellBasedWithTimingsTestSuite
<span class="p">{</span>
<span class="nl">public:</span>
</pre></div><h2 id="Test1-abasicPotts-basedsimulation">Test 1 - a basic Potts-based simulation</h2>
<p>
In the first test, we run a simple Potts-based simulation, in which we create a monolayer
of cells, using a Potts mesh. Each cell is assigned a stochastic cell-cycle model.
</p>
<div class="code"><pre>    <span class="kt">void</span> <span class="nf">TestMonolayer</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="cm">/** The next line is needed because we cannot currently run Potts simulations in parallel. */</span>
        EXIT_IF_PARALLEL<span class="p">;</span>

</pre></div><p>
First, we generate a Potts mesh. To create a <tt>PottsMesh</tt>, we can use
the <tt>PottsMeshGenerator</tt>. This generates a regular square-shaped mesh,
in which all elements are the same size.
Here the first three arguments specify the domain width; the number of elements across; and the width of
elements. The second set of three arguments specify the domain height; the number of elements up; and
the height of individual elements.
We have chosen a 2 by 2 block of elements, each consisting of 4 by 4  ( = 16) lattice sites.
</p>
<div class="code"><pre>        PottsMeshGenerator<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> generator<span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>  <span class="c1">// Parameters are: lattice sites across; num elements across; element width; lattice sites up; num elements up; and element height
</span>        PottsMesh<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetMesh<span class="p">();</span>

</pre></div><p>
Having created a mesh, we now create a <tt>std::vector</tt> of <tt>CellPtr</tt>s.
To do this, we the <tt>CellsGenerator</tt> helper class, which is templated over the type
of cell model required (here <tt>UniformCellCycleModel</tt>)
and the dimension. We create an empty vector of cells and pass this into the
method along with the mesh. The second argument represents the size of that the vector
<tt>cells</tt> should become - one cell for each element. Third argument makes all cells
proliferate.
</p>
<div class="code"><pre>        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        MAKE_PTR<span class="p">(</span>TransitCellProliferativeType<span class="p">,</span> p_transit_type<span class="p">);</span>
        CellsGenerator<span class="o">&lt;</span>UniformCellCycleModel<span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> cells_generator<span class="p">;</span>
        cells_generator<span class="p">.</span>GenerateBasicRandom<span class="p">(</span>cells<span class="p">,</span> p_mesh<span class="o">-&gt;</span>GetNumElements<span class="p">(),</span> p_transit_type<span class="p">);</span>

</pre></div><p>
Now we have a mesh and a set of cells to go with it, we can create a <tt>CellPopulation</tt>.
In general, this class associates a collection of cells with a mesh.
For this test, because we have a <tt>PottsMesh</tt>, we use a particular type of
cell population called a <tt>PottsBasedCellPopulation</tt>.
</p>
<div class="code"><pre>        PottsBasedCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">);</span>

</pre></div><p>
We can set the "Temperature" to be used in the Potts Simulation using the optional command below.
The default value is 0.1.
</p>
<div class="code"><pre>        cell_population<span class="p">.</span>SetTemperature<span class="p">(</span><span class="mf">0.1</span><span class="p">);</span>
</pre></div><p>
By default the Potts simulation will make 1 sweep over the whole domain per timestep.  To use a different
number of sweeps per timestep use the command.
</p>
<div class="code"><pre>        cell_population<span class="p">.</span>SetNumSweepsPerTimestep<span class="p">(</span><span class="mi">1</span><span class="p">);</span>

</pre></div><p>
We then pass in the cell population into an <tt>OnLatticeSimulation</tt>,
and set the output directory and end time.
</p>
<div class="code"><pre>        OnLatticeSimulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> simulator<span class="p">(</span>cell_population<span class="p">);</span>
        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"PottsBasedMonolayer"</span><span class="p">);</span>
        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mf">50.0</span><span class="p">);</span>
</pre></div><p>
The default timestep is 0.1, but can be changed using the below command. The timestep is used in conjunction with the "Temperature" and
number of sweeps per timestep to specify the relationship between cell movement and proliferation. We also set the simulation to only output
every 10 steps i.e. once per hour.
</p>
<div class="code"><pre>        simulator<span class="p">.</span>SetDt<span class="p">(</span><span class="mf">0.1</span><span class="p">);</span>
        simulator<span class="p">.</span>SetSamplingTimestepMultiple<span class="p">(</span><span class="mi">10</span><span class="p">);</span>

</pre></div><p>
We must now create one or more update rules, which determine the Hamiltonian
in the Potts simulation. For this test, we use two update rules based upon
a volume constraint (<tt>VolumeConstraintPottsUpdateRule</tt>) and adhesion between cells (<tt>AdhesionPottsUpdateRule</tt>) and pass them to the <tt>OnLatticeSimulation</tt>.
For a list of possible update rules see subclasses of <tt>AbstractPottsUpdateRule</tt>.
These can be found in the inheritance diagram, here, <a class="ext-link" href="https://chaste.cs.ox.ac.uk/chaste/docs/release_2021.1/classAbstractPottsUpdateRule.html" title="Documentation for the AbstractPottsUpdateRule class"><span class="icon">â€‹</span>AbstractPottsUpdateRule</a>.
</p>
<p>
Similarly to specifying forces for off lattice simulations we use the <tt>MAKE_PTR</tt> macro
to make a boost shared pointer to our required update rule before specifying parameters and passing to the simulation as follows
</p>
<div class="code"><pre>        MAKE_PTR<span class="p">(</span>VolumeConstraintPottsUpdateRule<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_volume_constraint_update_rule<span class="p">);</span>
</pre></div><p>
Set an appropriate target volume in number of lattice sites. Here we use the default value of 16 lattice sites.
</p>
<div class="code"><pre>        p_volume_constraint_update_rule<span class="o">-&gt;</span>SetMatureCellTargetVolume<span class="p">(</span><span class="mi">16</span><span class="p">);</span>
</pre></div><p>
You can also vary the deformation energy parameter. The larger the parameter
the more cells will try to maintain target volume. Here we use the default value of 0.2.
</p>
<div class="code"><pre>        p_volume_constraint_update_rule<span class="o">-&gt;</span>SetDeformationEnergyParameter<span class="p">(</span><span class="mf">0.2</span><span class="p">);</span>
</pre></div><p>
Finally we add the update rule to the simulator.
</p>
<div class="code"><pre>        simulator<span class="p">.</span>AddUpdateRule<span class="p">(</span>p_volume_constraint_update_rule<span class="p">);</span>
</pre></div><p>
We repeat the process for any other update rules.
</p>
<div class="code"><pre>        MAKE_PTR<span class="p">(</span>AdhesionPottsUpdateRule<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_adhesion_update_rule<span class="p">);</span>
        simulator<span class="p">.</span>AddUpdateRule<span class="p">(</span>p_adhesion_update_rule<span class="p">);</span>

</pre></div><p>
To run the simulation, we call <tt>Solve()</tt>.
</p>
<div class="code"><pre>        simulator<span class="p">.</span>Solve<span class="p">();</span>

</pre></div><p>
The next two lines are for test purposes only and are not part of this tutorial. If different simulation input parameters are being explored
the lines should be removed.
</p>
<div class="code"><pre>        TS_ASSERT_EQUALS<span class="p">(</span>cell_population<span class="p">.</span>GetNumRealCells<span class="p">(),</span> <span class="mi">64u</span><span class="p">);</span>
        TS_ASSERT_DELTA<span class="p">(</span>SimulationTime<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>GetTime<span class="p">(),</span> <span class="mf">50.0</span><span class="p">,</span> <span class="mf">1e-10</span><span class="p">);</span>
    <span class="p">}</span>

</pre></div><p>
To visualize the results, open a new terminal, <tt>cd</tt> to the Chaste directory,
then <tt>cd</tt> to <tt>anim</tt>. Then do: <tt>java Visualize2dVertexCells /tmp/$USER/testoutput/PottsBasedMonolayer/results_from_time_0</tt>.
We may have to do: <tt>javac Visualize2dVertexCells.java</tt> beforehand to create the
java executable.
</p>
<p>
We could also visualize the results using paraview.
</p>
<p>
See <a class="wiki" href="/chaste/tutorials/release_2021.1/UserTutorials/VisualizingWithParaview.html">UserTutorials/VisualizingWithParaview</a> for more information.
</p>
<p>
Load the file <tt>/tmp/$USER/testoutput/PottsBasedMonolayer/results_from_time_0/results.pvd</tt>, and click apply.
</p>
<p>
Add box "Glyphs" to represent lattice sites. You will need to adjust the size so they don't overlap.
</p>
<p>
Note that, for larger simulations, you may need to unclick "Mask Points" (or similar) so as not to limit the number of glyphs
displayed by Paraview.
</p>
<p>
Select the "Display" tab and select "color by" cell index to see individual cells.
</p>
<p>
Add a "Threshold" filter, filter by cell type and make the lower threshold 0 or greater (unoccupied lattice sites are labelled with -1). This will allow you to view only the cells.
</p>
<p>
Load the files <tt>/tmp/$USER/testoutput/PottsBasedMonolayer/results_from_time_0/outlines_..vtu</tt>, and click apply.
</p>
<p>
In order to see the cell outlines you will need to select "Surface With Edges" in the drop down menu.
</p>
<p>
Click play to see the evolution of the simulation.
</p>
<p>
You should see that the cells sort into ones of the same type.
</p>
<h2 id="Test2-CellSorting">Test 2 - Cell Sorting</h2>
<p>
The next test generates a collection of cells, there are two types of cells, labelled ones
and non labelled ones, there is differential adhesion between the cell types. For the
parameters specified, the cells sort into separate types.
</p>
<p>
Parameters are taken from Graner, F. and Glazier, J. A. (1992). Simulation of biological
cell sorting using a two-dimensional extended Potts model. Phys. Rev. Lett., 69(13):2015â€“2016.
</p>
<div class="code"><pre>    <span class="kt">void</span> <span class="nf">TestPottsMonolayerCellSorting</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="cm">/** The next line is needed because we cannot currently run Potts simulations in parallel. */</span>
        EXIT_IF_PARALLEL<span class="p">;</span>

</pre></div><p>
First, we generate a Potts mesh. To create a <tt>PottsMesh</tt>, we can use
the <tt>PottsMeshGenerator</tt>. This generates a regular square-shaped mesh,
in which all elements are the same size.
We have chosen an 8 by 8 block of elements each consisting of 4 by 4  ( = 16) lattice sites.
</p>
<div class="code"><pre>        PottsMeshGenerator<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> generator<span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>  <span class="c1">// Parameters are: lattice sites across; num elements across; element width; lattice sites up; num elements up; and element height
</span>        PottsMesh<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetMesh<span class="p">();</span>

</pre></div><p>
Having created a mesh, we now create a <tt>std::vector</tt> of <tt>CellPtr</tt>s.
To do this, we the <tt>CellsGenerator</tt> helper class, as before but this time
the third argument is set to make all cells non-proliferative.
</p>
<div class="code"><pre>        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        MAKE_PTR<span class="p">(</span>DifferentiatedCellProliferativeType<span class="p">,</span> p_diff_type<span class="p">);</span>
        CellsGenerator<span class="o">&lt;</span>UniformCellCycleModel<span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> cells_generator<span class="p">;</span>
        cells_generator<span class="p">.</span>GenerateBasicRandom<span class="p">(</span>cells<span class="p">,</span> p_mesh<span class="o">-&gt;</span>GetNumElements<span class="p">(),</span> p_diff_type<span class="p">);</span>

</pre></div><p>
Before we make a <tt>CellPopulation</tt> we make a boost shared pointer to a cell label and then assign this
label to some randomly chosen cells.
</p>
<div class="code"><pre>        MAKE_PTR<span class="p">(</span>CellLabel<span class="p">,</span> p_label<span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> i <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> i<span class="o">&lt;</span>cells<span class="p">.</span>size<span class="p">();</span> i<span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span>RandomNumberGenerator<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>ranf<span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">)</span>
            <span class="p">{</span>
                cells<span class="p">[</span>i<span class="p">]</span><span class="o">-&gt;</span>AddCellProperty<span class="p">(</span>p_label<span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

</pre></div><p>
Now we have a mesh and a set of cells to go with it, we can create a <tt>CellPopulation</tt>.
</p>
<div class="code"><pre>        PottsBasedCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">);</span>

</pre></div><p>
In order to visualize labelled cells we need to use the following command.
</p>
<div class="code"><pre>        cell_population<span class="p">.</span>AddCellWriter<span class="o">&lt;</span>CellLabelWriter<span class="o">&gt;</span><span class="p">();</span>

</pre></div><p>
We then pass in the cell population into an <tt>OnLatticeSimulation</tt>,
and set the output directory and end time.
</p>
<div class="code"><pre>        OnLatticeSimulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> simulator<span class="p">(</span>cell_population<span class="p">);</span>
        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"PottsMonolayerCellSorting"</span><span class="p">);</span>
        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mf">20.0</span><span class="p">);</span>
        simulator<span class="p">.</span>SetSamplingTimestepMultiple<span class="p">(</span><span class="mi">10</span><span class="p">);</span>

</pre></div><p>
We must now create one or more update rules, which determine the Hamiltonian
in the Potts simulation. For this test, we use two update rules based upon
a volume constraint (<tt>VolumeConstraintPottsUpdateRule</tt>) and differential adhesion between cells (<tt>DifferentialAdhesionPottsUpdateRule</tt>), set appropriate parameters, and pass them to the <tt>OnLatticeSimulation</tt>.
</p>
<div class="code"><pre>        MAKE_PTR<span class="p">(</span>VolumeConstraintPottsUpdateRule<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_volume_constraint_update_rule<span class="p">);</span>
        p_volume_constraint_update_rule<span class="o">-&gt;</span>SetMatureCellTargetVolume<span class="p">(</span><span class="mi">16</span><span class="p">);</span>
        p_volume_constraint_update_rule<span class="o">-&gt;</span>SetDeformationEnergyParameter<span class="p">(</span><span class="mf">0.2</span><span class="p">);</span>
        simulator<span class="p">.</span>AddUpdateRule<span class="p">(</span>p_volume_constraint_update_rule<span class="p">);</span>

        MAKE_PTR<span class="p">(</span>DifferentialAdhesionPottsUpdateRule<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_differential_adhesion_update_rule<span class="p">);</span>

        p_differential_adhesion_update_rule<span class="o">-&gt;</span>SetLabelledCellLabelledCellAdhesionEnergyParameter<span class="p">(</span><span class="mf">0.16</span><span class="p">);</span>
        p_differential_adhesion_update_rule<span class="o">-&gt;</span>SetLabelledCellCellAdhesionEnergyParameter<span class="p">(</span><span class="mf">0.11</span><span class="p">);</span>
        p_differential_adhesion_update_rule<span class="o">-&gt;</span>SetCellCellAdhesionEnergyParameter<span class="p">(</span><span class="mf">0.02</span><span class="p">);</span>
        p_differential_adhesion_update_rule<span class="o">-&gt;</span>SetLabelledCellBoundaryAdhesionEnergyParameter<span class="p">(</span><span class="mf">0.16</span><span class="p">);</span>
        p_differential_adhesion_update_rule<span class="o">-&gt;</span>SetCellBoundaryAdhesionEnergyParameter<span class="p">(</span><span class="mf">0.16</span><span class="p">);</span>
        simulator<span class="p">.</span>AddUpdateRule<span class="p">(</span>p_differential_adhesion_update_rule<span class="p">);</span>
</pre></div><p>
These parameters cause the cells to sort, for different values you can get different patterns.
</p>
<p>
To run the simulation, we call <tt>Solve()</tt>.
</p>
<div class="code"><pre>        simulator<span class="p">.</span>Solve<span class="p">();</span>

</pre></div><p>
The next two lines are for test purposes only and are not part of this tutorial.
</p>
<div class="code"><pre>        TS_ASSERT_EQUALS<span class="p">(</span>cell_population<span class="p">.</span>GetNumRealCells<span class="p">(),</span> <span class="mi">64u</span><span class="p">);</span>
        TS_ASSERT_DELTA<span class="p">(</span>SimulationTime<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>GetTime<span class="p">(),</span> <span class="mf">20.0</span><span class="p">,</span> <span class="mf">1e-10</span><span class="p">);</span>
    <span class="p">}</span>

</pre></div><p>
To visualize the results, open a new terminal, <tt>cd</tt> to the Chaste directory,
then <tt>cd</tt> to <tt>anim</tt>. Then do: <tt>java Visualize2dVertexCells /tmp/$USER/testoutput/PottsMonolayerCellSorting/results_from_time_0</tt>.
We may have to do: <tt>javac Visualize2dVertexCells.java</tt> beforehand to create the
java executable.
</p>
<p>
You could also visualize in paraview as above.
</p>
<h2 id="Test3-3DCellSorting">Test 3 - 3D Cell Sorting</h2>
<p>
The next test extends the previous example to three dimensions.
</p>
<div class="code"><pre>    <span class="kt">void</span> <span class="nf">TestPottsSpheroidCellSorting</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="cm">/** The next line is needed because we cannot currently run Potts simulations in parallel. */</span>
        EXIT_IF_PARALLEL<span class="p">;</span>

</pre></div><p>
First, we generate a Potts mesh. To create a <tt>PottsMesh</tt>, we can use
the <tt>PottsMeshGenerator</tt>. This generates a regular square-shaped mesh,
in which all elements are the same size.
</p>
<p>
Here the first three arguments specify the domain width; the number of elements across; and the width of
elements. The second set of three arguments specify the domain height; the number of elements up; and
the height of individual elements.  The third set of three arguments specify the domain depth; the number of elements deep; and
the depth of individual elements.
We have chosen an 4 by 4 by 4 ( = 64) block of elements each consisting of 2 by 2 by 2 ( = 8) lattice sites.
</p>
<div class="code"><pre>        PottsMeshGenerator<span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span> generator<span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>  <span class="c1">// Parameters are: lattice sites across; num elements across; element width; lattice sites up; num elements up; and element height; lattice sites deep; num elements deep; and element depth
</span>        PottsMesh<span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetMesh<span class="p">();</span>

</pre></div><p>
Having created a mesh, we now create a <tt>std::vector</tt> of <tt>CellPtr</tt>s.
To do this, we the <tt>CellsGenerator</tt> helper class, as before but this time
the third argument is set to make all cells non-proliferative.
</p>
<div class="code"><pre>        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        MAKE_PTR<span class="p">(</span>DifferentiatedCellProliferativeType<span class="p">,</span> p_diff_type<span class="p">);</span>
        CellsGenerator<span class="o">&lt;</span>UniformCellCycleModel<span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> cells_generator<span class="p">;</span>
        cells_generator<span class="p">.</span>GenerateBasicRandom<span class="p">(</span>cells<span class="p">,</span> p_mesh<span class="o">-&gt;</span>GetNumElements<span class="p">(),</span> p_diff_type<span class="p">);</span>

</pre></div><p>
As for the 2D case before we make a <tt>CellPopulation</tt> we make a pointer to a cell label and then assign this
label to some randomly chosen cells.
</p>
<div class="code"><pre>        MAKE_PTR<span class="p">(</span>CellLabel<span class="p">,</span> p_label<span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> i <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> i<span class="o">&lt;</span>cells<span class="p">.</span>size<span class="p">();</span> i<span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span>RandomNumberGenerator<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>ranf<span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">)</span>
            <span class="p">{</span>
                cells<span class="p">[</span>i<span class="p">]</span><span class="o">-&gt;</span>AddCellProperty<span class="p">(</span>p_label<span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

</pre></div><p>
Now we have a mesh and a set of cells to go with it, we can create a <tt>CellPopulation</tt>.
In general, this class associates a collection of cells with a set of elements or a mesh.
For this test, because we have a <tt>PottsMesh</tt>, we use a particular type of
cell population called a <tt>PottsBasedCellPopulation</tt>.
</p>
<div class="code"><pre>        PottsBasedCellPopulation<span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">);</span>

</pre></div><p>
In order to visualize labelled cells we need to use the following command.
</p>
<div class="code"><pre>        cell_population<span class="p">.</span>AddCellWriter<span class="o">&lt;</span>CellLabelWriter<span class="o">&gt;</span><span class="p">();</span>

</pre></div><p>
We then pass in the cell population into an <tt>OnLatticeSimulation</tt>,
and set the output directory and end time.
</p>
<div class="code"><pre>        OnLatticeSimulation<span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span> simulator<span class="p">(</span>cell_population<span class="p">);</span>
        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"PottsCellSorting3D"</span><span class="p">);</span>
        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mf">20.0</span><span class="p">);</span>
        simulator<span class="p">.</span>SetSamplingTimestepMultiple<span class="p">(</span><span class="mi">10</span><span class="p">);</span>

</pre></div><p>
We must now create one or more update rules, which determine the Hamiltonian
in the Potts simulation. For this test, we use two update rules based upon
an area constraint and differential adhesion between cells and pass them to the <tt>OnLatticeSimulation</tt>.
</p>
<div class="code"><pre>        MAKE_PTR<span class="p">(</span>VolumeConstraintPottsUpdateRule<span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">,</span> p_volume_constraint_update_rule<span class="p">);</span>
</pre></div><p>
Now set the target volume to be appropriate for this 3D simulation.
</p>
<div class="code"><pre>        p_volume_constraint_update_rule<span class="o">-&gt;</span>SetMatureCellTargetVolume<span class="p">(</span><span class="mf">8.0</span><span class="p">);</span>
        p_volume_constraint_update_rule<span class="o">-&gt;</span>SetDeformationEnergyParameter<span class="p">(</span><span class="mf">0.2</span><span class="p">);</span>
        simulator<span class="p">.</span>AddUpdateRule<span class="p">(</span>p_volume_constraint_update_rule<span class="p">);</span>

</pre></div><p>
We use the same differential adhesion parameters as in the 2D case.
</p>
<div class="code"><pre>        MAKE_PTR<span class="p">(</span>DifferentialAdhesionPottsUpdateRule<span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">,</span> p_differential_adhesion_update_rule<span class="p">);</span>
        p_differential_adhesion_update_rule<span class="o">-&gt;</span>SetLabelledCellLabelledCellAdhesionEnergyParameter<span class="p">(</span><span class="mf">0.16</span><span class="p">);</span>
        p_differential_adhesion_update_rule<span class="o">-&gt;</span>SetLabelledCellCellAdhesionEnergyParameter<span class="p">(</span><span class="mf">0.11</span><span class="p">);</span>
        p_differential_adhesion_update_rule<span class="o">-&gt;</span>SetCellCellAdhesionEnergyParameter<span class="p">(</span><span class="mf">0.02</span><span class="p">);</span>
        p_differential_adhesion_update_rule<span class="o">-&gt;</span>SetLabelledCellBoundaryAdhesionEnergyParameter<span class="p">(</span><span class="mf">0.16</span><span class="p">);</span>
        p_differential_adhesion_update_rule<span class="o">-&gt;</span>SetCellBoundaryAdhesionEnergyParameter<span class="p">(</span><span class="mf">0.16</span><span class="p">);</span>
        simulator<span class="p">.</span>AddUpdateRule<span class="p">(</span>p_differential_adhesion_update_rule<span class="p">);</span>

</pre></div><p>
To run the simulation, we call <tt>Solve()</tt>.
</p>
<div class="code"><pre>        simulator<span class="p">.</span>Solve<span class="p">();</span>

</pre></div><p>
The next two lines are for test purposes only and are not part of this tutorial.
</p>
<div class="code"><pre>        TS_ASSERT_EQUALS<span class="p">(</span>cell_population<span class="p">.</span>GetNumRealCells<span class="p">(),</span> <span class="mi">64u</span><span class="p">);</span>
        TS_ASSERT_DELTA<span class="p">(</span>SimulationTime<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>GetTime<span class="p">(),</span> <span class="mf">20.0</span><span class="p">,</span> <span class="mf">1e-10</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div><p>
To visualize the results, we need to use Paraview. Note that we don't output the cell boundaries (outlines) in 3D.
See <a class="wiki" href="/chaste/tutorials/release_2021.1/UserTutorials/VisualizingWithParaview.html">UserTutorials/VisualizingWithParaview</a> for more information.
</p>
<p>
Load the file <tt>/tmp/$USER/testoutput/PottsCellSorting3D/results_from_time_0/results.pvd</tt>, and click apply.
</p>
<p>
Add box "Glyphs" to represent lattice sites. You will need to adjust the size so they don't overlap.
</p>
<p>
Note that, for larger simulations, you may need to unclick "Mask Points" (or similar) so as not to limit the number of glyphs
displayed by Paraview.
</p>
<p>
Select the "Display" tab and select "color by" cell label (you can also "color by" cell index to see individual cells).
</p>
<p>
Add a "Threshold" filter, filter by cell type and make the lower threshold 0 or greater (unoccupied lattice sites are labelled with -1). This will allow you to view only the cells.
</p>
<p>
Click play to see the evolution of the simulation.
</p>
<p>
You should see that the cells sort into ones of the same type.
</p>
<div class="code"><pre><span class="p">};</span>

</pre></div><h1 id="Code">Code</h1>
<p>
The full code is given below
</p>
<h2 id="FilenameTestRunningPottsBasedSimulationsTutorial.hpp">File name <tt>TestRunningPottsBasedSimulationsTutorial.hpp</tt></h2>
<div class="code"><pre><span class="cp">#include &lt;cxxtest/TestSuite.h&gt;
#include "CheckpointArchiveTypes.hpp"
#include "AbstractCellBasedWithTimingsTestSuite.hpp"
#include "PetscSetupAndFinalize.hpp"
</span>
<span class="cp">#include "CellsGenerator.hpp"
#include "DifferentiatedCellProliferativeType.hpp"
#include "SmartPointers.hpp"
#include "UniformCellCycleModel.hpp"
#include "PottsMeshGenerator.hpp"
#include "OnLatticeSimulation.hpp"
#include "PottsBasedCellPopulation.hpp"
#include "VolumeConstraintPottsUpdateRule.hpp"
#include "AdhesionPottsUpdateRule.hpp"
#include "DifferentialAdhesionPottsUpdateRule.hpp"
#include "TransitCellProliferativeType.hpp"
#include "CellLabel.hpp"
#include "CellLabelWriter.hpp"
</span>
<span class="k">class</span> <span class="nc">TestRunningPottsBasedSimulationsTutorial</span> <span class="o">:</span> <span class="k">public</span> AbstractCellBasedWithTimingsTestSuite
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> TestMonolayer<span class="p">()</span>
    <span class="p">{</span>
        <span class="cm">/** The next line is needed because we cannot currently run Potts simulations in parallel. */</span>
        EXIT_IF_PARALLEL<span class="p">;</span>

        PottsMeshGenerator<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> generator<span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>  <span class="c1">// Parameters are: lattice sites across; num elements across; element width; lattice sites up; num elements up; and element height
</span>        PottsMesh<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetMesh<span class="p">();</span>

        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        MAKE_PTR<span class="p">(</span>TransitCellProliferativeType<span class="p">,</span> p_transit_type<span class="p">);</span>
        CellsGenerator<span class="o">&lt;</span>UniformCellCycleModel<span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> cells_generator<span class="p">;</span>
        cells_generator<span class="p">.</span>GenerateBasicRandom<span class="p">(</span>cells<span class="p">,</span> p_mesh<span class="o">-&gt;</span>GetNumElements<span class="p">(),</span> p_transit_type<span class="p">);</span>

        PottsBasedCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">);</span>

        cell_population<span class="p">.</span>SetTemperature<span class="p">(</span><span class="mf">0.1</span><span class="p">);</span>
        cell_population<span class="p">.</span>SetNumSweepsPerTimestep<span class="p">(</span><span class="mi">1</span><span class="p">);</span>

        OnLatticeSimulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> simulator<span class="p">(</span>cell_population<span class="p">);</span>
        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"PottsBasedMonolayer"</span><span class="p">);</span>
        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mf">50.0</span><span class="p">);</span>
        simulator<span class="p">.</span>SetDt<span class="p">(</span><span class="mf">0.1</span><span class="p">);</span>
        simulator<span class="p">.</span>SetSamplingTimestepMultiple<span class="p">(</span><span class="mi">10</span><span class="p">);</span>

        MAKE_PTR<span class="p">(</span>VolumeConstraintPottsUpdateRule<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_volume_constraint_update_rule<span class="p">);</span>
        p_volume_constraint_update_rule<span class="o">-&gt;</span>SetMatureCellTargetVolume<span class="p">(</span><span class="mi">16</span><span class="p">);</span>
        p_volume_constraint_update_rule<span class="o">-&gt;</span>SetDeformationEnergyParameter<span class="p">(</span><span class="mf">0.2</span><span class="p">);</span>
        simulator<span class="p">.</span>AddUpdateRule<span class="p">(</span>p_volume_constraint_update_rule<span class="p">);</span>
        MAKE_PTR<span class="p">(</span>AdhesionPottsUpdateRule<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_adhesion_update_rule<span class="p">);</span>
        simulator<span class="p">.</span>AddUpdateRule<span class="p">(</span>p_adhesion_update_rule<span class="p">);</span>

        simulator<span class="p">.</span>Solve<span class="p">();</span>

        TS_ASSERT_EQUALS<span class="p">(</span>cell_population<span class="p">.</span>GetNumRealCells<span class="p">(),</span> <span class="mi">64u</span><span class="p">);</span>
        TS_ASSERT_DELTA<span class="p">(</span>SimulationTime<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>GetTime<span class="p">(),</span> <span class="mf">50.0</span><span class="p">,</span> <span class="mf">1e-10</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> TestPottsMonolayerCellSorting<span class="p">()</span>
    <span class="p">{</span>
        <span class="cm">/** The next line is needed because we cannot currently run Potts simulations in parallel. */</span>
        EXIT_IF_PARALLEL<span class="p">;</span>

        PottsMeshGenerator<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> generator<span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>  <span class="c1">// Parameters are: lattice sites across; num elements across; element width; lattice sites up; num elements up; and element height
</span>        PottsMesh<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetMesh<span class="p">();</span>

        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        MAKE_PTR<span class="p">(</span>DifferentiatedCellProliferativeType<span class="p">,</span> p_diff_type<span class="p">);</span>
        CellsGenerator<span class="o">&lt;</span>UniformCellCycleModel<span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> cells_generator<span class="p">;</span>
        cells_generator<span class="p">.</span>GenerateBasicRandom<span class="p">(</span>cells<span class="p">,</span> p_mesh<span class="o">-&gt;</span>GetNumElements<span class="p">(),</span> p_diff_type<span class="p">);</span>

        MAKE_PTR<span class="p">(</span>CellLabel<span class="p">,</span> p_label<span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> i <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> i<span class="o">&lt;</span>cells<span class="p">.</span>size<span class="p">();</span> i<span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span>RandomNumberGenerator<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>ranf<span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">)</span>
            <span class="p">{</span>
                cells<span class="p">[</span>i<span class="p">]</span><span class="o">-&gt;</span>AddCellProperty<span class="p">(</span>p_label<span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        PottsBasedCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">);</span>

        cell_population<span class="p">.</span>AddCellWriter<span class="o">&lt;</span>CellLabelWriter<span class="o">&gt;</span><span class="p">();</span>

        OnLatticeSimulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> simulator<span class="p">(</span>cell_population<span class="p">);</span>
        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"PottsMonolayerCellSorting"</span><span class="p">);</span>
        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mf">20.0</span><span class="p">);</span>
        simulator<span class="p">.</span>SetSamplingTimestepMultiple<span class="p">(</span><span class="mi">10</span><span class="p">);</span>

        MAKE_PTR<span class="p">(</span>VolumeConstraintPottsUpdateRule<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_volume_constraint_update_rule<span class="p">);</span>
        p_volume_constraint_update_rule<span class="o">-&gt;</span>SetMatureCellTargetVolume<span class="p">(</span><span class="mi">16</span><span class="p">);</span>
        p_volume_constraint_update_rule<span class="o">-&gt;</span>SetDeformationEnergyParameter<span class="p">(</span><span class="mf">0.2</span><span class="p">);</span>
        simulator<span class="p">.</span>AddUpdateRule<span class="p">(</span>p_volume_constraint_update_rule<span class="p">);</span>

        MAKE_PTR<span class="p">(</span>DifferentialAdhesionPottsUpdateRule<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_differential_adhesion_update_rule<span class="p">);</span>

        p_differential_adhesion_update_rule<span class="o">-&gt;</span>SetLabelledCellLabelledCellAdhesionEnergyParameter<span class="p">(</span><span class="mf">0.16</span><span class="p">);</span>
        p_differential_adhesion_update_rule<span class="o">-&gt;</span>SetLabelledCellCellAdhesionEnergyParameter<span class="p">(</span><span class="mf">0.11</span><span class="p">);</span>
        p_differential_adhesion_update_rule<span class="o">-&gt;</span>SetCellCellAdhesionEnergyParameter<span class="p">(</span><span class="mf">0.02</span><span class="p">);</span>
        p_differential_adhesion_update_rule<span class="o">-&gt;</span>SetLabelledCellBoundaryAdhesionEnergyParameter<span class="p">(</span><span class="mf">0.16</span><span class="p">);</span>
        p_differential_adhesion_update_rule<span class="o">-&gt;</span>SetCellBoundaryAdhesionEnergyParameter<span class="p">(</span><span class="mf">0.16</span><span class="p">);</span>
        simulator<span class="p">.</span>AddUpdateRule<span class="p">(</span>p_differential_adhesion_update_rule<span class="p">);</span>
        simulator<span class="p">.</span>Solve<span class="p">();</span>

        TS_ASSERT_EQUALS<span class="p">(</span>cell_population<span class="p">.</span>GetNumRealCells<span class="p">(),</span> <span class="mi">64u</span><span class="p">);</span>
        TS_ASSERT_DELTA<span class="p">(</span>SimulationTime<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>GetTime<span class="p">(),</span> <span class="mf">20.0</span><span class="p">,</span> <span class="mf">1e-10</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> TestPottsSpheroidCellSorting<span class="p">()</span>
    <span class="p">{</span>
        <span class="cm">/** The next line is needed because we cannot currently run Potts simulations in parallel. */</span>
        EXIT_IF_PARALLEL<span class="p">;</span>

        PottsMeshGenerator<span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span> generator<span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>  <span class="c1">// Parameters are: lattice sites across; num elements across; element width; lattice sites up; num elements up; and element height; lattice sites deep; num elements deep; and element depth
</span>        PottsMesh<span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetMesh<span class="p">();</span>

        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        MAKE_PTR<span class="p">(</span>DifferentiatedCellProliferativeType<span class="p">,</span> p_diff_type<span class="p">);</span>
        CellsGenerator<span class="o">&lt;</span>UniformCellCycleModel<span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> cells_generator<span class="p">;</span>
        cells_generator<span class="p">.</span>GenerateBasicRandom<span class="p">(</span>cells<span class="p">,</span> p_mesh<span class="o">-&gt;</span>GetNumElements<span class="p">(),</span> p_diff_type<span class="p">);</span>

        MAKE_PTR<span class="p">(</span>CellLabel<span class="p">,</span> p_label<span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> i <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> i<span class="o">&lt;</span>cells<span class="p">.</span>size<span class="p">();</span> i<span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span>RandomNumberGenerator<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>ranf<span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">)</span>
            <span class="p">{</span>
                cells<span class="p">[</span>i<span class="p">]</span><span class="o">-&gt;</span>AddCellProperty<span class="p">(</span>p_label<span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        PottsBasedCellPopulation<span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">);</span>

        cell_population<span class="p">.</span>AddCellWriter<span class="o">&lt;</span>CellLabelWriter<span class="o">&gt;</span><span class="p">();</span>

        OnLatticeSimulation<span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span> simulator<span class="p">(</span>cell_population<span class="p">);</span>
        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"PottsCellSorting3D"</span><span class="p">);</span>
        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mf">20.0</span><span class="p">);</span>
        simulator<span class="p">.</span>SetSamplingTimestepMultiple<span class="p">(</span><span class="mi">10</span><span class="p">);</span>

        MAKE_PTR<span class="p">(</span>VolumeConstraintPottsUpdateRule<span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">,</span> p_volume_constraint_update_rule<span class="p">);</span>
        p_volume_constraint_update_rule<span class="o">-&gt;</span>SetMatureCellTargetVolume<span class="p">(</span><span class="mf">8.0</span><span class="p">);</span>
        p_volume_constraint_update_rule<span class="o">-&gt;</span>SetDeformationEnergyParameter<span class="p">(</span><span class="mf">0.2</span><span class="p">);</span>
        simulator<span class="p">.</span>AddUpdateRule<span class="p">(</span>p_volume_constraint_update_rule<span class="p">);</span>

        MAKE_PTR<span class="p">(</span>DifferentialAdhesionPottsUpdateRule<span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">,</span> p_differential_adhesion_update_rule<span class="p">);</span>
        p_differential_adhesion_update_rule<span class="o">-&gt;</span>SetLabelledCellLabelledCellAdhesionEnergyParameter<span class="p">(</span><span class="mf">0.16</span><span class="p">);</span>
        p_differential_adhesion_update_rule<span class="o">-&gt;</span>SetLabelledCellCellAdhesionEnergyParameter<span class="p">(</span><span class="mf">0.11</span><span class="p">);</span>
        p_differential_adhesion_update_rule<span class="o">-&gt;</span>SetCellCellAdhesionEnergyParameter<span class="p">(</span><span class="mf">0.02</span><span class="p">);</span>
        p_differential_adhesion_update_rule<span class="o">-&gt;</span>SetLabelledCellBoundaryAdhesionEnergyParameter<span class="p">(</span><span class="mf">0.16</span><span class="p">);</span>
        p_differential_adhesion_update_rule<span class="o">-&gt;</span>SetCellBoundaryAdhesionEnergyParameter<span class="p">(</span><span class="mf">0.16</span><span class="p">);</span>
        simulator<span class="p">.</span>AddUpdateRule<span class="p">(</span>p_differential_adhesion_update_rule<span class="p">);</span>

        simulator<span class="p">.</span>Solve<span class="p">();</span>

        TS_ASSERT_EQUALS<span class="p">(</span>cell_population<span class="p">.</span>GetNumRealCells<span class="p">(),</span> <span class="mi">64u</span><span class="p">);</span>
        TS_ASSERT_DELTA<span class="p">(</span>SimulationTime<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>GetTime<span class="p">(),</span> <span class="mf">20.0</span><span class="p">,</span> <span class="mf">1e-10</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

</pre></div></div>
          

    </div>
  </body>
</html>
