<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>UserTutorials/AnotherCardiacElectroMechanics - Chaste</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="https://chaste.github.io/old_releases/trac.css" type="text/css" />
    <link rel="stylesheet" href="https://chaste.github.io/old_releases/wiki.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="https://chaste.github.io/old_releases/site.css" />
  </head>
  <body>
    <div id="banner">
      <div id="header">
        <p>
          <a id="logo" href="https://chaste.github.io/"><img src="https://chaste.github.io/chaste_0256.png" alt="Chaste logo" height="60" /></a>
          <em>Documentation for <a href="https://chaste.github.io/old_releases/release_2021.1/">Release 2021.1</a>.</em>
        </p>
      </div>
    </div>
    <p>&nbsp;</p>
    <div id="content" class="wiki">
      <div class="wikipage searchable">
        
          <div id="wikipage" class="trac-content"><p>
This tutorial is automatically generated from the file heart/test/tutorials/TestAnotherCardiacElectroMechanicsTutorial.hpp at revision <a class="changeset" href="/trac/changeset/5e8c8d7218a9/git_repo" title="Copyright mayhem!">5e8c8d7218a9/git_repo</a>.
Note that the code is given in full at the bottom of the page.
</p>
<h1 id="CardiacElectro-mechanicalProblemscont.">Cardiac Electro-mechanical Problems (cont.)</h1>
<p>
It is worth running this test suite with <tt>build=GccOpt_ndebug</tt>
</p>
<p>
The same includes as the previous tutorial
</p>
<div class="code"><pre><span class="cp">#include &lt;cxxtest/TestSuite.h&gt;
#include "PlaneStimulusCellFactory.hpp"
#include "PetscSetupAndFinalize.hpp"
#include "CardiacElectroMechProbRegularGeom.hpp"
#include "CardiacElectroMechanicsProblem.hpp"
#include "LuoRudy1991.hpp"
#include "NonlinearElasticityTools.hpp"
#include "NobleVargheseKohlNoble1998WithSac.hpp"
#include "CompressibleMooneyRivlinMaterialLaw.hpp"
#include "NobleVargheseKohlNoble1998WithSac.hpp"
#include "Hdf5ToMeshalyzerConverter.hpp"
#include "ZeroStimulusCellFactory.hpp"
#include "FileFinder.hpp"
</span>
</pre></div><p>
A cell factory used in one of the tests
</p>
<div class="code"><pre><span class="k">class</span> <span class="nc">PointStimulus2dCellFactory</span> <span class="o">:</span> <span class="k">public</span> AbstractCardiacCellFactory<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="nl">private:</span>
    boost<span class="o">::</span>shared_ptr<span class="o">&lt;</span>SimpleStimulus<span class="o">&gt;</span> mpStimulus<span class="p">;</span>

<span class="nl">public:</span>
    PointStimulus2dCellFactory<span class="p">()</span>
        <span class="o">:</span> AbstractCardiacCellFactory<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(),</span>
          mpStimulus<span class="p">(</span><span class="k">new</span> SimpleStimulus<span class="p">(</span><span class="o">-</span><span class="mf">5e5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">))</span>
    <span class="p">{</span>
    <span class="p">}</span>

    AbstractCardiacCell<span class="o">*</span> CreateCardiacCellForTissueNode<span class="p">(</span>Node<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;*</span> pNode<span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">double</span> x <span class="o">=</span> pNode<span class="o">-&gt;</span>rGetLocation<span class="p">()[</span><span class="mi">0</span><span class="p">];</span>
        <span class="kt">double</span> y <span class="o">=</span> pNode<span class="o">-&gt;</span>rGetLocation<span class="p">()[</span><span class="mi">1</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span>fabs<span class="p">(</span>x<span class="p">)</span><span class="o">&lt;</span><span class="mf">0.02</span><span class="o">+</span><span class="mf">1e-6</span> <span class="o">&amp;&amp;</span> y<span class="o">&lt;-</span><span class="mf">0.4</span><span class="o">+</span><span class="mf">1e-6</span><span class="p">)</span> <span class="c1">// stimulating small region
</span>        <span class="p">{</span>
            <span class="k">return</span> <span class="k">new</span> CellLuoRudy1991FromCellML<span class="p">(</span>mpSolver<span class="p">,</span> mpStimulus<span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">new</span> CellLuoRudy1991FromCellML<span class="p">(</span>mpSolver<span class="p">,</span> mpZeroStimulus<span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">TestAnotherCardiacElectroMechanicsTutorial</span> <span class="o">:</span> <span class="k">public</span> CxxTest<span class="o">::</span>TestSuite
<span class="p">{</span>
<span class="nl">public:</span>
</pre></div><h2 id="Mechano-electricfeedbackandalternativeboundaryconditions">Mechano-electric feedback, and alternative boundary conditions</h2>
<p>
Let us now run a simulation with mechano-electric feedback (MEF), and with different boundary conditions.
</p>
<div class="code"><pre>    <span class="kt">void</span> <span class="nf">TestWithMef</span><span class="p">()</span>
    <span class="p">{</span>
</pre></div><p>
If we want to use MEF, where the stretch (in the fibre-direction) couples back to the cell
model and is used in stretch-activated channels (SACs), we can't just let Chaste convert
from cellml to C++ code as usual (see electro-physiology tutorials on how cell model files
are autogenerated from CellML during compilation), since these files don't use stretch and don't
have SACs. We have to use chaste_codegen to create a cell model class for us, rename and save it, and
manually add the SAC current.
</p>
<p>
There is one example of this already in the code-base, which we will use it the following
simulation. It is the Noble 98 model, with a SAC added that depends linearly on stretches (&gt;1).
It is found in the file !NobleVargheseKohlNoble1998WithSac.hpp, and is called
<tt>CML_noble_varghese_kohl_noble_1998_basic_with_sac</tt>.
</p>
<p>
To add a SAC current to (or otherwise alter) your favourite cell model, you have to do the following.
Auto-generate the C++ code, by running the following on the cellml file:
<tt>./python/ConvertCellModel.py heart/src/odes/cellml/LuoRudy1991.cellml</tt>
(see <a class="wiki" href="https://chaste.github.io/old_releases/release_2021.1/ChasteGuides/CodeGenerationFromCellML.html#Usingthehelperscript">ChasteGuides/CodeGenerationFromCellML#Usingthehelperscript</a>
if you want further documentation on this script).
</p>
<p>
Copy and rename the resultant .hpp and .cpp files (which can be found in the same folder as the
input cellml). For example, rename everything to <tt>LuoRudy1991WithSac</tt>. Then alter the class
to overload the method <tt>AbstractCardiacCell::SetStretch(double stretch)</tt> to store the stretch,
and then implement the SAC in the <tt>GetIIonic()</tt> method.  <tt>CML_noble_varghese_kohl_noble_1998_basic_with_sac</tt>
provides an example of the changes that need to be made.
</p>
<p>
Let us create a cell factory returning these Noble98 SAC cells, but with no stimulus - the
SAC switching on will lead be to activation.
</p>
<div class="code"><pre>        ZeroStimulusCellFactory<span class="o">&lt;</span>CML_noble_varghese_kohl_noble_1998_basic_with_sac<span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> cell_factory<span class="p">;</span>

</pre></div><p>
Construct two meshes are before, in 2D
</p>
<div class="code"><pre>        TetrahedralMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> electrics_mesh<span class="p">;</span>
        electrics_mesh<span class="p">.</span>ConstructRegularSlabMesh<span class="p">(</span><span class="mf">0.01</span><span class="cm">/*stepsize*/</span><span class="p">,</span> <span class="mf">0.1</span><span class="cm">/*length*/</span><span class="p">,</span> <span class="mf">0.1</span><span class="cm">/*width*/</span><span class="p">,</span> <span class="mf">0.1</span><span class="cm">/*depth*/</span><span class="p">);</span>

        QuadraticMesh<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> mechanics_mesh<span class="p">;</span>
        mechanics_mesh<span class="p">.</span>ConstructRegularSlabMesh<span class="p">(</span><span class="mf">0.02</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span> <span class="cm">/*as above with a different stepsize*/</span><span class="p">);</span>

</pre></div><p>
Collect the fixed nodes. This time we directly specify the new locations. We say the
nodes on X=0 are to be fixed, setting the deformed x=0, but leaving y to be free
(sliding boundary conditions). This functionality is described in more detail in the
solid mechanics tutorials.
</p>
<div class="code"><pre>        std<span class="o">::</span>vector<span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> fixed_nodes<span class="p">;</span>
        std<span class="o">::</span>vector<span class="o">&lt;</span>c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> <span class="o">&gt;</span> fixed_node_locations<span class="p">;</span>

        fixed_nodes<span class="p">.</span>push_back<span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        fixed_node_locations<span class="p">.</span>push_back<span class="p">(</span>zero_vector<span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> i<span class="o">=</span><span class="mi">1</span><span class="p">;</span> i<span class="o">&lt;</span>mechanics_mesh<span class="p">.</span>GetNumNodes<span class="p">();</span> i<span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">double</span> X <span class="o">=</span> mechanics_mesh<span class="p">.</span>GetNode<span class="p">(</span>i<span class="p">)</span><span class="o">-&gt;</span>rGetLocation<span class="p">()[</span><span class="mi">0</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span>fabs<span class="p">(</span>X<span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="c1">// ie, if X==0
</span>            <span class="p">{</span>
                c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> new_position<span class="p">;</span>
                new_position<span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
                new_position<span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> ElectroMechanicsProblemDefinition<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>FREE<span class="p">;</span>

                fixed_nodes<span class="p">.</span>push_back<span class="p">(</span>i<span class="p">);</span>
                fixed_node_locations<span class="p">.</span>push_back<span class="p">(</span>new_position<span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

</pre></div><p>
Now specify tractions on the top and bottom surfaces. For full descriptions of how
to apply tractions see the solid mechanics tutorials. Here, we collect the boundary
elements on the bottom and top surfaces, and apply inward tractions - this will have the
effect of stretching the tissue in the X-direction.
</p>
<div class="code"><pre>        std<span class="o">::</span>vector<span class="o">&lt;</span>BoundaryElement<span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*&gt;</span> boundary_elems<span class="p">;</span>
        std<span class="o">::</span>vector<span class="o">&lt;</span>c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> <span class="o">&gt;</span> tractions<span class="p">;</span>

        c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> traction<span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span>TetrahedralMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;::</span>BoundaryElementIterator iter <span class="o">=</span> mechanics_mesh<span class="p">.</span>GetBoundaryElementIteratorBegin<span class="p">();</span>
             iter <span class="o">!=</span> mechanics_mesh<span class="p">.</span>GetBoundaryElementIteratorEnd<span class="p">();</span>
             <span class="o">++</span>iter<span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span>fabs<span class="p">((</span><span class="o">*</span>iter<span class="p">)</span><span class="o">-&gt;</span>CalculateCentroid<span class="p">()[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="c1">// if Y=0
</span>            <span class="p">{</span>
                BoundaryElement<span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> p_element <span class="o">=</span> <span class="o">*</span>iter<span class="p">;</span>
                boundary_elems<span class="p">.</span>push_back<span class="p">(</span>p_element<span class="p">);</span>

                traction<span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span>  <span class="mf">0.0</span><span class="p">;</span> <span class="c1">// kPa, since the contraction model and material law use kPa for stiffnesses
</span>                traction<span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span>  <span class="mf">1.0</span><span class="p">;</span> <span class="c1">// kPa, since the contraction model and material law use kPa for stiffnesses
</span>                tractions<span class="p">.</span>push_back<span class="p">(</span>traction<span class="p">);</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span>fabs<span class="p">((</span><span class="o">*</span>iter<span class="p">)</span><span class="o">-&gt;</span>CalculateCentroid<span class="p">()[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="c1">// if Y=0.1
</span>            <span class="p">{</span>
                BoundaryElement<span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> p_element <span class="o">=</span> <span class="o">*</span>iter<span class="p">;</span>
                boundary_elems<span class="p">.</span>push_back<span class="p">(</span>p_element<span class="p">);</span>

                traction<span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span>  <span class="mf">0.0</span><span class="p">;</span>
                traction<span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">;</span>
                tractions<span class="p">.</span>push_back<span class="p">(</span>traction<span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

</pre></div><p>
Now set up the problem. We will use a compressible approach.
</p>
<div class="code"><pre>        ElectroMechanicsProblemDefinition<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> problem_defn<span class="p">(</span>mechanics_mesh<span class="p">);</span>
        problem_defn<span class="p">.</span>SetContractionModel<span class="p">(</span>KERCHOFFS2003<span class="p">,</span><span class="mf">0.01</span><span class="cm">/*contraction model ODE timestep*/</span><span class="p">);</span>
        problem_defn<span class="p">.</span>SetUseDefaultCardiacMaterialLaw<span class="p">(</span>INCOMPRESSIBLE<span class="p">);</span>
        problem_defn<span class="p">.</span>SetMechanicsSolveTimestep<span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
</pre></div><p>
Set the fixed node and traction info.
</p>
<div class="code"><pre>        problem_defn<span class="p">.</span>SetFixedNodes<span class="p">(</span>fixed_nodes<span class="p">,</span> fixed_node_locations<span class="p">);</span>
        problem_defn<span class="p">.</span>SetTractionBoundaryConditions<span class="p">(</span>boundary_elems<span class="p">,</span> tractions<span class="p">);</span>

</pre></div><p>
Now say that the deformation should affect the electro-physiology
</p>
<div class="code"><pre>        problem_defn<span class="p">.</span>SetDeformationAffectsElectrophysiology<span class="p">(</span><span class="nb">false</span> <span class="cm">/*deformation affects conductivity*/</span><span class="p">,</span> <span class="nb">true</span> <span class="cm">/*deformation affects cell models*/</span><span class="p">);</span>

</pre></div><p>
Set the end time, create the problem, and solve
</p>
<div class="code"><pre>        HeartConfig<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>SetSimulationDuration<span class="p">(</span><span class="mf">50.0</span><span class="p">);</span>

        CardiacElectroMechanicsProblem<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span> problem<span class="p">(</span>INCOMPRESSIBLE<span class="p">,</span>
                                                    MONODOMAIN<span class="p">,</span>
                                                    <span class="o">&amp;</span>electrics_mesh<span class="p">,</span>
                                                    <span class="o">&amp;</span>mechanics_mesh<span class="p">,</span>
                                                    <span class="o">&amp;</span>cell_factory<span class="p">,</span>
                                                    <span class="o">&amp;</span>problem_defn<span class="p">,</span>
                                                    <span class="s">"TestCardiacElectroMechanicsWithMef"</span><span class="p">);</span>
        problem<span class="p">.</span>Solve<span class="p">();</span>

</pre></div><p>
Nothing exciting happens in the simulation as it is currently written. To get some interesting occurring,
alter the SAC conductance in the cell model from 0.035 to 0.35 (micro-Siemens).
(look for the line <tt>const double g_sac = 0.035</tt> in <tt>NobleVargheseKohlNoble1998WithSac.hpp</tt>).
</p>
<p>
Rerun and visualise as usual, using Cmgui. By visualising the voltage on the deforming mesh, you can see that the
voltage gradually increases due to the SAC, since the tissue is stretched, until the threshold is reached
and activation occurs.
</p>
<p>
For MEF simulations, we may want to visualise the electrical results on the electrics mesh using
Meshalyzer, for example to more easily visualise action potentials. This isn't (and currently
can't be) created by <tt>CardiacElectroMechanicsProblem</tt>. We can use a converter as follows
to post-process:
</p>
<div class="code"><pre>        FileFinder <span class="nf">test_output_folder</span><span class="p">(</span><span class="s">"TestCardiacElectroMechanicsWithMef/electrics"</span><span class="p">,</span> RelativeTo<span class="o">::</span>ChasteTestOutput<span class="p">);</span>
        Hdf5ToMeshalyzerConverter<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> converter<span class="p">(</span>test_output_folder<span class="p">,</span> <span class="s">"voltage"</span><span class="p">,</span>
                                                 <span class="o">&amp;</span>electrics_mesh<span class="p">,</span> <span class="nb">false</span><span class="p">,</span>
                                                 HeartConfig<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>GetVisualizerOutputPrecision<span class="p">());</span>

</pre></div><p>
Some other notes. If you want to apply time-dependent traction boundary conditions, this is possible by
specifying the traction in functional form - see solid mechanics tutorials. Similarly, more natural
'pressure acting on the deformed body' boundary conditions are possible - see below tutorial.
</p>
<p>
<strong>Robustness:</strong> Sometimes the nonlinear solver doesn't converge, and will give an error. This can be due to either
a non-physical (or not very physical) situation, or just because the current guess is quite far
from the solution and the solver can't find the solution (this can occur in nonlinear elasticity
problems if the loading is large, for example). Current work in progress is on making the solver
more robust, and also on parallelising the solver. One option when a solve fails is to decrease the
mechanics timestep.
</p>
<p>
Ignore the following, it is just to check nothing has changed.
</p>
<div class="code"><pre>        Hdf5DataReader <span class="nf">reader</span><span class="p">(</span><span class="s">"TestCardiacElectroMechanicsWithMef/electrics"</span><span class="p">,</span> <span class="s">"voltage"</span><span class="p">);</span>
        <span class="kt">unsigned</span> num_timesteps <span class="o">=</span> reader<span class="p">.</span>GetUnlimitedDimensionValues<span class="p">().</span>size<span class="p">();</span>
        Vec voltage <span class="o">=</span> PetscTools<span class="o">::</span>CreateVec<span class="p">(</span>electrics_mesh<span class="p">.</span>GetNumNodes<span class="p">());</span>
        reader<span class="p">.</span>GetVariableOverNodes<span class="p">(</span>voltage<span class="p">,</span> <span class="s">"V"</span><span class="p">,</span> num_timesteps<span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        ReplicatableVector <span class="nf">voltage_repl</span><span class="p">(</span>voltage<span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> i<span class="o">=</span><span class="mi">0</span><span class="p">;</span> i<span class="o">&lt;</span>voltage_repl<span class="p">.</span>GetSize<span class="p">();</span> i<span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            TS_ASSERT_DELTA<span class="p">(</span>voltage_repl<span class="p">[</span>i<span class="p">],</span> <span class="o">-</span><span class="mf">81.9080</span><span class="p">,</span> <span class="mf">1e-3</span><span class="p">);</span>
        <span class="p">}</span>
        PetscTools<span class="o">::</span>Destroy<span class="p">(</span>voltage<span class="p">);</span>
    <span class="p">}</span>

</pre></div><h2 id="Internalpressures">Internal pressures</h2>
<p>
Next, we run a simulation on a 2d annulus, with an internal pressure applied.
</p>
<div class="code"><pre>    <span class="kt">void</span> <span class="nf">TestAnnulusWithInternalPressure</span><span class="p">()</span>
    <span class="p">{</span>
</pre></div><p>
The following should require little explanation now
</p>
<div class="code"><pre>        TetrahedralMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> electrics_mesh<span class="p">;</span>
        QuadraticMesh<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> mechanics_mesh<span class="p">;</span>

        <span class="c1">// could (should?) use finer electrics mesh, but keeping electrics simulation time down
</span>        TrianglesMeshReader<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> reader1<span class="p">(</span><span class="s">"mesh/test/data/annuli/circular_annulus_960_elements"</span><span class="p">);</span>
        electrics_mesh<span class="p">.</span>ConstructFromMeshReader<span class="p">(</span>reader1<span class="p">);</span>

        TrianglesMeshReader<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> reader2<span class="p">(</span><span class="s">"mesh/test/data/annuli/circular_annulus_960_elements_quad"</span><span class="p">,</span><span class="mi">2</span> <span class="cm">/*quadratic elements*/</span><span class="p">);</span>
        mechanics_mesh<span class="p">.</span>ConstructFromMeshReader<span class="p">(</span>reader2<span class="p">);</span>

        PointStimulus2dCellFactory cell_factory<span class="p">;</span>

        std<span class="o">::</span>vector<span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> fixed_nodes<span class="p">;</span>
        std<span class="o">::</span>vector<span class="o">&lt;</span>c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> <span class="o">&gt;</span> fixed_node_locations<span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> i<span class="o">=</span><span class="mi">0</span><span class="p">;</span> i<span class="o">&lt;</span>mechanics_mesh<span class="p">.</span>GetNumNodes<span class="p">();</span> i<span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">double</span> x <span class="o">=</span> mechanics_mesh<span class="p">.</span>GetNode<span class="p">(</span>i<span class="p">)</span><span class="o">-&gt;</span>rGetLocation<span class="p">()[</span><span class="mi">0</span><span class="p">];</span>
            <span class="kt">double</span> y <span class="o">=</span> mechanics_mesh<span class="p">.</span>GetNode<span class="p">(</span>i<span class="p">)</span><span class="o">-&gt;</span>rGetLocation<span class="p">()[</span><span class="mi">1</span><span class="p">];</span>

            <span class="k">if</span> <span class="p">(</span>fabs<span class="p">(</span>x<span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-6</span> <span class="o">&amp;&amp;</span> fabs<span class="p">(</span>y<span class="o">+</span><span class="mf">0.5</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-6</span><span class="p">)</span>  <span class="c1">// fixed point (0.0,-0.5) at bottom of mesh
</span>            <span class="p">{</span>
                fixed_nodes<span class="p">.</span>push_back<span class="p">(</span>i<span class="p">);</span>
                c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> new_position<span class="p">;</span>
                new_position<span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> x<span class="p">;</span>
                new_position<span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> y<span class="p">;</span>
                fixed_node_locations<span class="p">.</span>push_back<span class="p">(</span>new_position<span class="p">);</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span>fabs<span class="p">(</span>x<span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-6</span> <span class="o">&amp;&amp;</span> fabs<span class="p">(</span>y<span class="o">-</span><span class="mf">0.5</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-6</span><span class="p">)</span>  <span class="c1">// constrained point (0.0,0.5) at top of mesh
</span>            <span class="p">{</span>
                fixed_nodes<span class="p">.</span>push_back<span class="p">(</span>i<span class="p">);</span>
                c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> new_position<span class="p">;</span>
                new_position<span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> x<span class="p">;</span>
                new_position<span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> ElectroMechanicsProblemDefinition<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>FREE<span class="p">;</span>
                fixed_node_locations<span class="p">.</span>push_back<span class="p">(</span>new_position<span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

</pre></div><p>
Increase this end time to see more contraction
</p>
<div class="code"><pre>        HeartConfig<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>SetSimulationDuration<span class="p">(</span><span class="mf">30.0</span><span class="p">);</span>

        ElectroMechanicsProblemDefinition<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> problem_defn<span class="p">(</span>mechanics_mesh<span class="p">);</span>

        problem_defn<span class="p">.</span>SetContractionModel<span class="p">(</span>KERCHOFFS2003<span class="p">,</span><span class="mf">0.1</span><span class="p">);</span>
        problem_defn<span class="p">.</span>SetUseDefaultCardiacMaterialLaw<span class="p">(</span>COMPRESSIBLE<span class="p">);</span>
        <span class="c1">//problem_defn.SetZeroDisplacementNodes(fixed_nodes);
</span>        problem_defn<span class="p">.</span>SetFixedNodes<span class="p">(</span>fixed_nodes<span class="p">,</span> fixed_node_locations<span class="p">);</span>
        problem_defn<span class="p">.</span>SetMechanicsSolveTimestep<span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>

        FileFinder <span class="nf">finder</span><span class="p">(</span><span class="s">"heart/test/data/fibre_tests/circular_annulus_960_elements.ortho"</span><span class="p">,</span>RelativeTo<span class="o">::</span>ChasteSourceRoot<span class="p">);</span>
        problem_defn<span class="p">.</span>SetVariableFibreSheetDirectionsFile<span class="p">(</span>finder<span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

</pre></div><p>
The elasticity solvers have two nonlinear solvers implemented, one hand-coded and one which uses PETSc's SNES
solver. The latter is not the default but can be more robust (and will probably be the default in later
versions). This is how it can be used. (This option can also be called if the compiled binary is run from
the command line (see <a class="wiki" href="https://chaste.github.io/old_releases/release_2021.1/ChasteGuides/RunningBinariesFromCommandLine.html">ChasteGuides/RunningBinariesFromCommandLine</a>) using the option "-mech_use_snes").
</p>
<div class="code"><pre>        problem_defn<span class="p">.</span>SetSolveUsingSnes<span class="p">();</span>

</pre></div><p>
Now let us collect all the boundary elements on the inner (endocardial) surface. The following
uses knowledge about the geometry - the inner surface is r=0.3, the outer is r=0.5.
</p>
<div class="code"><pre>        std<span class="o">::</span>vector<span class="o">&lt;</span>BoundaryElement<span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*&gt;</span> boundary_elems<span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span>TetrahedralMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;::</span>BoundaryElementIterator iter
               <span class="o">=</span> mechanics_mesh<span class="p">.</span>GetBoundaryElementIteratorBegin<span class="p">();</span>
             iter <span class="o">!=</span> mechanics_mesh<span class="p">.</span>GetBoundaryElementIteratorEnd<span class="p">();</span>
             <span class="o">++</span>iter<span class="p">)</span>
        <span class="p">{</span>
            ChastePoint<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> centroid <span class="o">=</span> <span class="p">(</span><span class="o">*</span>iter<span class="p">)</span><span class="o">-&gt;</span>CalculateCentroid<span class="p">();</span>
            <span class="kt">double</span> r <span class="o">=</span> sqrt<span class="p">(</span> centroid<span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span>centroid<span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> centroid<span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span>centroid<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span>r <span class="o">&lt;</span> <span class="mf">0.4</span><span class="p">)</span>
            <span class="p">{</span>
                BoundaryElement<span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> p_element <span class="o">=</span> <span class="o">*</span>iter<span class="p">;</span>
                boundary_elems<span class="p">.</span>push_back<span class="p">(</span>p_element<span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

</pre></div><p>
This is how to set the pressure to be applied to these boundary elements. The negative sign implies
inward pressure.
</p>
<div class="code"><pre>        problem_defn<span class="p">.</span>SetApplyNormalPressureOnDeformedSurface<span class="p">(</span>boundary_elems<span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span> <span class="cm">/*1 KPa is about 8mmHg*/</span><span class="p">);</span>
</pre></div><p>
The solver computes the equilibrium solution (given the pressure loading) before the first timestep.
As there is a big deformation from the undeformed state to this loaded state, the nonlinear solver may
not converge. The following increments the loading (solves with p=-1/3, then p=-2/3, then p=-1), which
allows convergence to occur.
</p>
<div class="code"><pre>        problem_defn<span class="p">.</span>SetNumIncrementsForInitialDeformation<span class="p">(</span><span class="mi">3</span><span class="p">);</span>

        CardiacElectroMechanicsProblem<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span> problem<span class="p">(</span>COMPRESSIBLE<span class="p">,</span>
                                                    MONODOMAIN<span class="p">,</span>
                                                    <span class="o">&amp;</span>electrics_mesh<span class="p">,</span>
                                                    <span class="o">&amp;</span>mechanics_mesh<span class="p">,</span>
                                                    <span class="o">&amp;</span>cell_factory<span class="p">,</span>
                                                    <span class="o">&amp;</span>problem_defn<span class="p">,</span>
                                                    <span class="s">"TestAnnulusWithInternalPressure"</span><span class="p">);</span>

</pre></div><p>
If we want stresses and strains output, we can do the following. The deformation gradients and 2nd PK stresses
for each element will be written at the requested times.
</p>
<div class="code"><pre>        problem<span class="p">.</span>SetOutputDeformationGradientsAndStress<span class="p">(</span><span class="mf">10.0</span> <span class="cm">/*how often (in ms) to write - should be a multiple of mechanics timestep*/</span><span class="p">);</span>

</pre></div><p>
Since this test involves a large deformation at t=0, several Newton iterations are required. To see how the nonlinear
solve is progressing, you can run from the binary from the command line with the command line argument "-mech_verbose".
</p>
<div class="code"><pre>        problem<span class="p">.</span>Solve<span class="p">();</span>
</pre></div><p>
Visualise using cmgui, and note the different shapes at t=-1 (undeformed) and t=0 (loaded)
</p>
<p>
Note: if you want to have a time-dependent pressure, you can replace the second parameter (the pressure)
in <tt>SetApplyNormalPressureOnDeformedSurface()</tt> with a function pointer (the name of a function) which returns
the pressure as a function of time.
</p>
<div class="code"><pre>    <span class="p">}</span>
</pre></div><p>
<strong>More examples:</strong> For a 3d ellipsoid geometry test, see heart/test/mechanics/TestCardiacElectroMechanicsOnEllipsoid.hpp
</p>
<div class="code"><pre><span class="p">};</span>

</pre></div><h1 id="Code">Code</h1>
<p>
The full code is given below
</p>
<h2 id="FilenameTestAnotherCardiacElectroMechanicsTutorial.hpp">File name <tt>TestAnotherCardiacElectroMechanicsTutorial.hpp</tt></h2>
<div class="code"><pre><span class="cp">#include &lt;cxxtest/TestSuite.h&gt;
#include "PlaneStimulusCellFactory.hpp"
#include "PetscSetupAndFinalize.hpp"
#include "CardiacElectroMechProbRegularGeom.hpp"
#include "CardiacElectroMechanicsProblem.hpp"
#include "LuoRudy1991.hpp"
#include "NonlinearElasticityTools.hpp"
#include "NobleVargheseKohlNoble1998WithSac.hpp"
#include "CompressibleMooneyRivlinMaterialLaw.hpp"
#include "NobleVargheseKohlNoble1998WithSac.hpp"
#include "Hdf5ToMeshalyzerConverter.hpp"
#include "ZeroStimulusCellFactory.hpp"
#include "FileFinder.hpp"
</span>
<span class="k">class</span> <span class="nc">PointStimulus2dCellFactory</span> <span class="o">:</span> <span class="k">public</span> AbstractCardiacCellFactory<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="nl">private:</span>
    boost<span class="o">::</span>shared_ptr<span class="o">&lt;</span>SimpleStimulus<span class="o">&gt;</span> mpStimulus<span class="p">;</span>

<span class="nl">public:</span>
    PointStimulus2dCellFactory<span class="p">()</span>
        <span class="o">:</span> AbstractCardiacCellFactory<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(),</span>
          mpStimulus<span class="p">(</span><span class="k">new</span> SimpleStimulus<span class="p">(</span><span class="o">-</span><span class="mf">5e5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">))</span>
    <span class="p">{</span>
    <span class="p">}</span>

    AbstractCardiacCell<span class="o">*</span> CreateCardiacCellForTissueNode<span class="p">(</span>Node<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;*</span> pNode<span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">double</span> x <span class="o">=</span> pNode<span class="o">-&gt;</span>rGetLocation<span class="p">()[</span><span class="mi">0</span><span class="p">];</span>
        <span class="kt">double</span> y <span class="o">=</span> pNode<span class="o">-&gt;</span>rGetLocation<span class="p">()[</span><span class="mi">1</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span>fabs<span class="p">(</span>x<span class="p">)</span><span class="o">&lt;</span><span class="mf">0.02</span><span class="o">+</span><span class="mf">1e-6</span> <span class="o">&amp;&amp;</span> y<span class="o">&lt;-</span><span class="mf">0.4</span><span class="o">+</span><span class="mf">1e-6</span><span class="p">)</span> <span class="c1">// stimulating small region
</span>        <span class="p">{</span>
            <span class="k">return</span> <span class="k">new</span> CellLuoRudy1991FromCellML<span class="p">(</span>mpSolver<span class="p">,</span> mpStimulus<span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">new</span> CellLuoRudy1991FromCellML<span class="p">(</span>mpSolver<span class="p">,</span> mpZeroStimulus<span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">TestAnotherCardiacElectroMechanicsTutorial</span> <span class="o">:</span> <span class="k">public</span> CxxTest<span class="o">::</span>TestSuite
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> TestWithMef<span class="p">()</span>
    <span class="p">{</span>
        ZeroStimulusCellFactory<span class="o">&lt;</span>CML_noble_varghese_kohl_noble_1998_basic_with_sac<span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> cell_factory<span class="p">;</span>

        TetrahedralMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> electrics_mesh<span class="p">;</span>
        electrics_mesh<span class="p">.</span>ConstructRegularSlabMesh<span class="p">(</span><span class="mf">0.01</span><span class="cm">/*stepsize*/</span><span class="p">,</span> <span class="mf">0.1</span><span class="cm">/*length*/</span><span class="p">,</span> <span class="mf">0.1</span><span class="cm">/*width*/</span><span class="p">,</span> <span class="mf">0.1</span><span class="cm">/*depth*/</span><span class="p">);</span>

        QuadraticMesh<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> mechanics_mesh<span class="p">;</span>
        mechanics_mesh<span class="p">.</span>ConstructRegularSlabMesh<span class="p">(</span><span class="mf">0.02</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span> <span class="cm">/*as above with a different stepsize*/</span><span class="p">);</span>

        std<span class="o">::</span>vector<span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> fixed_nodes<span class="p">;</span>
        std<span class="o">::</span>vector<span class="o">&lt;</span>c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> <span class="o">&gt;</span> fixed_node_locations<span class="p">;</span>

        fixed_nodes<span class="p">.</span>push_back<span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        fixed_node_locations<span class="p">.</span>push_back<span class="p">(</span>zero_vector<span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> i<span class="o">=</span><span class="mi">1</span><span class="p">;</span> i<span class="o">&lt;</span>mechanics_mesh<span class="p">.</span>GetNumNodes<span class="p">();</span> i<span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">double</span> X <span class="o">=</span> mechanics_mesh<span class="p">.</span>GetNode<span class="p">(</span>i<span class="p">)</span><span class="o">-&gt;</span>rGetLocation<span class="p">()[</span><span class="mi">0</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span>fabs<span class="p">(</span>X<span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="c1">// ie, if X==0
</span>            <span class="p">{</span>
                c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> new_position<span class="p">;</span>
                new_position<span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
                new_position<span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> ElectroMechanicsProblemDefinition<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>FREE<span class="p">;</span>

                fixed_nodes<span class="p">.</span>push_back<span class="p">(</span>i<span class="p">);</span>
                fixed_node_locations<span class="p">.</span>push_back<span class="p">(</span>new_position<span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        std<span class="o">::</span>vector<span class="o">&lt;</span>BoundaryElement<span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*&gt;</span> boundary_elems<span class="p">;</span>
        std<span class="o">::</span>vector<span class="o">&lt;</span>c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> <span class="o">&gt;</span> tractions<span class="p">;</span>

        c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> traction<span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span>TetrahedralMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;::</span>BoundaryElementIterator iter <span class="o">=</span> mechanics_mesh<span class="p">.</span>GetBoundaryElementIteratorBegin<span class="p">();</span>
             iter <span class="o">!=</span> mechanics_mesh<span class="p">.</span>GetBoundaryElementIteratorEnd<span class="p">();</span>
             <span class="o">++</span>iter<span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span>fabs<span class="p">((</span><span class="o">*</span>iter<span class="p">)</span><span class="o">-&gt;</span>CalculateCentroid<span class="p">()[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="c1">// if Y=0
</span>            <span class="p">{</span>
                BoundaryElement<span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> p_element <span class="o">=</span> <span class="o">*</span>iter<span class="p">;</span>
                boundary_elems<span class="p">.</span>push_back<span class="p">(</span>p_element<span class="p">);</span>

                traction<span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span>  <span class="mf">0.0</span><span class="p">;</span> <span class="c1">// kPa, since the contraction model and material law use kPa for stiffnesses
</span>                traction<span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span>  <span class="mf">1.0</span><span class="p">;</span> <span class="c1">// kPa, since the contraction model and material law use kPa for stiffnesses
</span>                tractions<span class="p">.</span>push_back<span class="p">(</span>traction<span class="p">);</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span>fabs<span class="p">((</span><span class="o">*</span>iter<span class="p">)</span><span class="o">-&gt;</span>CalculateCentroid<span class="p">()[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="c1">// if Y=0.1
</span>            <span class="p">{</span>
                BoundaryElement<span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> p_element <span class="o">=</span> <span class="o">*</span>iter<span class="p">;</span>
                boundary_elems<span class="p">.</span>push_back<span class="p">(</span>p_element<span class="p">);</span>

                traction<span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span>  <span class="mf">0.0</span><span class="p">;</span>
                traction<span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">;</span>
                tractions<span class="p">.</span>push_back<span class="p">(</span>traction<span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        ElectroMechanicsProblemDefinition<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> problem_defn<span class="p">(</span>mechanics_mesh<span class="p">);</span>
        problem_defn<span class="p">.</span>SetContractionModel<span class="p">(</span>KERCHOFFS2003<span class="p">,</span><span class="mf">0.01</span><span class="cm">/*contraction model ODE timestep*/</span><span class="p">);</span>
        problem_defn<span class="p">.</span>SetUseDefaultCardiacMaterialLaw<span class="p">(</span>INCOMPRESSIBLE<span class="p">);</span>
        problem_defn<span class="p">.</span>SetMechanicsSolveTimestep<span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
        problem_defn<span class="p">.</span>SetFixedNodes<span class="p">(</span>fixed_nodes<span class="p">,</span> fixed_node_locations<span class="p">);</span>
        problem_defn<span class="p">.</span>SetTractionBoundaryConditions<span class="p">(</span>boundary_elems<span class="p">,</span> tractions<span class="p">);</span>

        problem_defn<span class="p">.</span>SetDeformationAffectsElectrophysiology<span class="p">(</span><span class="nb">false</span> <span class="cm">/*deformation affects conductivity*/</span><span class="p">,</span> <span class="nb">true</span> <span class="cm">/*deformation affects cell models*/</span><span class="p">);</span>

        HeartConfig<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>SetSimulationDuration<span class="p">(</span><span class="mf">50.0</span><span class="p">);</span>

        CardiacElectroMechanicsProblem<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span> problem<span class="p">(</span>INCOMPRESSIBLE<span class="p">,</span>
                                                    MONODOMAIN<span class="p">,</span>
                                                    <span class="o">&amp;</span>electrics_mesh<span class="p">,</span>
                                                    <span class="o">&amp;</span>mechanics_mesh<span class="p">,</span>
                                                    <span class="o">&amp;</span>cell_factory<span class="p">,</span>
                                                    <span class="o">&amp;</span>problem_defn<span class="p">,</span>
                                                    <span class="s">"TestCardiacElectroMechanicsWithMef"</span><span class="p">);</span>
        problem<span class="p">.</span>Solve<span class="p">();</span>

        FileFinder <span class="nf">test_output_folder</span><span class="p">(</span><span class="s">"TestCardiacElectroMechanicsWithMef/electrics"</span><span class="p">,</span> RelativeTo<span class="o">::</span>ChasteTestOutput<span class="p">);</span>
        Hdf5ToMeshalyzerConverter<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> converter<span class="p">(</span>test_output_folder<span class="p">,</span> <span class="s">"voltage"</span><span class="p">,</span>
                                                 <span class="o">&amp;</span>electrics_mesh<span class="p">,</span> <span class="nb">false</span><span class="p">,</span>
                                                 HeartConfig<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>GetVisualizerOutputPrecision<span class="p">());</span>

        Hdf5DataReader <span class="nf">reader</span><span class="p">(</span><span class="s">"TestCardiacElectroMechanicsWithMef/electrics"</span><span class="p">,</span> <span class="s">"voltage"</span><span class="p">);</span>
        <span class="kt">unsigned</span> num_timesteps <span class="o">=</span> reader<span class="p">.</span>GetUnlimitedDimensionValues<span class="p">().</span>size<span class="p">();</span>
        Vec voltage <span class="o">=</span> PetscTools<span class="o">::</span>CreateVec<span class="p">(</span>electrics_mesh<span class="p">.</span>GetNumNodes<span class="p">());</span>
        reader<span class="p">.</span>GetVariableOverNodes<span class="p">(</span>voltage<span class="p">,</span> <span class="s">"V"</span><span class="p">,</span> num_timesteps<span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        ReplicatableVector <span class="nf">voltage_repl</span><span class="p">(</span>voltage<span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> i<span class="o">=</span><span class="mi">0</span><span class="p">;</span> i<span class="o">&lt;</span>voltage_repl<span class="p">.</span>GetSize<span class="p">();</span> i<span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            TS_ASSERT_DELTA<span class="p">(</span>voltage_repl<span class="p">[</span>i<span class="p">],</span> <span class="o">-</span><span class="mf">81.9080</span><span class="p">,</span> <span class="mf">1e-3</span><span class="p">);</span>
        <span class="p">}</span>
        PetscTools<span class="o">::</span>Destroy<span class="p">(</span>voltage<span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> TestAnnulusWithInternalPressure<span class="p">()</span>
    <span class="p">{</span>
        TetrahedralMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> electrics_mesh<span class="p">;</span>
        QuadraticMesh<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> mechanics_mesh<span class="p">;</span>

        <span class="c1">// could (should?) use finer electrics mesh, but keeping electrics simulation time down
</span>        TrianglesMeshReader<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> reader1<span class="p">(</span><span class="s">"mesh/test/data/annuli/circular_annulus_960_elements"</span><span class="p">);</span>
        electrics_mesh<span class="p">.</span>ConstructFromMeshReader<span class="p">(</span>reader1<span class="p">);</span>

        TrianglesMeshReader<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> reader2<span class="p">(</span><span class="s">"mesh/test/data/annuli/circular_annulus_960_elements_quad"</span><span class="p">,</span><span class="mi">2</span> <span class="cm">/*quadratic elements*/</span><span class="p">);</span>
        mechanics_mesh<span class="p">.</span>ConstructFromMeshReader<span class="p">(</span>reader2<span class="p">);</span>

        PointStimulus2dCellFactory cell_factory<span class="p">;</span>

        std<span class="o">::</span>vector<span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> fixed_nodes<span class="p">;</span>
        std<span class="o">::</span>vector<span class="o">&lt;</span>c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> <span class="o">&gt;</span> fixed_node_locations<span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> i<span class="o">=</span><span class="mi">0</span><span class="p">;</span> i<span class="o">&lt;</span>mechanics_mesh<span class="p">.</span>GetNumNodes<span class="p">();</span> i<span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">double</span> x <span class="o">=</span> mechanics_mesh<span class="p">.</span>GetNode<span class="p">(</span>i<span class="p">)</span><span class="o">-&gt;</span>rGetLocation<span class="p">()[</span><span class="mi">0</span><span class="p">];</span>
            <span class="kt">double</span> y <span class="o">=</span> mechanics_mesh<span class="p">.</span>GetNode<span class="p">(</span>i<span class="p">)</span><span class="o">-&gt;</span>rGetLocation<span class="p">()[</span><span class="mi">1</span><span class="p">];</span>

            <span class="k">if</span> <span class="p">(</span>fabs<span class="p">(</span>x<span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-6</span> <span class="o">&amp;&amp;</span> fabs<span class="p">(</span>y<span class="o">+</span><span class="mf">0.5</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-6</span><span class="p">)</span>  <span class="c1">// fixed point (0.0,-0.5) at bottom of mesh
</span>            <span class="p">{</span>
                fixed_nodes<span class="p">.</span>push_back<span class="p">(</span>i<span class="p">);</span>
                c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> new_position<span class="p">;</span>
                new_position<span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> x<span class="p">;</span>
                new_position<span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> y<span class="p">;</span>
                fixed_node_locations<span class="p">.</span>push_back<span class="p">(</span>new_position<span class="p">);</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span>fabs<span class="p">(</span>x<span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-6</span> <span class="o">&amp;&amp;</span> fabs<span class="p">(</span>y<span class="o">-</span><span class="mf">0.5</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-6</span><span class="p">)</span>  <span class="c1">// constrained point (0.0,0.5) at top of mesh
</span>            <span class="p">{</span>
                fixed_nodes<span class="p">.</span>push_back<span class="p">(</span>i<span class="p">);</span>
                c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> new_position<span class="p">;</span>
                new_position<span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> x<span class="p">;</span>
                new_position<span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> ElectroMechanicsProblemDefinition<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>FREE<span class="p">;</span>
                fixed_node_locations<span class="p">.</span>push_back<span class="p">(</span>new_position<span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        HeartConfig<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>SetSimulationDuration<span class="p">(</span><span class="mf">30.0</span><span class="p">);</span>

        ElectroMechanicsProblemDefinition<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> problem_defn<span class="p">(</span>mechanics_mesh<span class="p">);</span>

        problem_defn<span class="p">.</span>SetContractionModel<span class="p">(</span>KERCHOFFS2003<span class="p">,</span><span class="mf">0.1</span><span class="p">);</span>
        problem_defn<span class="p">.</span>SetUseDefaultCardiacMaterialLaw<span class="p">(</span>COMPRESSIBLE<span class="p">);</span>
        <span class="c1">//problem_defn.SetZeroDisplacementNodes(fixed_nodes);
</span>        problem_defn<span class="p">.</span>SetFixedNodes<span class="p">(</span>fixed_nodes<span class="p">,</span> fixed_node_locations<span class="p">);</span>
        problem_defn<span class="p">.</span>SetMechanicsSolveTimestep<span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>

        FileFinder <span class="nf">finder</span><span class="p">(</span><span class="s">"heart/test/data/fibre_tests/circular_annulus_960_elements.ortho"</span><span class="p">,</span>RelativeTo<span class="o">::</span>ChasteSourceRoot<span class="p">);</span>
        problem_defn<span class="p">.</span>SetVariableFibreSheetDirectionsFile<span class="p">(</span>finder<span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

        problem_defn<span class="p">.</span>SetSolveUsingSnes<span class="p">();</span>

        std<span class="o">::</span>vector<span class="o">&lt;</span>BoundaryElement<span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*&gt;</span> boundary_elems<span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span>TetrahedralMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;::</span>BoundaryElementIterator iter
               <span class="o">=</span> mechanics_mesh<span class="p">.</span>GetBoundaryElementIteratorBegin<span class="p">();</span>
             iter <span class="o">!=</span> mechanics_mesh<span class="p">.</span>GetBoundaryElementIteratorEnd<span class="p">();</span>
             <span class="o">++</span>iter<span class="p">)</span>
        <span class="p">{</span>
            ChastePoint<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> centroid <span class="o">=</span> <span class="p">(</span><span class="o">*</span>iter<span class="p">)</span><span class="o">-&gt;</span>CalculateCentroid<span class="p">();</span>
            <span class="kt">double</span> r <span class="o">=</span> sqrt<span class="p">(</span> centroid<span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span>centroid<span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> centroid<span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span>centroid<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span>r <span class="o">&lt;</span> <span class="mf">0.4</span><span class="p">)</span>
            <span class="p">{</span>
                BoundaryElement<span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> p_element <span class="o">=</span> <span class="o">*</span>iter<span class="p">;</span>
                boundary_elems<span class="p">.</span>push_back<span class="p">(</span>p_element<span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        problem_defn<span class="p">.</span>SetApplyNormalPressureOnDeformedSurface<span class="p">(</span>boundary_elems<span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span> <span class="cm">/*1 KPa is about 8mmHg*/</span><span class="p">);</span>
        problem_defn<span class="p">.</span>SetNumIncrementsForInitialDeformation<span class="p">(</span><span class="mi">3</span><span class="p">);</span>

        CardiacElectroMechanicsProblem<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span> problem<span class="p">(</span>COMPRESSIBLE<span class="p">,</span>
                                                    MONODOMAIN<span class="p">,</span>
                                                    <span class="o">&amp;</span>electrics_mesh<span class="p">,</span>
                                                    <span class="o">&amp;</span>mechanics_mesh<span class="p">,</span>
                                                    <span class="o">&amp;</span>cell_factory<span class="p">,</span>
                                                    <span class="o">&amp;</span>problem_defn<span class="p">,</span>
                                                    <span class="s">"TestAnnulusWithInternalPressure"</span><span class="p">);</span>

        problem<span class="p">.</span>SetOutputDeformationGradientsAndStress<span class="p">(</span><span class="mf">10.0</span> <span class="cm">/*how often (in ms) to write - should be a multiple of mechanics timestep*/</span><span class="p">);</span>

        problem<span class="p">.</span>Solve<span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

</pre></div></div>
          

    </div>
  </body>
</html>
