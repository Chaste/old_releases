<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>UserTutorials/RunningCryptSimulationsWithMutations - Chaste</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="/trac-static/css/trac.css" type="text/css" />
    <link rel="stylesheet" href="/trac-static/css/wiki.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="/trac-static/css/site.css" />
  </head>
  <body>
    <div id="banner">
      <div id="header">
        <p>
          <a id="logo" href="http://www.cs.ox.ac.uk/chaste"><img src="/logos/chaste-266x60.jpg" alt="Chaste logo" height="60" width="266" /></a>
          <em>Documentation for <a href="/chaste/tutorials/release_2021.1/">Release 2021.1</a>.</em>
        </p>
      </div>
    </div>
    <p>&nbsp;</p>
    <div id="content" class="wiki">
      <div class="wikipage searchable">
        
          <div id="wikipage" class="trac-content"><p>
This tutorial is automatically generated from the file crypt/test/tutorial/TestRunningCryptSimulationsWithMutationsTutorial.hpp at revision <a class="changeset" href="/trac/changeset/5e8c8d7218a9/git_repo" title="Copyright mayhem!">5e8c8d7218a9/git_repo</a>.
Note that the code is given in full at the bottom of the page.
</p>
<h1 id="Examplesshowinghowtoruncryptsimulationswithvariousmutations">Examples showing how to run crypt simulations with various mutations</h1>
<h2 id="Introduction">Introduction</h2>
<p>
This tutorial assumes you have already read <a class="wiki" href="/chaste/tutorials/release_2021.1/UserTutorials/RunningMeshBasedCryptSimulations.html">UserTutorials/RunningMeshBasedCryptSimulations</a>.
</p>
<p>
In this tutorial we show how Chaste can be used to simulate a cylindrical model of an
intestinal crypt with mutations using both mesh and vertex-based simulations.
Full details of the computational model can be found in the paper by
Osborne <em>et al.</em> (2010) [10.1098/rsta.2010.0173].
</p>
<p>
As in previous cell-based Chaste tutorials, we begin by including the necessary header files.
</p>
<div class="code"><pre><span class="cp">#include &lt;cxxtest/TestSuite.h&gt;
#include "CheckpointArchiveTypes.hpp"
#include "SmartPointers.hpp"
#include "AbstractCellBasedTestSuite.hpp"
</span>
</pre></div><p>
The next header file defines a helper class for generating cells for crypt simulations.
</p>
<div class="code"><pre><span class="cp">#include "CryptCellsGenerator.hpp"
</span></pre></div><p>
The next header file defines a <tt>WntCellCycleModel</tt>, where the proliferative behaviour of a cell is
dependent on the concentration of Wnt at that point in space. Cells proliferate where there is a plentiful level of Wnt
and cease proliferation below a given threshold.
</p>
<div class="code"><pre><span class="cp">#include "SimpleWntCellCycleModel.hpp"
</span></pre></div><p>
The next header file defines a helper class for generating a suitable triangular mesh
for the crypt simulation, such that the cell corresponding to each node is initially
in mechanical equilibrium with its neighours and periodic boundary conditions are applied
at the left- and right-hand sides of the mesh (hence the "cylindrical").
</p>
<div class="code"><pre><span class="cp">#include "CylindricalHoneycombMeshGenerator.hpp"
</span></pre></div><p>
The next header file defines a <tt>CellPopulation</tt> class that uses a triangular mesh, and allows
for the inclusion of 'ghost nodes'. These are nodes in the mesh that do not correspond
to cells; instead they help ensure that a sensible Delaunay triangulation is generated
at each timestep. This is because the triangulation algorithm requires a convex hull.
</p>
<div class="code"><pre><span class="cp">#include "MeshBasedCellPopulationWithGhostNodes.hpp"
</span></pre></div><p>
The next header file defines a force law, based on a linear spring, for describing
the mechanical interactions between neighbouring cells in the crypt.
</p>
<div class="code"><pre><span class="cp">#include "GeneralisedLinearSpringForce.hpp"
</span></pre></div><p>
The next header file defines the class that simulates the evolution of a <tt>CellPopulation</tt>,
specialized to deal with the cylindrical crypt geometry.
</p>
<div class="code"><pre><span class="cp">#include "CryptSimulation2d.hpp"
</span></pre></div><p>
The next header file defines a Wnt singleton class, which (if used) deals with the
imposed Wnt gradient in our crypt model. This affects cell proliferation in the case
where we construct each cell with a <tt>WntCellCycleModel</tt>.
</p>
<div class="code"><pre><span class="cp">#include "WntConcentration.hpp"
</span></pre></div><p>
The next header file defines a cell killer class, which implements sloughing of cells
into the lumen once they reach the top of the crypt.
</p>
<div class="code"><pre><span class="cp">#include "SloughingCellKiller.hpp"
</span></pre></div><p>
These headers are used for defining and recording mutations.
</p>
<div class="code"><pre><span class="cp">#include "ApcTwoHitCellMutationState.hpp"
#include "CellMutationStatesCountWriter.hpp"
</span></pre></div><p>
The final header ensures that this test is only ever run sequentially, not in parallel.
</p>
<div class="code"><pre><span class="cp">#include "FakePetscSetup.hpp"
</span>
</pre></div><p>
Next, we define the test class, which inherits from <tt>AbstractCellBasedTestSuite</tt>
and defines some test methods.
</p>
<div class="code"><pre><span class="k">class</span> <span class="nc">TestRunningCryptSimulationsWithMutationsTutorial</span> <span class="o">:</span> <span class="k">public</span> AbstractCellBasedTestSuite
<span class="p">{</span>
<span class="nl">public:</span>
</pre></div><h2 id="Test1:amesh-basedcryptsimulationwithmutations">Test 1: a mesh-based crypt simulation with mutations</h2>
<p>
In the first test, we demonstrate how to introduce mutations into a simulation of a crypt.
</p>
<div class="code"><pre>    <span class="kt">void</span> <span class="nf">TestMeshBasedCryptWithMutations</span><span class="p">()</span>
    <span class="p">{</span>
</pre></div><p>
Note that time is re-initialized to zero and the random number generator is re-seeded to zero in the <tt>AbstractCellBasedTestSuite</tt>.
</p>
<p>
We first create a cylindrical mesh, and get the cell location indices, exactly as before.
</p>
<div class="code"><pre>        CylindricalHoneycombMeshGenerator <span class="nf">generator</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
        Cylindrical2dMesh<span class="o">*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetCylindricalMesh<span class="p">();</span>

        std<span class="o">::</span>vector<span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> location_indices <span class="o">=</span> generator<span class="p">.</span>GetCellLocationIndices<span class="p">();</span>

</pre></div><p>
We create the cells, using the same method as before. Here, though, we use a <tt>SimpleWntCellCycleModel</tt>.
</p>
<div class="code"><pre>        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        CryptCellsGenerator<span class="o">&lt;</span>SimpleWntCellCycleModel<span class="o">&gt;</span> cells_generator<span class="p">;</span>
        cells_generator<span class="p">.</span>Generate<span class="p">(</span>cells<span class="p">,</span> p_mesh<span class="p">,</span> location_indices<span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

</pre></div><p>
We now create boost shared pointers to any mutations we wish to use.
We need to do this using the <tt>CellPropertyRegistry</tt>, otherwise
the numbers of each type of mutation aren't correctly tracked. For
a list of possible mutations, see subclasses of <tt>AbstractCellMutationState</tt>.
These can be found in the inheritance diagram, here,
<a class="ext-link" href="https://chaste.cs.ox.ac.uk/chaste/docs/release_2021.1/classAbstractCellMutationState.html" title="Documentation for the AbstractCellMutationState class"><span class="icon">â€‹</span>AbstractCellMutationState</a>.
Each mutation has a different effect on the cell cycle models; see the class
documentation for details.
</p>
<div class="code"><pre>        boost<span class="o">::</span>shared_ptr<span class="o">&lt;</span>AbstractCellProperty<span class="o">&gt;</span> p_state<span class="p">(</span>CellPropertyRegistry<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>Get<span class="o">&lt;</span>ApcTwoHitCellMutationState<span class="o">&gt;</span><span class="p">());</span>

</pre></div><p>
We create the cell population, as before.
</p>
<div class="code"><pre>        MeshBasedCellPopulationWithGhostNodes<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">,</span> location_indices<span class="p">);</span>

</pre></div><p>
In order to visualize mutant cells and to count how many cells there are of each type we need to use the following command.
</p>
<div class="code"><pre>        cell_population<span class="p">.</span>AddCellPopulationCountWriter<span class="o">&lt;</span>CellMutationStatesCountWriter<span class="o">&gt;</span><span class="p">();</span>

</pre></div><p>
We set the height of the crypt. As well as passing this variable into the <tt>SloughingCellKiller</tt>,
we will pass it to the <tt>WntConcentration</tt> object (see below).
</p>
<div class="code"><pre>        <span class="kt">double</span> crypt_height <span class="o">=</span> <span class="mf">8.0</span><span class="p">;</span>

</pre></div><p>
When using a <tt>SimpleWntCellCycleModel</tt>, we need a way of telling each cell what the Wnt concentration
is at its location. To do this, we set up a <tt>WntConcentration</tt> object. Like <tt>SimulationTime</tt>,
<tt>WntConcentration</tt> is a singleton class, so when instantiated it is accessible from anywhere in
the code (and in particular, all cells and cell-cycle models can access it). We need to say what
the profile of the Wnt concentation should be up the crypt: here, we say it is <tt>LINEAR</tt> (linear
decreasing from 1 to 0 from the bottom of the crypt to the top). We also need to inform the
<tt>WntConcentration</tt> of the cell population and the height of the crypt.
</p>
<div class="code"><pre>        WntConcentration<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>SetType<span class="p">(</span>LINEAR<span class="p">);</span>
        WntConcentration<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>SetCellPopulation<span class="p">(</span>cell_population<span class="p">);</span>
        WntConcentration<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>SetCryptLength<span class="p">(</span>crypt_height<span class="p">);</span>

</pre></div><p>
Create a simulator as before (except setting a different output directory).
</p>
<div class="code"><pre>        CryptSimulation2d <span class="nf">simulator</span><span class="p">(</span>cell_population<span class="p">);</span>
        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"MeshBasedCryptWithMutations"</span><span class="p">);</span>
        simulator<span class="p">.</span>SetSamplingTimestepMultiple<span class="p">(</span><span class="mi">12</span><span class="p">);</span>
        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mi">10</span><span class="p">);</span>

</pre></div><p>
As before, we create a force law and cell killer and pass these objects to the simulator, then call
Solve().
</p>
<div class="code"><pre>        MAKE_PTR<span class="p">(</span>GeneralisedLinearSpringForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_linear_force<span class="p">);</span>
        simulator<span class="p">.</span>AddForce<span class="p">(</span>p_linear_force<span class="p">);</span>
        MAKE_PTR_ARGS<span class="p">(</span>SloughingCellKiller<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_killer<span class="p">,</span> <span class="p">(</span><span class="o">&amp;</span>cell_population<span class="p">,</span> crypt_height<span class="p">));</span>
        simulator<span class="p">.</span>AddCellKiller<span class="p">(</span>p_killer<span class="p">);</span>

        simulator<span class="p">.</span>Solve<span class="p">();</span>

</pre></div><p>
Now we have run the simulation to a steady state (where the initial regular configuration is lost) we select a cell to become mutant.
We select one of the cells and set the mutation state to <tt>ApcTwoHitCellMutationState</tt> (i.e. p_state).
</p>
<div class="code"><pre>        <span class="k">for</span> <span class="p">(</span>AbstractCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>Iterator cell_iter <span class="o">=</span> cell_population<span class="p">.</span>Begin<span class="p">();</span>
             cell_iter <span class="o">!=</span> cell_population<span class="p">.</span>End<span class="p">();</span>
             <span class="o">++</span>cell_iter<span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">unsigned</span> node_index <span class="o">=</span> cell_population<span class="p">.</span>GetLocationIndexUsingCell<span class="p">(</span><span class="o">*</span>cell_iter<span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span>node_index <span class="o">==</span> <span class="mi">74</span><span class="p">)</span> <span class="c1">// Chosen from looking at the results from steady state
</span>            <span class="p">{</span>
                cell_iter<span class="o">-&gt;</span>SetMutationState<span class="p">(</span>p_state<span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

</pre></div><p>
We also change the value of the damping constant for mutant cells to be
ten times the normal value.
</p>
<div class="code"><pre>       <span class="kt">double</span> normal_damping_constant <span class="o">=</span> cell_population<span class="p">.</span>GetDampingConstantNormal<span class="p">();</span>
       cell_population<span class="p">.</span>SetDampingConstantMutant<span class="p">(</span><span class="mi">10</span><span class="o">*</span>normal_damping_constant<span class="p">);</span>

</pre></div><p>
Next we reset the end time to some later time.
</p>
<div class="code"><pre>       simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mi">20</span><span class="p">);</span>

</pre></div><p>
Run the simulation to the new end time.
</p>
<div class="code"><pre>       simulator<span class="p">.</span>Solve<span class="p">();</span>

</pre></div><p>
Finally, we must tidy up by destroying the <tt>WntConcentration</tt>
singleton object. This avoids memory leaks occurring.
</p>
<div class="code"><pre>       WntConcentration<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>Destroy<span class="p">();</span>
    <span class="p">}</span>
</pre></div><p>
To visualize the results, open a new terminal, <tt>cd</tt> to the Chaste directory,
then <tt>cd</tt> to <tt>anim</tt>. Then do: <tt>java Visualize2dCentreCells /tmp/$USER/testoutput/MeshBasedCryptWithMutations/results_from_time_0</tt>.
</p>
<p>
These are the results before we add the mutations do: <tt>java Visualize2dCentreCells /tmp/$USER/testoutput/MeshBasedCryptWithMutations/results_from_time_10</tt>
to see the results from after the mutation has been added.
</p>
<p>
We may have to do: <tt>javac Visualize2dCentreCells.java</tt> beforehand to create the
java executable.
</p>
<p>
In the results folder there is also a file <tt>cellmutationstates.dat</tt> which tracks the numbers of each mutation type in the simulation.
These results are just tab separated columns so may be visualized by using gnuplot, Matlab or similar.
</p>
<div class="code"><pre><span class="p">};</span>

</pre></div><h1 id="Code">Code</h1>
<p>
The full code is given below
</p>
<h2 id="FilenameTestRunningCryptSimulationsWithMutationsTutorial.hpp">File name <tt>TestRunningCryptSimulationsWithMutationsTutorial.hpp</tt></h2>
<div class="code"><pre><span class="cp">#include &lt;cxxtest/TestSuite.h&gt;
#include "CheckpointArchiveTypes.hpp"
#include "SmartPointers.hpp"
#include "AbstractCellBasedTestSuite.hpp"
</span>
<span class="cp">#include "CryptCellsGenerator.hpp"
#include "SimpleWntCellCycleModel.hpp"
#include "CylindricalHoneycombMeshGenerator.hpp"
#include "MeshBasedCellPopulationWithGhostNodes.hpp"
#include "GeneralisedLinearSpringForce.hpp"
#include "CryptSimulation2d.hpp"
#include "WntConcentration.hpp"
#include "SloughingCellKiller.hpp"
#include "ApcTwoHitCellMutationState.hpp"
#include "CellMutationStatesCountWriter.hpp"
#include "FakePetscSetup.hpp"
</span>
<span class="k">class</span> <span class="nc">TestRunningCryptSimulationsWithMutationsTutorial</span> <span class="o">:</span> <span class="k">public</span> AbstractCellBasedTestSuite
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> TestMeshBasedCryptWithMutations<span class="p">()</span>
    <span class="p">{</span>
        CylindricalHoneycombMeshGenerator generator<span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
        Cylindrical2dMesh<span class="o">*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetCylindricalMesh<span class="p">();</span>

        std<span class="o">::</span>vector<span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> location_indices <span class="o">=</span> generator<span class="p">.</span>GetCellLocationIndices<span class="p">();</span>

        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        CryptCellsGenerator<span class="o">&lt;</span>SimpleWntCellCycleModel<span class="o">&gt;</span> cells_generator<span class="p">;</span>
        cells_generator<span class="p">.</span>Generate<span class="p">(</span>cells<span class="p">,</span> p_mesh<span class="p">,</span> location_indices<span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

        boost<span class="o">::</span>shared_ptr<span class="o">&lt;</span>AbstractCellProperty<span class="o">&gt;</span> p_state<span class="p">(</span>CellPropertyRegistry<span class="o">::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>Get<span class="o">&lt;</span>ApcTwoHitCellMutationState<span class="o">&gt;</span><span class="p">());</span>

        MeshBasedCellPopulationWithGhostNodes<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">,</span> location_indices<span class="p">);</span>

        cell_population<span class="p">.</span>AddCellPopulationCountWriter<span class="o">&lt;</span>CellMutationStatesCountWriter<span class="o">&gt;</span><span class="p">();</span>

        <span class="kt">double</span> crypt_height <span class="o">=</span> <span class="mf">8.0</span><span class="p">;</span>

        WntConcentration<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>SetType<span class="p">(</span>LINEAR<span class="p">);</span>
        WntConcentration<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>SetCellPopulation<span class="p">(</span>cell_population<span class="p">);</span>
        WntConcentration<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>Instance<span class="p">()</span><span class="o">-&gt;</span>SetCryptLength<span class="p">(</span>crypt_height<span class="p">);</span>

        CryptSimulation2d <span class="nf">simulator</span><span class="p">(</span>cell_population<span class="p">);</span>
        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"MeshBasedCryptWithMutations"</span><span class="p">);</span>
        simulator<span class="p">.</span>SetSamplingTimestepMultiple<span class="p">(</span><span class="mi">12</span><span class="p">);</span>
        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mi">10</span><span class="p">);</span>

        MAKE_PTR<span class="p">(</span>GeneralisedLinearSpringForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_linear_force<span class="p">);</span>
        simulator<span class="p">.</span>AddForce<span class="p">(</span>p_linear_force<span class="p">);</span>
        MAKE_PTR_ARGS<span class="p">(</span>SloughingCellKiller<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_killer<span class="p">,</span> <span class="p">(</span><span class="o">&amp;</span>cell_population<span class="p">,</span> crypt_height<span class="p">));</span>
        simulator<span class="p">.</span>AddCellKiller<span class="p">(</span>p_killer<span class="p">);</span>

        simulator<span class="p">.</span>Solve<span class="p">();</span>

        <span class="k">for</span> <span class="p">(</span>AbstractCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>Iterator cell_iter <span class="o">=</span> cell_population<span class="p">.</span>Begin<span class="p">();</span>
             cell_iter <span class="o">!=</span> cell_population<span class="p">.</span>End<span class="p">();</span>
             <span class="o">++</span>cell_iter<span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">unsigned</span> node_index <span class="o">=</span> cell_population<span class="p">.</span>GetLocationIndexUsingCell<span class="p">(</span><span class="o">*</span>cell_iter<span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span>node_index <span class="o">==</span> <span class="mi">74</span><span class="p">)</span> <span class="c1">// Chosen from looking at the results from steady state
</span>            <span class="p">{</span>
                cell_iter<span class="o">-&gt;</span>SetMutationState<span class="p">(</span>p_state<span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

       <span class="kt">double</span> normal_damping_constant <span class="o">=</span> cell_population<span class="p">.</span>GetDampingConstantNormal<span class="p">();</span>
       cell_population<span class="p">.</span>SetDampingConstantMutant<span class="p">(</span><span class="mi">10</span><span class="o">*</span>normal_damping_constant<span class="p">);</span>

       simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mi">20</span><span class="p">);</span>

       simulator<span class="p">.</span>Solve<span class="p">();</span>

       WntConcentration<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>Destroy<span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

</pre></div></div>
          

    </div>
  </body>
</html>
