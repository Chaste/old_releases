<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>ChasteGuides/BoostSerialization - Chaste</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="https://chaste.github.io/old_releases/trac.css" type="text/css" />
    <link rel="stylesheet" href="https://chaste.github.io/old_releases/wiki.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="https://chaste.github.io/old_releases/site.css" />
  </head>
  <body>
    <div id="banner">
      <div id="header">
        <p>
          <a id="logo" href="https://chaste.github.io/"><img src="https://chaste.github.io/chaste_0256.png" alt="Chaste logo" height="60" /></a>
          <em>Documentation for <a href="https://chaste.github.io/old_releases/release_3.3/">Release 3.3</a>.</em>
        </p>
      </div>
    </div>
    <p>&nbsp;</p>
    <div id="content" class="wiki">
      <div class="wikipage searchable">
        
          <div id="wikipage" class="trac-content"><h1 id="ImplementingcheckpointingforclasseswithBoostSerialization">Implementing checkpointing for classes with Boost Serialization</h1>
<p>
In order to checkpoint and save/resume simulations, we use the <a class="ext-link" href="http://www.boost.org/libs/serialization/doc/index.html"><span class="icon">​</span>Serialization</a> library from <a class="ext-link" href="http://www.boost.org/"><span class="icon">​</span>Boost</a>.  This page contains some notes on how to use this functionality well in Chaste.  Full documentation can be found at <a class="ext-link" href="http://www.boost.org/libs/serialization/doc/index.html"><span class="icon">​</span>http://www.boost.org/libs/serialization/doc/index.html</a>
</p>
<p>
</p><div class="wiki-toc">
<ol>
  <li>
    <a href="#ImplementingcheckpointingforclasseswithBoostSerialization">Implementing checkpointing for classes with Boost Serialization</a>
    <ol>
      <li>
        <a href="#Headerfiles">Header files</a>
      </li>
      <li>
        <a href="#Classhierarchies">Class hierarchies</a>
        <ol>
          <li>
            <a href="#Abstractclasses">Abstract classes</a>
          </li>
          <li>
            <a href="#Derivedclasses">Derived classes</a>
          </li>
        </ol>
      </li>
      <li>
        <a href="#Avoidingtheneedforspecialconstructors">Avoiding the need for special constructors</a>
      </li>
      <li>
        <a href="#Singletonclasses">Singleton classes</a>
      </li>
      <li>
        <a href="#LoadingarchivescreatedbyolderChasteversions">Loading archives created by older Chaste versions</a>
      </li>
      <li>
        <a href="#Testingthearchiving">Testing the archiving</a>
      </li>
      <li>
        <a href="#Parallelarchiving">Parallel archiving</a>
        <ol>
          <li>
            <a href="#Cardiacsimulations">Cardiac simulations</a>
          </li>
        </ol>
      </li>
      <li>
        <a href="#Othernotes">Other notes</a>
        <ol>
          <li>
            <a href="#Usingbinaryarchives">Using binary archives</a>
          </li>
          <li>
            <a href="#Compressingthearchive">Compressing the archive</a>
          </li>
        </ol>
      </li>
    </ol>
  </li>
</ol>
</div><p>
</p>
<h2 id="Headerfiles">Header files</h2>
<p>
One important point to note is that <strong>only</strong> code which needs to <strong>create</strong> archive objects should include the <tt>*archive.hpp</tt> headers.  This allows the serialization code in our classes to be (largely) independent of the type of archive being written to/read from.
</p>
<p>
All header files of the form <tt>&lt;boost/archive/*archive.hpp&gt;</tt> are <strong>required</strong> to precede the header file <tt>&lt;boost/serialization/export.hpp&gt;</tt>.  It is good practice therefore for tests of archiving to include:
</p>
<div class="code"><pre><span class="cp">#include "CheckpointArchiveTypes.hpp"
</span></pre></div><p>
first, then include Chaste classes.  See <a class="wiki" href="https://chaste.github.io/old_releases/release_3.3/ChasteGuides/BoostSerialization.html#Derivedclasses">below</a> for details on how to use the export header.
</p>
<p>
The main header file that classes with serialization methods will need is
</p>
<div class="code"><pre><span class="cp">#include "ChasteSerialization.hpp"
</span></pre></div><p>
Other headers are also needed for dealing with <a class="wiki" href="https://chaste.github.io/old_releases/release_3.3/ChasteGuides/BoostSerialization.html#Classhierarchies">abstract and derived classes; see below</a>.
</p>
<p>
For serializing vectors, add <tt>#include &lt;boost/serialization/vector.hpp&gt;</tt>.  Similar headers exist for other STL collections.
</p>
<p>
There are cases where Chaste code needs to create archives, for example to provide <tt>Save</tt> and <tt>Load</tt> functionality for tissue simulations, or heart simulation checkpointing.  The easiest way to handle this is to create a separate helper class (in its own source files) which does this.  For examples see <a class="missing source">source:trunk/cell_based/src/simulation/CellBasedSimulationArchiver.hpp</a> and <a class="missing source">source:trunk/heart/src/problem/CardiacSimulationArchive.hpp</a>.  This source file then needs to be included before any other Chaste headers (that might include serialization headers).
</p>
<p>
Trying to have save and load functionality in different places will almost certainly lead to problems such as:
</p>
<pre class="wiki">heart/build/debug/src/problem/AbstractCardiacProblem.o:
    multiple definition of `boost::archive::detail::guid_initializer&lt;SimpleStimulus&gt;::instance'
heart/build/debug/bidomain/TestBidomainArchiveKSPRunner.o:
    first defined here
</pre><p>
The cause of this is multiple definitions of the unique IDs needed to properly serialize derived classes through a pointer (see below).  If multiple .cpp files include both an archive header (<tt>&lt;boost/archive/*archive.hpp&gt;</tt>) and  <tt>&lt;boost/serialization/export.hpp&gt;</tt>, either directly or indirectly, then each corresponding object file (or library) will define the same unique ID, hence the error.
It is OK to have archive headers in multiple files, provided that the export header follows in at most one case of files being linked together.
</p>
<h2 id="Classhierarchies">Class hierarchies</h2>
<p>
Some extra work is needed to deal properly with serializing objects from a class hierarchy.
</p>
<h3 id="Abstractclasses">Abstract classes</h3>
<p>
While many compilers can automatically detect abstract classes, some do not, and so need them to be indicated explicitly.  Since the interface for doing this changed in Boost 1.36, we have written a wrapper interface in <a class="missing source">source:trunk/global/src/checkpointing/ClassIsAbstract.hpp</a>.  When writing an abstract base class (i.e. one with pure virtual methods), include this header (<tt>#include "ClassIsAbstract.hpp"</tt>) and use the macro
</p>
<div class="code"><pre>CLASS_IS_ABSTRACT<span class="p">(</span>class_name<span class="p">)</span>
</pre></div><p>
after the class definition, to indicate to the serialization library that it should not try to instantiate the class, thus avoiding compiler errors on some systems.
</p>
<p>
Note that this macro should <strong><em>only</em></strong> be used for classes with <strong><em>pure virtual</em></strong> methods.  If they only have virtual methods with implementations, then the class can actually be instantiated, and the macro should not be used.  Including the macro unnecessarily can lead to segfaults!
</p>
<p>
If the abstract class is templated, the above macro will not work.  There are convenience macros for common scenarios, or you may have to expand the underlying definition manually.  See <a class="missing source">source:trunk/global/src/checkpointing/ClassIsAbstract.hpp</a> for details.
</p>
<h3 id="Derivedclasses">Derived classes</h3>
<p>
Derived classes must make sure to serialize their base parts, by including <tt>&lt;boost/serialization/base_object.hpp&gt;</tt> and using
</p>
<div class="code"><pre>archive <span class="o">&amp;</span> boost<span class="o">::</span>serialization<span class="o">::</span>base_object<span class="o">&lt;</span>base_class_name<span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
</pre></div><p>
as the first instruction in their <tt>serialize</tt> method.  See <a class="ext-link" href="http://www.boost.org/libs/serialization/doc/serialization.html#base"><span class="icon">​</span>Boost docs</a>.
</p>
<p>
If serializing a derived class through a base class pointer or reference, the library will need some help to know which class to instantiate when loading from the archive.  This is done by defining a globally unique identifier for the class using the <tt>BOOST_CLASS_EXPORT</tt> macro from <tt>&lt;boost/serialization/export.hpp&gt;</tt>.  Due to changes in this macro between Boost versions, we provide wrapper macros in <a class="missing source">source:trunk/global/src/checkpointing/SerializationExportWrapper.hpp</a> and <a class="missing source">source:trunk/global/src/checkpointing/SerializationExportWrapperForCpp.hpp</a>.
</p>
<p>
Chaste header files that declare derived classes should include something like the following <em>after</em> the class block in the .hpp file:
</p>
<div class="code"><pre><span class="cp">#include "SerializationExportWrapper.hpp"
</span>CHASTE_CLASS_EXPORT<span class="p">(</span>class_name<span class="p">)</span>
</pre></div><p>
The corresponding .cpp file must include something like the following after any other includes (I suggest putting it at the end of the file for consistency):
</p>
<div class="code"><pre><span class="cp">#include "SerializationExportWrapperForCpp.hpp"
</span>CHASTE_CLASS_EXPORT<span class="p">(</span>class_name<span class="p">)</span>
</pre></div><p>
Note that the name given to <tt>CHASTE_CLASS_EXPORT</tt> <strong>must</strong> match that used in the .hpp file.
</p>
<p>
<strong>Note that this macro is not needed for <em>abstract</em> base classes</strong>, only the derived classes, since no instances of the base itself will be serialized.  See <a class="ext-link" href="http://www.boost.org/libs/serialization/doc/special.html#export"><span class="icon">​</span>here</a> and <a class="ext-link" href="http://www.boost.org/libs/serialization/doc/serialization.html#derivedpointers"><span class="icon">​</span>here</a> for further information.
</p>
<p>
With templated classes, this simple invocation doesn't work.  A fully general export macro approach <a class="ext-link" href="http://lists.boost.org/boost-users/2005/05/11731.php"><span class="icon">​</span>seems impossible</a>.
The header <a class="missing source">source:trunk/global/src/checkpointing/SerializationExportWrapper.hpp</a> provides macros for where a derived class is templated over dimension (either a single dimension, or both element and space dimension, or including PROBLEM_DIM).  See <a class="missing changeset" title="No permission to view changeset 2266 on (default)">r2266</a>, <a class="missing changeset" title="No permission to view changeset 6952 on (default)">r6952</a>, <a class="missing source">source:trunk/models/src/crypt/killers/RandomCellKiller.hpp@2266#L74</a> and <a class="missing source">source:trunk/mesh/src/common/TetrahedralMesh.hpp@6952#L467</a> for examples of its use.
</p>
<h2 id="Avoidingtheneedforspecialconstructors">Avoiding the need for special constructors</h2>
<p>
It is undesirable to have to write a special constructor for classes just for the use of the archiving code.  There are two ways around this.
</p>
<p>
One is to write separate functions <tt>save_construct_data</tt> and <tt>load_construct_data</tt> for the class.  These save/load the parameters needed for an existing constructor.  See also <a class="ext-link" href="http://www.boost.org/libs/serialization/doc/serialization.html#constructors"><span class="icon">​</span>the official documentation</a>, and <a class="missing source">source:trunk/cell_based/src/tissue/cell/TissueCell.hpp@7488#L305</a> for an example.
</p>
<p>
Note that the example in the documentation seems to suggest that you can directly access private member data from a <tt>save_construct_data</tt> function.  This is incorrect.  You'll either need public accessor methods for the data you require, or a public helper method to save the data to the archive.
</p>
<p>
The other method is to create a <em>private default constructor</em> which does nothing, as is done in <a class="missing source">source:trunk/heart/src/problem/Electrodes.hpp</a>.  All the work can then be done by the <tt>serialize</tt> method.
</p>
<h2 id="Singletonclasses">Singleton classes</h2>
<p>
In order for singleton classes to remain singletons, they must be serialized properly.  The <a class="missing source">SerializableSingleton</a> class makes doing so easier, without requiring any special handling for the first serialization of a singleton.  Any singleton class which needs to be serialized should inherit from this base, which provides both part of the "singleton-ness" (by inheriting from boost::noncopyable), and also a method <tt>GetSerializationWrapper()</tt>.  Users of the singleton which wish to serialize it should not do so directly.  Instead, they should call <tt>GetSerializationWrapper</tt> and serialize the returned pointer.  Doing so will ensure that only a single global instance of the singleton is maintained when loading from an archive.  For more information see the <a href="https://chaste.cs.ox.ac.uk/chaste/docs/release_3.3/classSerializableSingleton.html">class doxygen</a>.
</p>
<p>
It is also advisable for singleton classes to <tt>assert(mpInstance==NULL)</tt> in their constructor, in order to trap cases where serialization has not been performed correctly.
</p>
<h2 id="LoadingarchivescreatedbyolderChasteversions">Loading archives created by older Chaste versions</h2>
<p>
As Chaste evolves, classes gain new data members, or members change, disappear, etc.  However, ideally each release of Chaste should still be able to load checkpoints created by the previous release.  In some cases this may not be possible, e.g. a new object added that doesn't have a sensible default.  However, in cases where it is possible, Boost provides the functionality to handle this, via the <tt>version</tt> parameter passed to serialization methods.
</p>
<p>
For each class in which the serialization changes, include the header <tt>ChasteSerializationVersion.hpp</tt>.  Within your serialize method, test the <tt>version</tt> parameter and act accordingly.  Finally, use the macro
</p>
<div class="code"><pre>BOOST_CLASS_VERSION<span class="p">(</span>ClassName<span class="p">,</span> VersionNumber<span class="p">)</span> 
</pre></div><p>
after your class definition to specify the current version number - increase it by 1 each time there is a change in how the class is archived (it defaults to 0 if the macro is not given).
</p>
<p>
See <a class="missing source">source:trunk/heart/src/odes/AbstractCardiacCell.hpp</a> and <a class="ext-link" href="http://www.boost.org/doc/libs/1_37_0/libs/serialization/doc/tutorial.html#versioning"><span class="icon">​</span>Boost's tutorial</a> for examples.
</p>
<p>
For templated classes, the macro will not work, and you have to expand <a class="ext-link" href="http://www.boost.org/doc/libs/1_37_0/libs/serialization/doc/traits.html#version"><span class="icon">​</span>its definition</a> yourself.  For example,
</p>
<div class="code"><pre><span class="k">namespace</span> boost <span class="p">{</span> 
<span class="k">namespace</span> serialization <span class="p">{</span>
<span class="cm">/**
 * Specify a version number for archive backwards compatibility.
 * 
 * This is how to do BOOST_CLASS_VERSION(AbstractCardiacPde, 1)
 * with a templated class.
 */</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="kt">unsigned</span> ELEMENT_DIM<span class="p">,</span> <span class="kt">unsigned</span> SPACE_DIM<span class="o">&gt;</span>
<span class="k">struct</span> version<span class="o">&lt;</span>AbstractCardiacPde<span class="o">&lt;</span>ELEMENT_DIM<span class="p">,</span> SPACE_DIM<span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="p">{</span>
    CHASTE_VERSION_CONTENT<span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace serialization
</span><span class="p">}</span> <span class="c1">// namespace boost
</span></pre></div><h2 id="Testingthearchiving">Testing the archiving</h2>
<p>
Things to note:
</p>
<ul><li>Always archive via a pointer (well, almost always).
</li><li>Always archive pretending it is the most abstract class possible (this tests that boost is registering classes properly - otherwise your EXPORT commands aren't tested).
</li><li>Write a test for each concrete class that can be archived, checking their unique methods and variables are archived properly.
</li></ul><p>
A good way to test the archiving is along the following lines:
</p>
<div class="code"><pre><span class="cp">#include "CheckpointArchiveTypes.hpp"
#include "ArchiveLocationInfo.hpp"
</span>
<span class="kt">void</span> <span class="nf">TestArchivingOfConcreteClass</span><span class="p">()</span> <span class="k">throw</span><span class="p">(</span>Exception<span class="p">)</span>
<span class="p">{</span>
    OutputFileHandler handler<span class="p">(</span><span class="s">"archive"</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="c1">// The next two lines ensure that different processes read/write different archive files when running in parallel
</span>    ArchiveLocationInfo<span class="o">::</span>SetArchiveDirectory<span class="p">(</span>handler<span class="p">.</span>FindFile<span class="p">(</span><span class="s">""</span><span class="p">));</span>
    std<span class="o">::</span>string archive_filename <span class="o">=</span> ArchiveLocationInfo<span class="o">::</span>GetProcessUniqueFilePath<span class="p">(</span><span class="s">"ConcreteClass.arch"</span><span class="p">);</span>

    <span class="c1">// Create data structures to store variables to test for equality here
</span>
    <span class="c1">// Save
</span>    <span class="p">{</span>
        AbstractClass<span class="o">*</span> <span class="k">const</span> p_abstract_class <span class="o">=</span> <span class="k">new</span> ConcreteClass<span class="p">();</span>
            
        <span class="c1">// Create an output file
</span>        std<span class="o">::</span>ofstream ofs<span class="p">(</span>archive_filename<span class="p">.</span>c_str<span class="p">());</span>
        <span class="c1">// And create a boost output archive that goes to this file
</span>        boost<span class="o">::</span>archive<span class="o">::</span>text_oarchive output_arch<span class="p">(</span>ofs<span class="p">);</span>

        <span class="c1">// Record values to test into data structures
</span>        <span class="c1">// If necessary you can use static_cast&lt;ConcreteClass*&gt;(p_abstract_class)
</span>        <span class="c1">// (if your abstract class doesn't contain the necessary variables and methods)
</span>            
        output_arch <span class="o">&lt;&lt;</span> p_abstract_class<span class="p">;</span>
        <span class="k">delete</span> p_abstract_class<span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Load
</span>    <span class="p">{</span>
        AbstractClass<span class="o">*</span> p_abstract_class_2<span class="p">;</span>

        <span class="c1">// Read from this input file
</span>        std<span class="o">::</span>ifstream ifs<span class="p">(</span>archive_filename<span class="p">.</span>c_str<span class="p">(),</span> std<span class="o">::</span>ios<span class="o">::</span>binary<span class="p">);</span>
        <span class="c1">// And choose a boost input_archive object to translate this file
</span>        boost<span class="o">::</span>archive<span class="o">::</span>text_iarchive input_arch<span class="p">(</span>ifs<span class="p">);</span>

        <span class="c1">// restore from the archive
</span>        input_arch <span class="o">&gt;&gt;</span> p_abstract_class_2<span class="p">;</span>

        <span class="c1">// Check things in the data structures with TS_ASSERTS here.
</span>        <span class="c1">// If necessary you can use static_cast&lt;ConcreteClass*&gt;(p_abstract_class_2)
</span>        <span class="c1">// (if your abstract class doesn't contain the necessary variables and methods)
</span>
        <span class="k">delete</span> p_abstract_class_2<span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div><p>
Note that all archive files in the repository should be generated using boost 1-40 to ensure compatibility with all of the possible boost versions supported by Chaste. You can generate these by logging on to e.g. <tt>chaste@userpc59</tt> and doing a build with e.g.
</p>
<pre class="wiki">scons build=GccOpt_hostconfig,boost=1-40,use-cvode=0 cell_based/test/crypt/TestGenerateSteadyStateCrypt.hpp
</pre><h2 id="Parallelarchiving">Parallel archiving</h2>
<p>
When checkpointing a parallel simulation, there are two kinds of data that need to be saved: replicated (same for every process) and distributed (different on each process).  We wish to write these to separate locations, so that the replicated data is only written to disk once, and to make it easier to re-load on a different number of processes (in which case the distributed data will need to be re-distributed).  However, the Boost Serialization library expects to be writing to just one archive.
</p>
<p>
Two classes are provided to solve this problem: <a class="missing source">ProcessSpecificArchive</a> and <a class="missing source">ArchiveOpener</a>.  The latter is for opening archives for reading or writing.  All that all a user needs to do is create an instance of this class, call <tt>GetCommonArchive</tt>, and read from/write to the returned archive.  When done, just destroy the instance (e.g. by closing the scope).
</p>
<p>
The <a class="missing source">ProcessSpecificArchive</a> class is for use by classes that need to save distributed data, and provides access to a secondary archive in which to store it. When opening an archive in a (potentially) parallel setting, using either the <a class="missing source">ArchiveOpener</a> or <a class="missing source">CardiacSimulationArchiver</a>, the <tt>Set</tt> method will be called to specify the secondary archive.  Classes which need to save distributed data can then use the <tt>Get</tt> method to access and write to/read from this archive.
</p>
<p>
Some classes (e.g. the meshes, <tt>LinearSystem</tt>, and <tt>HeartConfig</tt>) don't write their data directly to the archive file, but instead write to separate files in the same folder.  They use the <a class="missing source">ArchiveLocationInfo</a> class to find out where to write to.
</p>
<h3 id="Cardiacsimulations">Cardiac simulations</h3>
<p>
The <tt>CardiacSimulationArchiver</tt> class provides a high-level interface to checkpointing of cardiac simulations, and orchestrates the logic for re-distributing data when loading on a different number of processes.  The logic is currently quite difficult to follow, and so I am attempting to document the main points here.
</p>
<p>
In order to support SVI, and potentially other applications which require loading halo information, all process-specific archives are read by all processes when loading from a checkpoint.  The only difference between the migration case (when loading on a different number of processes from that which saved the checkpoint) and the 'normal' case is which process-specific archive is loaded first.  If the number of processes matches, each process loads its own process-specific archive while reading the common archive, so that the mesh can maintain the same partitioning.  When migrating, each process reads the process-0 archive first, since it is guaranteed to exist.  <tt>AbstractCardiacProblem::LoadExtraArchive</tt> is then called with each additional process-specific archive.
</p>
<p>
When a <tt>DistributedVectorFactory</tt> is loaded from any process-specific archive, then the <tt>DistributedVectorFactory</tt> <tt>load_construct_data</tt> will set <tt>mpOriginalFactory</tt> to contain the version in the archive (i.e. using its <tt>lo, hi, size, num_procs</tt>), and the object created will partition based on PETSc's default for a <tt>Vec</tt> with problem size <tt>mpOriginalFactory-&gt;GetProblemSize()</tt>.  <tt>CardiacSimulationArchiver</tt> also calls <tt>DistributedVectorFactory::SetCheckNumberOfProcessesOnLoad(false)</tt> to prevent <tt>load_construct_data</tt> setting the local size as <tt>hi-lo</tt>, since these will not always add up to the problem size when loading different process-specific archives.
</p>
<p>
<tt>AbstractTetrahedralMesh::load</tt> makes use of the original factory, if present, to partition the loaded mesh.  (<tt>AbstractMesh::serialize</tt> checkpoints the mesh's <tt>DistributedVectorFactory</tt> to the process-specific archive.  This may be NULL in some cases (when we're not a <tt>DistributedTetrahedralMesh</tt>?).)  It unsets the member variable temporarily, saving it to <tt>p_factory</tt>, and sets <tt>p_our_factory</tt> to the original factory or NULL.  If there is an original factory and the number of processes matches, then <tt>SetDistributedVectorFactory</tt> is called to force use of the same partition as before; otherwise <tt>p_our_factory</tt> is set to NULL to allow repartitioning.  We then <tt>ConstructFromMeshReader</tt>.  Finally, <tt>mpDistributedVectorFactory</tt> needs to be changed to point to <tt>p_factory</tt> so all objects use the same factory, and <tt>p_factory</tt> updated if it exists and we repartitioned using <tt>p_factory-&gt;SetFromFactory(this-&gt;mpDistributedVectorFactory)</tt> (which clears <tt>mGlobalLows</tt> and sets <tt>mLo</tt> and <tt>mHi</tt>).
</p>
<h2 id="Othernotes">Other notes</h2>
<h3 id="Usingbinaryarchives">Using binary archives</h3>
<p>
Binary archives are faster to save and load, and take less disk space. 
The disadvantages are that they become machine/architecture specific, and you can't just look in the file to see what's changed, or check class names are exported correctly. 
But if you are implementing archiving for a personal / science project it can be worth using them. 
The <tt>src</tt> implementation is unchanged, the tests that write/read the archives just need to use:
</p>
<pre class="wiki">boost::archive::binary_iarchive
boost::archive::binary_oarchive
</pre><p>
instead of 
</p>
<pre class="wiki">boost::archive::text_iarchive
boost::archive::text_oarchive
</pre><p>
in all of the above example code. This can speed things up considerably, and also reduce archive file sizes (see <a class="missing ticket">#2520</a>). It's easy to simply load an ascii archive and re-save in binary, or vice-versa, if you need to.
</p>
<h3 id="Compressingthearchive">Compressing the archive</h3>
<p>
Note that archive compression needs <tt>libboost_iostreams</tt> adding to the library paths on compilation. You can find the line in your hostconfig that looks like
</p>
<pre class="wiki">boost_libs = ['boost_serialization', 'boost_filesystem', 'boost_system']
</pre><p>
and add <tt>'boost_iostreams'</tt> to the list.
</p>
<p>
The standard way of using archives now becomes a bit more complicated with an intermediate stream buffer that takes care of translating between boost archiving and the raw filestream.
The below code is an altered version of the above standard test/use of archiving.
</p>
<div class="code"><pre><span class="cp">#include "CheckpointArchiveTypes.hpp"
</span>
<span class="c1">// For compressing output
</span><span class="cp">#include &lt;boost/iostreams/filtering_stream.hpp&gt;
#include &lt;boost/iostreams/filter/zlib.hpp&gt;
</span>
<span class="kt">void</span> <span class="nf">TestArchivingOfConcreteClass</span><span class="p">()</span> <span class="k">throw</span><span class="p">(</span>Exception<span class="p">)</span>
<span class="p">{</span>
    OutputFileHandler handler<span class="p">(</span><span class="s">"archive"</span><span class="p">,</span><span class="nb">false</span><span class="p">);</span> 
    std<span class="o">::</span>string archive_filename <span class="o">=</span> handler<span class="p">.</span>GetOutputDirectoryFullPath<span class="p">()</span> <span class="o">+</span> <span class="s">"ConcreteClass.arch"</span><span class="p">;</span>

    <span class="c1">// Create data structures to store variables to test for equality here
</span>
    <span class="p">{</span>
        AbstractClass<span class="o">*</span> <span class="k">const</span> p_abstract_class <span class="o">=</span> <span class="k">new</span> ConcreteClass<span class="p">();</span>
            
        <span class="c1">// Create an output file
</span>        std<span class="o">::</span>ofstream ofs<span class="p">(</span>archive_filename<span class="p">.</span>c_str<span class="p">());</span>

        <span class="c1">// But instead of boost archive directly using this, pass boost archive
</span>        <span class="c1">// to a new boost filtered_ostream, and add a compressor to the filtered_ostream.
</span>        boost<span class="o">::</span>iostreams<span class="o">::</span>filtering_ostream out<span class="p">;</span>
        boost<span class="o">::</span>iostreams<span class="o">::</span>zlib_params zp<span class="p">(</span>boost<span class="o">::</span>iostreams<span class="o">::</span>zlib<span class="o">::</span>best_speed<span class="p">);</span>
        out<span class="p">.</span>push<span class="p">(</span>boost<span class="o">::</span>iostreams<span class="o">::</span>zlib_compressor<span class="p">(</span>zp<span class="p">));</span>
        out<span class="p">.</span>push<span class="p">(</span>ofs<span class="p">);</span>

        <span class="c1">// As normal, but boost archive goes via the filtering_ostream instead of directly to the ostream.
</span>        boost<span class="o">::</span>archive<span class="o">::</span>text_oarchive output_arch<span class="p">(</span>out<span class="p">);</span>

        <span class="c1">// Record values to test into data structures
</span>        <span class="c1">// If necessary you can use static_cast&lt;ConcreteClass*&gt;(p_abstract_class)
</span>        <span class="c1">// (if your abstract class doesn't contain the necessary variables and methods)
</span>            
        output_arch <span class="o">&lt;&lt;</span> p_abstract_class<span class="p">;</span>
        <span class="k">delete</span> p_abstract_class<span class="p">;</span>
    <span class="p">}</span>

    <span class="p">{</span>
        AbstractClass<span class="o">*</span> p_abstract_class_2<span class="p">;</span>

        <span class="c1">// Read from this input archive
</span>        std<span class="o">::</span>ifstream ifs<span class="p">(</span>archive_filename<span class="p">.</span>c_str<span class="p">(),</span> std<span class="o">::</span>ios<span class="o">::</span>binary<span class="p">);</span>

        <span class="c1">// Set up the compressed reader filtering stream
</span>        boost<span class="o">::</span>iostreams<span class="o">::</span>filtering_istream in<span class="p">;</span>
        boost<span class="o">::</span>iostreams<span class="o">::</span>zlib_params zp<span class="p">(</span>boost<span class="o">::</span>iostreams<span class="o">::</span>zlib<span class="o">::</span>best_speed<span class="p">);</span>
        in<span class="p">.</span>push<span class="p">(</span>boost<span class="o">::</span>iostreams<span class="o">::</span>zlib_decompressor<span class="p">(</span>zp<span class="p">));</span>
        in<span class="p">.</span>push<span class="p">(</span>ifs<span class="p">);</span>

        <span class="c1">// Copy boost archive input stream reads via the filtered stream, which does uncompression.
</span>        boost<span class="o">::</span>archive<span class="o">::</span>text_iarchive input_arch<span class="p">(</span>in<span class="p">);</span>

        <span class="c1">// restore from the archive
</span>        input_arch <span class="o">&gt;&gt;</span> p_abstract_class_2<span class="p">;</span>

        <span class="c1">// Check things in the data structures with TS_ASSERTS here.
</span>        <span class="c1">// If necessary you can use static_cast&lt;ConcreteClass*&gt;(p_abstract_class_2)
</span>        <span class="c1">// (if your abstract class doesn't contain the necessary variables and methods)
</span>
        <span class="k">delete</span> p_abstract_class_2<span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div>
          

    </div>
  </body>
</html>
