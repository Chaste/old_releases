<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>UserTutorials/CreatingAndUsingANewCellKiller - Chaste</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="/trac-static/css/trac.css" type="text/css" />
    <link rel="stylesheet" href="/trac-static/css/wiki.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="/trac-static/css/site.css" />
  </head>
  <body>
    <div id="banner">
      <div id="header">
        <p>
          <a id="logo" href="http://www.cs.ox.ac.uk/chaste"><img src="/logos/chaste-266x60.jpg" alt="Chaste logo" height="60" width="266" /></a>
          <em>Documentation for <a href="/chaste/tutorials/release_3.3/">Release 3.3</a>.</em>
        </p>
      </div>
    </div>
    <p>&nbsp;</p>
    <div id="content" class="wiki">
      <div class="wikipage searchable">
        
          <div id="wikipage" class="trac-content"><p>
This tutorial is automatically generated from the file trunk/cell_based/test/tutorial/TestCreatingAndUsingANewCellKillerTutorial.hpp at revision <a class="missing changeset" title="No permission to view changeset 23343 on (default)">r23343</a>.
Note that the code is given in full at the bottom of the page.
</p>
<h1 id="Anexampleshowinghowtocreateanewcellkilleranduseitinacell-basedsimulation">An example showing how to create a new cell killer and use it in a cell-based simulation</h1>
<h2 id="Introduction">Introduction</h2>
<p>
In the crypt tutorial, we used an existing cell killer class to define
how cells were sloughed off the top of a crypt. In this tutorial we show
how to create a new cell killer class, and how this can be used in a cell-based
simulation.
</p>
<h2 id="a1.Includingheaderfiles">1. Including header files</h2>
<p>
As in previous cell-based Chaste tutorials, we begin by including the necessary
header file and archiving headers.
</p>
<div class="code"><pre><span class="cp">#include &lt;cxxtest/TestSuite.h&gt;
#include "CheckpointArchiveTypes.hpp"
#include "AbstractCellBasedTestSuite.hpp"
</span>
<span class="cp">#include &lt;boost/archive/text_oarchive.hpp&gt;
#include &lt;boost/archive/text_iarchive.hpp&gt;
</span>
</pre></div><p>
The next header defines a base class for cell killers, from which the new
cell killer class will inherit.
</p>
<div class="code"><pre><span class="cp">#include "AbstractCellKiller.hpp"
</span></pre></div><p>
The remaining header files define classes that will be used in the cell-based
simulation test. We have encountered each of these header files in previous cell-based
Chaste tutorials.
</p>
<div class="code"><pre><span class="cp">#include "HoneycombMeshGenerator.hpp"
#include "FixedDurationGenerationBasedCellCycleModel.hpp"
#include "GeneralisedLinearSpringForce.hpp"
#include "OffLatticeSimulation.hpp"
#include "CellsGenerator.hpp"
#include "SmartPointers.hpp"
</span><span class="c1">//This test is always run sequentially (never in parallel)
</span><span class="cp">#include "FakePetscSetup.hpp"
</span>
</pre></div><h2 id="Definingthecellkillerclass">Defining the cell killer class</h2>
<p>
As an example, let us consider a cell killer that labels any cells in a
two-dimensional cell population which lie outside the elliptical domain given in
Cartesian coordinates by the equation (<em>x</em>/20)<sup>2</sup> + (<em>y</em>/10)<sup>2</sup> &lt; 1. To
implement this we define a new cell killer class, <tt>MyCellKiller</tt>,
which inherits from <tt>AbstractCellKiller</tt> and overrides the
<tt>CheckAndLabelCellsForApoptosisOrDeath()</tt> method.
</p>
<p>
Note that usually this code would be separated out into a separate declaration in
a .hpp file and definition in a .cpp file.
</p>
<div class="code"><pre><span class="k">class</span> <span class="nc">MyCellKiller</span> <span class="o">:</span> <span class="k">public</span> AbstractCellKiller<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="nl">private:</span>

    <span class="k">friend</span> <span class="k">class</span> <span class="nc">boost</span><span class="o">::</span>serialization<span class="o">::</span>access<span class="p">;</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Archive</span><span class="o">&gt;</span>
    <span class="kt">void</span> serialize<span class="p">(</span>Archive <span class="o">&amp;</span> archive<span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> version<span class="p">)</span>
    <span class="p">{</span>
        archive <span class="o">&amp;</span> boost<span class="o">::</span>serialization<span class="o">::</span>base_object<span class="o">&lt;</span>AbstractCellKiller<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>

</pre></div><p>
The first public method is a default constructor, which just calls the base
constructor.
</p>
<div class="code"><pre><span class="nl">public:</span>

    MyCellKiller<span class="p">(</span>AbstractCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;*</span> pCellPopulation<span class="p">)</span>
        <span class="o">:</span> AbstractCellKiller<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span>pCellPopulation<span class="p">)</span>
    <span class="p">{}</span>

</pre></div><p>
The second public method overrides <tt>CheckAndLabelCellsForApoptosisOrDeath()</tt>.
This method iterates over all cells in the population, and calls <tt>Kill()</tt> on
any cell whose centre is located outside the ellipse (<em>x</em>/20)<sup>2</sup> + (<em>y</em>/10)<sup>2</sup> &lt; 1.
</p>
<div class="code"><pre>    <span class="kt">void</span> <span class="nf">CheckAndLabelCellsForApoptosisOrDeath</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span>AbstractCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>Iterator cell_iter <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span>mpCellPopulation<span class="o">-&gt;</span>Begin<span class="p">();</span>
            cell_iter <span class="o">!=</span> <span class="k">this</span><span class="o">-&gt;</span>mpCellPopulation<span class="o">-&gt;</span>End<span class="p">();</span>
            <span class="o">++</span>cell_iter<span class="p">)</span>
        <span class="p">{</span>
            c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> location <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span>mpCellPopulation<span class="o">-&gt;</span>GetLocationOfCellCentre<span class="p">(</span><span class="o">*</span>cell_iter<span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span>pow<span class="p">(</span>location<span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">20</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> pow<span class="p">(</span>location<span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="p">{</span>
                cell_iter<span class="o">-&gt;</span>Kill<span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

</pre></div><p>
The final public method overrides <tt>OutputCellKillerParameters()</tt>.
This method outputs any member variables to a specified results file <tt>rParamsFile</tt>.
In our case, there are no parameters, so we simply call the method on the base class.
Nonetheless, we still need to override the method, since it is pure virtual in the base
class.
</p>
<div class="code"><pre>    <span class="kt">void</span> <span class="nf">OutputCellKillerParameters</span><span class="p">(</span>out_stream<span class="o">&amp;</span> rParamsFile<span class="p">)</span>
    <span class="p">{</span>
        AbstractCellKiller<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>OutputCellKillerParameters<span class="p">(</span>rParamsFile<span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

</pre></div><p>
As mentioned in <a class="wiki" href="/chaste/tutorials/release_3.3/UserTutorials/CreatingAndUsingANewCellCycleModel.html">UserTutorials/CreatingAndUsingANewCellCycleModel</a>, we need to include the next block
of code to be able to archive the cell killer object in a cell-based
simulation, and to obtain a unique identifier for our new cell killer for writing
results to file.
</p>
<div class="code"><pre><span class="cp">#include "SerializationExportWrapper.hpp"
</span>CHASTE_CLASS_EXPORT<span class="p">(</span>MyCellKiller<span class="p">)</span>
<span class="cp">#include "SerializationExportWrapperForCpp.hpp"
</span>CHASTE_CLASS_EXPORT<span class="p">(</span>MyCellKiller<span class="p">)</span>

</pre></div><p>
We only need to include the next block of code if we wish to be able to archive (save or load)
the cell killer object in a cell-based simulation. We must define <tt>save_construct_data</tt> and
<tt>load_construct_data</tt> methods, which archive the cell killer constructor input argument(s)
(in this case, a <tt>CellPopulation</tt>).
</p>
<div class="code"><pre><span class="k">namespace</span> boost
<span class="p">{</span>
    <span class="k">namespace</span> serialization
    <span class="p">{</span>
        <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Archive</span><span class="o">&gt;</span>
        <span class="kr">inline</span> <span class="kt">void</span> save_construct_data<span class="p">(</span>
            Archive <span class="o">&amp;</span> ar<span class="p">,</span> <span class="k">const</span> MyCellKiller <span class="o">*</span> t<span class="p">,</span> <span class="k">const</span> BOOST_PFTO <span class="kt">unsigned</span> <span class="kt">int</span> file_version<span class="p">)</span>
        <span class="p">{</span>
            <span class="k">const</span> AbstractCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;*</span> <span class="k">const</span> p_cell_population <span class="o">=</span> t<span class="o">-&gt;</span>GetCellPopulation<span class="p">();</span>
            ar <span class="o">&lt;&lt;</span> p_cell_population<span class="p">;</span>
        <span class="p">}</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Archive</span><span class="o">&gt;</span>
        <span class="kr">inline</span> <span class="kt">void</span> load_construct_data<span class="p">(</span>
            Archive <span class="o">&amp;</span> ar<span class="p">,</span> MyCellKiller <span class="o">*</span> t<span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> file_version<span class="p">)</span>
        <span class="p">{</span>
            AbstractCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;*</span> p_cell_population<span class="p">;</span>
            ar <span class="o">&gt;&gt;</span> p_cell_population<span class="p">;</span>

            <span class="c1">// Invoke inplace constructor to initialise instance
</span>            <span class="o">::</span><span class="k">new</span><span class="p">(</span>t<span class="p">)</span>MyCellKiller<span class="p">(</span>p_cell_population<span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

</pre></div><p>
This completes the code for <tt>MyCellKiller</tt>. Note that usually this code
would be separated out into a separate declaration in a .hpp file and definition
in a .cpp file.
</p>
<h3 id="TheTests">The Tests</h3>
<p>
We now define the test class, which inherits from <tt>AbstractCellBasedTestSuite</tt>.
</p>
<div class="code"><pre><span class="k">class</span> <span class="nc">TestCreatingAndUsingANewCellKillerTutorial</span> <span class="o">:</span> <span class="k">public</span> AbstractCellBasedTestSuite
<span class="p">{</span>
<span class="nl">public:</span>

</pre></div><h2 id="Testingthecellkiller">Testing the cell killer</h2>
<p>
We begin by testing that our new cell-cycle model is implemented correctly.
</p>
<div class="code"><pre>    <span class="kt">void</span> <span class="nf">TestMyCellKiller</span><span class="p">()</span> <span class="k">throw</span><span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
</pre></div><p>
We use the honeycomb mesh generator to create a honeycomb mesh.
</p>
<div class="code"><pre>        HoneycombMeshGenerator <span class="nf">generator</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        MutableMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetMesh<span class="p">();</span>

</pre></div><p>
We then construct and initialise some cells, each with a
<tt>FixedDurationGenerationBasedCellCycleModel</tt>, using the helper class
<tt>CellsGenerator</tt>.
</p>
<div class="code"><pre>        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        CellsGenerator<span class="o">&lt;</span>FixedDurationGenerationBasedCellCycleModel<span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> cells_generator<span class="p">;</span>
        cells_generator<span class="p">.</span>GenerateBasic<span class="p">(</span>cells<span class="p">,</span> p_mesh<span class="o">-&gt;</span>GetNumNodes<span class="p">());</span>

</pre></div><p>
Now that we have defined the mesh and cells, we can define the cell population. The
constructor takes in the mesh and the cells vector.
</p>
<div class="code"><pre>        MeshBasedCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">);</span>

</pre></div><p>
We now use the cell population to construct a cell killer object.
</p>
<div class="code"><pre>        MyCellKiller <span class="nf">my_cell_killer</span><span class="p">(</span><span class="o">&amp;</span>cell_population<span class="p">);</span>

</pre></div><p>
To test that we have implemented the cell killer correctly, we call the
overridden method <tt>CheckAndLabelCellsForApoptosisOrDeath</tt>...
</p>
<div class="code"><pre>        my_cell_killer<span class="p">.</span>CheckAndLabelCellsForApoptosisOrDeath<span class="p">();</span>

</pre></div><p>
... and check that any cell whose centre is located outside the ellipse
(<em>x</em>/20)<sup>2</sup> + (<em>y</em>/10)<sup>2</sup> &lt; 1 has indeed been labelled as dead.
</p>
<div class="code"><pre>        <span class="k">for</span> <span class="p">(</span>AbstractCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>Iterator cell_iter <span class="o">=</span> cell_population<span class="p">.</span>Begin<span class="p">();</span>
             cell_iter <span class="o">!=</span> cell_population<span class="p">.</span>End<span class="p">();</span>
             <span class="o">++</span>cell_iter<span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">double</span> x <span class="o">=</span> cell_population<span class="p">.</span>GetLocationOfCellCentre<span class="p">(</span><span class="o">*</span>cell_iter<span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
            <span class="kt">double</span> y <span class="o">=</span> cell_population<span class="p">.</span>GetLocationOfCellCentre<span class="p">(</span><span class="o">*</span>cell_iter<span class="p">)[</span><span class="mi">1</span><span class="p">];</span>

            <span class="k">if</span> <span class="p">(</span>pow<span class="p">(</span>x<span class="o">/</span><span class="mi">20</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> pow<span class="p">(</span>y<span class="o">/</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="p">{</span>
                TS_ASSERT_EQUALS<span class="p">(</span>cell_iter<span class="o">-&gt;</span>IsDead<span class="p">(),</span> <span class="nb">true</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                TS_ASSERT_EQUALS<span class="p">(</span>cell_iter<span class="o">-&gt;</span>IsDead<span class="p">(),</span> <span class="nb">false</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

</pre></div><p>
As an extra test, we now remove any dead cells and check that all
remaining cells are indeed located within the ellipse.
</p>
<div class="code"><pre>        cell_population<span class="p">.</span>RemoveDeadCells<span class="p">();</span>

        <span class="k">for</span> <span class="p">(</span>AbstractCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>Iterator cell_iter <span class="o">=</span> cell_population<span class="p">.</span>Begin<span class="p">();</span>
             cell_iter <span class="o">!=</span> cell_population<span class="p">.</span>End<span class="p">();</span>
             <span class="o">++</span>cell_iter<span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">double</span> x <span class="o">=</span> cell_population<span class="p">.</span>GetLocationOfCellCentre<span class="p">(</span><span class="o">*</span>cell_iter<span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
            <span class="kt">double</span> y <span class="o">=</span> cell_population<span class="p">.</span>GetLocationOfCellCentre<span class="p">(</span><span class="o">*</span>cell_iter<span class="p">)[</span><span class="mi">1</span><span class="p">];</span>

            TS_ASSERT_LESS_THAN_EQUALS<span class="p">(</span>pow<span class="p">(</span>x<span class="o">/</span><span class="mi">20</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> pow<span class="p">(</span>y<span class="o">/</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
        <span class="p">}</span>

</pre></div><p>
The last chunk of code provides an archiving test for the cell killer.
We create an output archive, save the existing cell killer object via
a pointer, then create an input archive and load the cell killer. If
the cell killer had any member variables, then we would test that these
were correctly initialised when the cell killer is loaded.
</p>
<div class="code"><pre>        OutputFileHandler <span class="nf">handler</span><span class="p">(</span><span class="s">"archive"</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
        std<span class="o">::</span>string archive_filename <span class="o">=</span> handler<span class="p">.</span>GetOutputDirectoryFullPath<span class="p">()</span> <span class="o">+</span> <span class="s">"my_cell_killer.arch"</span><span class="p">;</span>

        <span class="p">{</span>
            AbstractCellKiller<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;*</span> <span class="k">const</span> p_cell_killer <span class="o">=</span> <span class="k">new</span> MyCellKiller<span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

            std<span class="o">::</span>ofstream ofs<span class="p">(</span>archive_filename<span class="p">.</span>c_str<span class="p">());</span>
            boost<span class="o">::</span>archive<span class="o">::</span>text_oarchive output_arch<span class="p">(</span>ofs<span class="p">);</span>

            output_arch <span class="o">&lt;&lt;</span> p_cell_killer<span class="p">;</span>
            <span class="k">delete</span> p_cell_killer<span class="p">;</span>
        <span class="p">}</span>

        <span class="p">{</span>
            std<span class="o">::</span>ifstream ifs<span class="p">(</span>archive_filename<span class="p">.</span>c_str<span class="p">(),</span> std<span class="o">::</span>ios<span class="o">::</span>binary<span class="p">);</span>
            boost<span class="o">::</span>archive<span class="o">::</span>text_iarchive input_arch<span class="p">(</span>ifs<span class="p">);</span>

            AbstractCellKiller<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;*</span> p_cell_killer<span class="p">;</span>

            input_arch <span class="o">&gt;&gt;</span> p_cell_killer<span class="p">;</span>
            <span class="k">delete</span> p_cell_killer<span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

</pre></div><h2 id="Usingthecellkillerinacell-basedsimulation">Using the cell killer in a cell-based simulation</h2>
<p>
We now provide a test demonstrating how <tt>MyCellKiller</tt> can be used
in a cell-based simulation.
</p>
<div class="code"><pre>    <span class="kt">void</span> <span class="nf">TestOffLatticeSimulationWithMyCellKiller</span><span class="p">()</span> <span class="k">throw</span><span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
</pre></div><p>
We proceed as before, creating a mesh-based cell population.
</p>
<div class="code"><pre>        HoneycombMeshGenerator <span class="nf">generator</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        MutableMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetMesh<span class="p">();</span>

        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        CellsGenerator<span class="o">&lt;</span>FixedDurationGenerationBasedCellCycleModel<span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> cells_generator<span class="p">;</span>
        cells_generator<span class="p">.</span>GenerateBasic<span class="p">(</span>cells<span class="p">,</span> p_mesh<span class="o">-&gt;</span>GetNumNodes<span class="p">());</span>

        MeshBasedCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">);</span>

</pre></div><p>
We now use the cell population to construct a cell killer object. This object
must be added to the cell-based simulation as a boost::shared_ptr, so we make
use of the macro MAKR_PTR_ARGS (defined in the header <tt>SmartPointers.hpp</tt>).
</p>
<div class="code"><pre>        MAKE_PTR_ARGS<span class="p">(</span>MyCellKiller<span class="p">,</span> p_killer<span class="p">,</span> <span class="p">(</span><span class="o">&amp;</span>cell_population<span class="p">));</span>

</pre></div><p>
We then pass in the cell population into an <tt>OffLatticeSimulation</tt>,
and set the output directory and end time.
</p>
<div class="code"><pre>        OffLatticeSimulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> simulator<span class="p">(</span>cell_population<span class="p">);</span>
        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"TestOffLatticeSimulationWithMyCellKiller"</span><span class="p">);</span>
        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>

</pre></div><p>
We create a force law and pass it to the <tt>OffLatticeSimulation</tt>.
</p>
<div class="code"><pre>        MAKE_PTR<span class="p">(</span>GeneralisedLinearSpringForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_linear_force<span class="p">);</span>
        p_linear_force<span class="o">-&gt;</span>SetCutOffLength<span class="p">(</span><span class="mi">3</span><span class="p">);</span>
        simulator<span class="p">.</span>AddForce<span class="p">(</span>p_linear_force<span class="p">);</span>

</pre></div><p>
We now pass the cell killer into the cell-based simulation.
</p>
<div class="code"><pre>        simulator<span class="p">.</span>AddCellKiller<span class="p">(</span>p_killer<span class="p">);</span>

</pre></div><p>
To run the simulation, we call <tt>Solve()</tt>.
</p>
<div class="code"><pre>        simulator<span class="p">.</span>Solve<span class="p">();</span>
    <span class="p">}</span>
</pre></div><p>
When you visualize the results with
</p>
<p>
<tt>java Visualize2dCentreCells /tmp/$USER/testoutput/TestOffLatticeSimulationWithMyCellKiller/results_from_time_0</tt>
</p>
<p>
you should see that once cells move out of the ellipse they are removed from the simulation.
</p>
<div class="code"><pre><span class="p">};</span>

</pre></div><h1 id="Code">Code</h1>
<p>
The full code is given below
</p>
<h2 id="FilenameTestCreatingAndUsingANewCellKillerTutorial.hpp">File name <tt>TestCreatingAndUsingANewCellKillerTutorial.hpp</tt></h2>
<div class="code"><pre><span class="cp">#include &lt;cxxtest/TestSuite.h&gt;
#include "CheckpointArchiveTypes.hpp"
#include "AbstractCellBasedTestSuite.hpp"
</span>
<span class="cp">#include &lt;boost/archive/text_oarchive.hpp&gt;
#include &lt;boost/archive/text_iarchive.hpp&gt;
</span>
<span class="cp">#include "AbstractCellKiller.hpp"
#include "HoneycombMeshGenerator.hpp"
#include "FixedDurationGenerationBasedCellCycleModel.hpp"
#include "GeneralisedLinearSpringForce.hpp"
#include "OffLatticeSimulation.hpp"
#include "CellsGenerator.hpp"
#include "SmartPointers.hpp"
</span><span class="c1">//This test is always run sequentially (never in parallel)
</span><span class="cp">#include "FakePetscSetup.hpp"
</span>
<span class="k">class</span> <span class="nc">MyCellKiller</span> <span class="o">:</span> <span class="k">public</span> AbstractCellKiller<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="nl">private:</span>

    <span class="k">friend</span> <span class="k">class</span> <span class="nc">boost</span><span class="o">::</span>serialization<span class="o">::</span>access<span class="p">;</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Archive</span><span class="o">&gt;</span>
    <span class="kt">void</span> serialize<span class="p">(</span>Archive <span class="o">&amp;</span> archive<span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> version<span class="p">)</span>
    <span class="p">{</span>
        archive <span class="o">&amp;</span> boost<span class="o">::</span>serialization<span class="o">::</span>base_object<span class="o">&lt;</span>AbstractCellKiller<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>

<span class="nl">public:</span>

    MyCellKiller<span class="p">(</span>AbstractCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;*</span> pCellPopulation<span class="p">)</span>
        <span class="o">:</span> AbstractCellKiller<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span>pCellPopulation<span class="p">)</span>
    <span class="p">{}</span>

    <span class="kt">void</span> CheckAndLabelCellsForApoptosisOrDeath<span class="p">()</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span>AbstractCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>Iterator cell_iter <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span>mpCellPopulation<span class="o">-&gt;</span>Begin<span class="p">();</span>
            cell_iter <span class="o">!=</span> <span class="k">this</span><span class="o">-&gt;</span>mpCellPopulation<span class="o">-&gt;</span>End<span class="p">();</span>
            <span class="o">++</span>cell_iter<span class="p">)</span>
        <span class="p">{</span>
            c_vector<span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> location <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span>mpCellPopulation<span class="o">-&gt;</span>GetLocationOfCellCentre<span class="p">(</span><span class="o">*</span>cell_iter<span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span>pow<span class="p">(</span>location<span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">20</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> pow<span class="p">(</span>location<span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="p">{</span>
                cell_iter<span class="o">-&gt;</span>Kill<span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> OutputCellKillerParameters<span class="p">(</span>out_stream<span class="o">&amp;</span> rParamsFile<span class="p">)</span>
    <span class="p">{</span>
        AbstractCellKiller<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>OutputCellKillerParameters<span class="p">(</span>rParamsFile<span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="cp">#include "SerializationExportWrapper.hpp"
</span>CHASTE_CLASS_EXPORT<span class="p">(</span>MyCellKiller<span class="p">)</span>
<span class="cp">#include "SerializationExportWrapperForCpp.hpp"
</span>CHASTE_CLASS_EXPORT<span class="p">(</span>MyCellKiller<span class="p">)</span>

<span class="k">namespace</span> boost
<span class="p">{</span>
    <span class="k">namespace</span> serialization
    <span class="p">{</span>
        <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Archive</span><span class="o">&gt;</span>
        <span class="kr">inline</span> <span class="kt">void</span> save_construct_data<span class="p">(</span>
            Archive <span class="o">&amp;</span> ar<span class="p">,</span> <span class="k">const</span> MyCellKiller <span class="o">*</span> t<span class="p">,</span> <span class="k">const</span> BOOST_PFTO <span class="kt">unsigned</span> <span class="kt">int</span> file_version<span class="p">)</span>
        <span class="p">{</span>
            <span class="k">const</span> AbstractCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;*</span> <span class="k">const</span> p_cell_population <span class="o">=</span> t<span class="o">-&gt;</span>GetCellPopulation<span class="p">();</span>
            ar <span class="o">&lt;&lt;</span> p_cell_population<span class="p">;</span>
        <span class="p">}</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Archive</span><span class="o">&gt;</span>
        <span class="kr">inline</span> <span class="kt">void</span> load_construct_data<span class="p">(</span>
            Archive <span class="o">&amp;</span> ar<span class="p">,</span> MyCellKiller <span class="o">*</span> t<span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> file_version<span class="p">)</span>
        <span class="p">{</span>
            AbstractCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;*</span> p_cell_population<span class="p">;</span>
            ar <span class="o">&gt;&gt;</span> p_cell_population<span class="p">;</span>

            <span class="c1">// Invoke inplace constructor to initialise instance
</span>            <span class="o">::</span><span class="k">new</span><span class="p">(</span>t<span class="p">)</span>MyCellKiller<span class="p">(</span>p_cell_population<span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">TestCreatingAndUsingANewCellKillerTutorial</span> <span class="o">:</span> <span class="k">public</span> AbstractCellBasedTestSuite
<span class="p">{</span>
<span class="nl">public:</span>

    <span class="kt">void</span> TestMyCellKiller<span class="p">()</span> <span class="k">throw</span><span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
        HoneycombMeshGenerator generator<span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        MutableMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetMesh<span class="p">();</span>

        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        CellsGenerator<span class="o">&lt;</span>FixedDurationGenerationBasedCellCycleModel<span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> cells_generator<span class="p">;</span>
        cells_generator<span class="p">.</span>GenerateBasic<span class="p">(</span>cells<span class="p">,</span> p_mesh<span class="o">-&gt;</span>GetNumNodes<span class="p">());</span>

        MeshBasedCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">);</span>

        MyCellKiller <span class="nf">my_cell_killer</span><span class="p">(</span><span class="o">&amp;</span>cell_population<span class="p">);</span>

        my_cell_killer<span class="p">.</span>CheckAndLabelCellsForApoptosisOrDeath<span class="p">();</span>

        <span class="k">for</span> <span class="p">(</span>AbstractCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>Iterator cell_iter <span class="o">=</span> cell_population<span class="p">.</span>Begin<span class="p">();</span>
             cell_iter <span class="o">!=</span> cell_population<span class="p">.</span>End<span class="p">();</span>
             <span class="o">++</span>cell_iter<span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">double</span> x <span class="o">=</span> cell_population<span class="p">.</span>GetLocationOfCellCentre<span class="p">(</span><span class="o">*</span>cell_iter<span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
            <span class="kt">double</span> y <span class="o">=</span> cell_population<span class="p">.</span>GetLocationOfCellCentre<span class="p">(</span><span class="o">*</span>cell_iter<span class="p">)[</span><span class="mi">1</span><span class="p">];</span>

            <span class="k">if</span> <span class="p">(</span>pow<span class="p">(</span>x<span class="o">/</span><span class="mi">20</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> pow<span class="p">(</span>y<span class="o">/</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="p">{</span>
                TS_ASSERT_EQUALS<span class="p">(</span>cell_iter<span class="o">-&gt;</span>IsDead<span class="p">(),</span> <span class="nb">true</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                TS_ASSERT_EQUALS<span class="p">(</span>cell_iter<span class="o">-&gt;</span>IsDead<span class="p">(),</span> <span class="nb">false</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        cell_population<span class="p">.</span>RemoveDeadCells<span class="p">();</span>

        <span class="k">for</span> <span class="p">(</span>AbstractCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;::</span>Iterator cell_iter <span class="o">=</span> cell_population<span class="p">.</span>Begin<span class="p">();</span>
             cell_iter <span class="o">!=</span> cell_population<span class="p">.</span>End<span class="p">();</span>
             <span class="o">++</span>cell_iter<span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">double</span> x <span class="o">=</span> cell_population<span class="p">.</span>GetLocationOfCellCentre<span class="p">(</span><span class="o">*</span>cell_iter<span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
            <span class="kt">double</span> y <span class="o">=</span> cell_population<span class="p">.</span>GetLocationOfCellCentre<span class="p">(</span><span class="o">*</span>cell_iter<span class="p">)[</span><span class="mi">1</span><span class="p">];</span>

            TS_ASSERT_LESS_THAN_EQUALS<span class="p">(</span>pow<span class="p">(</span>x<span class="o">/</span><span class="mi">20</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> pow<span class="p">(</span>y<span class="o">/</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
        <span class="p">}</span>

        OutputFileHandler handler<span class="p">(</span><span class="s">"archive"</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
        std<span class="o">::</span>string archive_filename <span class="o">=</span> handler<span class="p">.</span>GetOutputDirectoryFullPath<span class="p">()</span> <span class="o">+</span> <span class="s">"my_cell_killer.arch"</span><span class="p">;</span>

        <span class="p">{</span>
            AbstractCellKiller<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;*</span> <span class="k">const</span> p_cell_killer <span class="o">=</span> <span class="k">new</span> MyCellKiller<span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

            std<span class="o">::</span>ofstream ofs<span class="p">(</span>archive_filename<span class="p">.</span>c_str<span class="p">());</span>
            boost<span class="o">::</span>archive<span class="o">::</span>text_oarchive output_arch<span class="p">(</span>ofs<span class="p">);</span>

            output_arch <span class="o">&lt;&lt;</span> p_cell_killer<span class="p">;</span>
            <span class="k">delete</span> p_cell_killer<span class="p">;</span>
        <span class="p">}</span>

        <span class="p">{</span>
            std<span class="o">::</span>ifstream ifs<span class="p">(</span>archive_filename<span class="p">.</span>c_str<span class="p">(),</span> std<span class="o">::</span>ios<span class="o">::</span>binary<span class="p">);</span>
            boost<span class="o">::</span>archive<span class="o">::</span>text_iarchive input_arch<span class="p">(</span>ifs<span class="p">);</span>

            AbstractCellKiller<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;*</span> p_cell_killer<span class="p">;</span>

            input_arch <span class="o">&gt;&gt;</span> p_cell_killer<span class="p">;</span>
            <span class="k">delete</span> p_cell_killer<span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> TestOffLatticeSimulationWithMyCellKiller<span class="p">()</span> <span class="k">throw</span><span class="p">(</span>Exception<span class="p">)</span>
    <span class="p">{</span>
        HoneycombMeshGenerator generator<span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        MutableMesh<span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;*</span> p_mesh <span class="o">=</span> generator<span class="p">.</span>GetMesh<span class="p">();</span>

        std<span class="o">::</span>vector<span class="o">&lt;</span>CellPtr<span class="o">&gt;</span> cells<span class="p">;</span>
        CellsGenerator<span class="o">&lt;</span>FixedDurationGenerationBasedCellCycleModel<span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> cells_generator<span class="p">;</span>
        cells_generator<span class="p">.</span>GenerateBasic<span class="p">(</span>cells<span class="p">,</span> p_mesh<span class="o">-&gt;</span>GetNumNodes<span class="p">());</span>

        MeshBasedCellPopulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> cell_population<span class="p">(</span><span class="o">*</span>p_mesh<span class="p">,</span> cells<span class="p">);</span>

        MAKE_PTR_ARGS<span class="p">(</span>MyCellKiller<span class="p">,</span> p_killer<span class="p">,</span> <span class="p">(</span><span class="o">&amp;</span>cell_population<span class="p">));</span>

        OffLatticeSimulation<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> simulator<span class="p">(</span>cell_population<span class="p">);</span>
        simulator<span class="p">.</span>SetOutputDirectory<span class="p">(</span><span class="s">"TestOffLatticeSimulationWithMyCellKiller"</span><span class="p">);</span>
        simulator<span class="p">.</span>SetEndTime<span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>

        MAKE_PTR<span class="p">(</span>GeneralisedLinearSpringForce<span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> p_linear_force<span class="p">);</span>
        p_linear_force<span class="o">-&gt;</span>SetCutOffLength<span class="p">(</span><span class="mi">3</span><span class="p">);</span>
        simulator<span class="p">.</span>AddForce<span class="p">(</span>p_linear_force<span class="p">);</span>

        simulator<span class="p">.</span>AddCellKiller<span class="p">(</span>p_killer<span class="p">);</span>

        simulator<span class="p">.</span>Solve<span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

</pre></div></div>
          

    </div>
  </body>
</html>
